import fs from 'fs';
import constants$1 from 'constants';
import require$$0 from 'stream';
import util$1 from 'util';
import assert from 'assert';
import path$1 from 'path';
import crypto from 'crypto';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global_1 =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
  // eslint-disable-next-line no-new-func
  Function('return this')();

var fails = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var descriptors = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

var objectPropertyIsEnumerable = {
	f: f
};

var createPropertyDescriptor = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var toString = {}.toString;

var classofRaw = function (it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

// toObject with fallback for non-array-like ES3 strings



var toIndexedObject = function (it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty$1 = {}.hasOwnProperty;

var has = function (it, key) {
  return hasOwnProperty$1.call(it, key);
};

var document$1 = global_1.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document$1) && isObject(document$1.createElement);

var documentCreateElement = function (it) {
  return EXISTS ? document$1.createElement(it) : {};
};

// Thank's IE8 for his funny defineProperty
var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};

var objectGetOwnPropertyDescriptor = {
	f: f$1
};

var anObject = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var objectDefineProperty = {
	f: f$2
};

var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function (key, value) {
  try {
    createNonEnumerableProperty(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  } return value;
};

var SHARED = '__core-js_shared__';
var store = global_1[SHARED] || setGlobal(SHARED, {});

var sharedStore = store;

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof sharedStore.inspectSource != 'function') {
  sharedStore.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

var inspectSource = sharedStore.inspectSource;

var WeakMap = global_1.WeakMap;

var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

var shared = createCommonjsModule(function (module) {
(module.exports = function (key, value) {
  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.5',
  mode:  'global',
  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});
});

var id = 0;
var postfix = Math.random();

var uid = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};

var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function (it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (nativeWeakMap) {
  var store$1 = new WeakMap$1();
  var wmget = store$1.get;
  var wmhas = store$1.has;
  var wmset = store$1.set;
  set = function (it, metadata) {
    wmset.call(store$1, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store$1, it) || {};
  };
  has$1 = function (it) {
    return wmhas.call(store$1, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return has(it, STATE) ? it[STATE] : {};
  };
  has$1 = function (it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor
};

var redefine = createCommonjsModule(function (module) {
var getInternalState = internalState.get;
var enforceInternalState = internalState.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global_1) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});
});

var path = global_1;

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
var toInteger = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
var toLength = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

var indexOf = arrayIncludes.indexOf;


var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

// IE8- don't enum bug keys
var enumBugKeys = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
	f: f$3
};

var f$4 = Object.getOwnPropertySymbols;

var objectGetOwnPropertySymbols = {
	f: f$4
};

// all object keys, includes non-enumerable and symbols
var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

var isForced_1 = isForced;

var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

var useSymbolAsUid = nativeSymbol
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
};

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
var toObject = function (argument) {
  return Object(requireObjectCoercible(argument));
};

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
};

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
  return O;
};

var html = getBuiltIn('document', 'documentElement');

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

var toString$1 = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var f$5 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};

var objectGetOwnPropertyNamesExternal = {
	f: f$5
};

var WellKnownSymbolsStore = shared('wks');
var Symbol$1 = global_1.Symbol;
var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

var wellKnownSymbol = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};

var f$6 = wellKnownSymbol;

var wellKnownSymbolWrapped = {
	f: f$6
};

var defineProperty = objectDefineProperty.f;

var defineWellKnownSymbol = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wellKnownSymbolWrapped.f(NAME)
  });
};

var defineProperty$1 = objectDefineProperty.f;



var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var setToStringTag = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty$1(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};

var aFunction$1 = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};

// optional / simple context binding
var functionBindContext = function (fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod$1 = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = functionBindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod$1(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod$1(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod$1(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod$1(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod$1(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1(6)
};

var $forEach = arrayIteration.forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE$1 = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = internalState.set;
var getInternalState = internalState.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE$1];
var $Symbol = global_1.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var nativeDefineProperty$1 = objectDefineProperty.f;
var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore$1 = shared('wks');
var QObject = global_1.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = descriptors && fails(function () {
  return objectCreate(nativeDefineProperty$1({}, 'a', {
    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty$1(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty$1;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!descriptors) symbol.description = description;
  return symbol;
};

var isSymbol = useSymbolAsUid ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty$1(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!nativeSymbol) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
  objectDefineProperty.f = $defineProperty;
  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

  wellKnownSymbolWrapped.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (descriptors) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
  defineWellKnownSymbol(name);
});

_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return objectGetOwnPropertySymbols.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;

var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

var process$1 = global_1.process;
var versions = process$1 && process$1.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (engineUserAgent) {
  match = engineUserAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = engineUserAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

var engineV8Version = version && +version;

var SPECIES$1 = wellKnownSymbol('species');

var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return engineV8Version >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$1] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var defineProperty$2 = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

var arrayMethodUsesToLength = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !descriptors) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty$2(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};

var $filter = arrayIteration.filter;



var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: objectCreate(null)
  });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

var $find = arrayIteration.find;



var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$1 }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);

var arrayMethodIsStrict = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};

var $forEach$1 = arrayIteration.forEach;



var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH$2 = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
var arrayForEach = (!STRICT_METHOD || !USES_TO_LENGTH$2) ? function forEach(callbackfn /* , thisArg */) {
  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
  forEach: arrayForEach
});

var nativeJoin = [].join;

var ES3_STRINGS = indexedObject != Object;
var STRICT_METHOD$1 = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
_export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$1 }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

var $map = arrayIteration.map;



var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH$3 = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$3 }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD$2 = arrayMethodIsStrict('sort');

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$2;

// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
_export({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? nativeSort.call(toObject(this))
      : nativeSort.call(toObject(this), aFunction$1(comparefn));
  }
});

var defineProperty$3 = objectDefineProperty.f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (descriptors && !(NAME in FunctionPrototype)) {
  defineProperty$3(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
  defineProperties: objectDefineProperties
});

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
  defineProperty: objectDefineProperty.f
});

var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;


var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor$2(1); });
var FORCED$1 = !descriptors || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
_export({ target: 'Object', stat: true, forced: FORCED$1, sham: !descriptors }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
  }
});

var createProperty = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
_export({ target: 'Object', stat: true, sham: !descriptors }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});

var FAILS_ON_PRIMITIVES$1 = fails(function () { objectKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$1 }, {
  keys: function keys(it) {
    return objectKeys(toObject(it));
  }
});

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

for (var COLLECTION_NAME in domIterables) {
  var Collection = global_1[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
  } catch (error) {
    CollectionPrototype.forEach = arrayForEach;
  }
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var regenerator = runtime_1;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
    else {
      return new Promise((resolve, reject) => {
        fn.apply(
          this,
          args.concat([(err, res) => err ? reject(err) : resolve(res)])
        );
      })
    }
  }, 'name', { value: fn.name })
};

var fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, args)
    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name })
};

var universalify = {
	fromCallback: fromCallback,
	fromPromise: fromPromise
};

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd
};
try {
  process.cwd();
} catch (er) {}

var chdir = process.chdir;
process.chdir = function(d) {
  cwd = null;
  chdir.call(process, d);
};

var polyfills = patch;

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants$1.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = (function (fs$rename) { return function (from, to, cb) {
      var start = Date.now();
      var backoff = 0;
      fs$rename(from, to, function CB (er) {
        if (er
            && (er.code === "EACCES" || er.code === "EPERM")
            && Date.now() - start < 60000) {
          setTimeout(function() {
            fs.stat(to, function (stater, st) {
              if (stater && stater.code === "ENOENT")
                fs$rename(from, to, CB);
              else
                cb(er);
            });
          }, backoff);
          if (backoff < 100)
            backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    }})(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    read.__proto__ = fs$read;
    return read
  })(fs.read);

  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0;
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++;
          continue
        }
        throw er
      }
    }
  }})(fs.readSync);

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants$1.O_WRONLY | constants$1.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err);
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2);
          });
        });
      });
    };

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants$1.O_WRONLY | constants$1.O_SYMLINK, mode);

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true;
      var ret;
      try {
        ret = fs.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret
    };
  }

  function patchLutimes (fs) {
    if (constants$1.hasOwnProperty("O_SYMLINK")) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants$1.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er);
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2);
            });
          });
        });
      };

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants$1.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd);
            } catch (er) {}
          } else {
            fs.closeSync(fd);
          }
        }
        return ret
      };

    } else {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
      fs.lutimesSync = function () {};
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options;
        options = null;
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target);
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}

var Stream = require$$0.Stream;

var legacyStreams = legacy;

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

var clone_1 = clone;

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: obj.__proto__ };
  else
    var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy
}

var gracefulFs = createCommonjsModule(function (module) {
/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue;
var previousSymbol;

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue');
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous');
} else {
  gracefulQueue = '___graceful-fs.queue';
  previousSymbol = '___graceful-fs.previous';
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  });
}

var debug = noop;
if (util$1.debuglog)
  debug = util$1.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util$1.format.apply(util$1, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
  };

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs, queue);

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          retry();
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments);
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close
  })(fs.close);

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments);
      retry();
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync
  })(fs.closeSync);

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue]);
      assert.equal(fs[gracefulQueue].length, 0);
    });
  }
}

if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs[gracefulQueue]);
}

module.exports = patch(clone_1(fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch;

  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile)
    fs.appendFile = appendFile;
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null;

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir (path, options, cb) {
    var args = [path];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files && files.sort)
        files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
        enqueue([go$readdir, [args]]);

      else {
        if (typeof cb === 'function')
          cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacyStreams(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }

  var fs$WriteStream = fs.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  // legacy names
  var FileReadStream = ReadStream;
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open;
  fs.open = open;
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null;

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb]]);
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments);
          retry();
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  fs[gracefulQueue].push(elem);
}

function retry () {
  var elem = fs[gracefulQueue].shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}
});

var fs_1 = createCommonjsModule(function (module, exports) {
// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = universalify.fromCallback;


const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchmod',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.opendir was added in Node.js v12.12.0
  // fs.lchown is not available on at least some Linux
  return typeof gracefulFs[key] === 'function'
});

// Export all keys:
Object.keys(gracefulFs).forEach(key => {
  if (key === 'promises') {
    // fs.promises is a getter property that triggers ExperimentalWarning
    // Don't re-export it here, the getter is defined in "lib/index.js"
    return
  }
  exports[key] = gracefulFs[key];
});

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(gracefulFs[method]);
});

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return gracefulFs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return gracefulFs.exists(filename, resolve)
  })
};

// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return gracefulFs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    gracefulFs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer });
    });
  })
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return gracefulFs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    gracefulFs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer });
    });
  })
};

// fs.writev only available in Node v12.9.0+
if (typeof gracefulFs.writev === 'function') {
  // Function signature is
  // s.writev(fd, buffers[, position], callback)
  // We need to handle the optional arg, so we use ...args
  exports.writev = function (fd, buffers, ...args) {
    if (typeof args[args.length - 1] === 'function') {
      return gracefulFs.writev(fd, buffers, ...args)
    }

    return new Promise((resolve, reject) => {
      gracefulFs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
        if (err) return reject(err)
        resolve({ bytesWritten, buffers });
      });
    })
  };
}

// fs.realpath.native only available in Node v9.2+
if (typeof gracefulFs.realpath.native === 'function') {
  exports.realpath.native = u(gracefulFs.realpath.native);
}
});

var atLeastNode = r => {
  const n = process.versions.node.split('.').map(x => parseInt(x, 10));
  r = r.split('.').map(x => parseInt(x, 10));
  return n[0] > r[0] || (n[0] === r[0] && (n[1] > r[1] || (n[1] === r[1] && n[2] >= r[2])))
};

const useNativeRecursiveOption = atLeastNode('10.12.0');

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = pth => {
  if (process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$1.parse(pth).root, ''));

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`);
      error.code = 'EINVAL';
      throw error
    }
  }
};

const processOptions = options => {
  const defaults = { mode: 0o777 };
  if (typeof options === 'number') options = { mode: options };
  return { ...defaults, ...options }
};

const permissionError = pth => {
  // This replicates the exception of `fs.mkdir` with native the
  // `recusive` option when run on an invalid drive under Windows.
  const error = new Error(`operation not permitted, mkdir '${pth}'`);
  error.code = 'EPERM';
  error.errno = -4048;
  error.path = pth;
  error.syscall = 'mkdir';
  return error
};

var makeDir_1 = async (input, options) => {
  checkPath(input);
  options = processOptions(options);

  if (useNativeRecursiveOption) {
    const pth = path$1.resolve(input);

    return fs_1.mkdir(pth, {
      mode: options.mode,
      recursive: true
    })
  }

  const make = async pth => {
    try {
      await fs_1.mkdir(pth, options.mode);
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error
      }

      if (error.code === 'ENOENT') {
        if (path$1.dirname(pth) === pth) {
          throw permissionError(pth)
        }

        if (error.message.includes('null bytes')) {
          throw error
        }

        await make(path$1.dirname(pth));
        return make(pth)
      }

      try {
        const stats = await fs_1.stat(pth);
        if (!stats.isDirectory()) {
          // This error is never exposed to the user
          // it is caught below, and the original error is thrown
          throw new Error('The path is not a directory')
        }
      } catch {
        throw error
      }
    }
  };

  return make(path$1.resolve(input))
};

var makeDirSync = (input, options) => {
  checkPath(input);
  options = processOptions(options);

  if (useNativeRecursiveOption) {
    const pth = path$1.resolve(input);

    return fs_1.mkdirSync(pth, {
      mode: options.mode,
      recursive: true
    })
  }

  const make = pth => {
    try {
      fs_1.mkdirSync(pth, options.mode);
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error
      }

      if (error.code === 'ENOENT') {
        if (path$1.dirname(pth) === pth) {
          throw permissionError(pth)
        }

        if (error.message.includes('null bytes')) {
          throw error
        }

        make(path$1.dirname(pth));
        return make(pth)
      }

      try {
        if (!fs_1.statSync(pth).isDirectory()) {
          // This error is never exposed to the user
          // it is caught below, and the original error is thrown
          throw new Error('The path is not a directory')
        }
      } catch {
        throw error
      }
    }
  };

  return make(path$1.resolve(input))
};

var makeDir = {
	makeDir: makeDir_1,
	makeDirSync: makeDirSync
};

const u = universalify.fromPromise;
const { makeDir: _makeDir, makeDirSync: makeDirSync$1 } = makeDir;
const makeDir$1 = u(_makeDir);

var mkdirs = {
  mkdirs: makeDir$1,
  mkdirsSync: makeDirSync$1,
  // alias
  mkdirp: makeDir$1,
  mkdirpSync: makeDirSync$1,
  ensureDir: makeDir$1,
  ensureDirSync: makeDirSync$1
};

function utimesMillis (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  gracefulFs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    gracefulFs.futimes(fd, atime, mtime, futimesErr => {
      gracefulFs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync (path, atime, mtime) {
  const fd = gracefulFs.openSync(path, 'r+');
  gracefulFs.futimesSync(fd, atime, mtime);
  return gracefulFs.closeSync(fd)
}

var utimes = {
  utimesMillis,
  utimesMillisSync
};

const nodeSupportsBigInt = atLeastNode('10.5.0');
const stat = (file) => nodeSupportsBigInt ? fs_1.stat(file, { bigint: true }) : fs_1.stat(file);
const statSync = (file) => nodeSupportsBigInt ? fs_1.statSync(file, { bigint: true }) : fs_1.statSync(file);

function getStats (src, dest) {
  return Promise.all([
    stat(src),
    stat(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
}

function getStatsSync (src, dest) {
  let destStat;
  const srcStat = statSync(src);
  try {
    destStat = statSync(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

function checkPaths (src, dest, funcName, cb) {
  util$1.callbackify(getStats)(src, dest, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;
    if (destStat && areIdentical(srcStat, destStat)) {
      return cb(new Error('Source and destination must not be the same.'))
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return cb(null, { srcStat, destStat })
  });
}

function checkPathsSync (src, dest, funcName) {
  const { srcStat, destStat } = getStatsSync(src, dest);
  if (destStat && areIdentical(srcStat, destStat)) {
    throw new Error('Source and destination must not be the same.')
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path$1.resolve(path$1.dirname(src));
  const destParent = path$1.resolve(path$1.dirname(dest));
  if (destParent === srcParent || destParent === path$1.parse(destParent).root) return cb()
  const callback = (err, destStat) => {
    if (err) {
      if (err.code === 'ENOENT') return cb()
      return cb(err)
    }
    if (areIdentical(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb)
  };
  if (nodeSupportsBigInt) fs_1.stat(destParent, { bigint: true }, callback);
  else fs_1.stat(destParent, callback);
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path$1.resolve(path$1.dirname(src));
  const destParent = path$1.resolve(path$1.dirname(dest));
  if (destParent === srcParent || destParent === path$1.parse(destParent).root) return
  let destStat;
  try {
    destStat = statSync(destParent);
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (areIdentical(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

function areIdentical (srcStat, destStat) {
  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
      // definitive answer
      return true
    }
    // Use additional heuristics if we can't use 'bigint'.
    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER
    // See issue 657
    if (destStat.size === srcStat.size &&
        destStat.mode === srcStat.mode &&
        destStat.nlink === srcStat.nlink &&
        destStat.atimeMs === srcStat.atimeMs &&
        destStat.mtimeMs === srcStat.mtimeMs &&
        destStat.ctimeMs === srcStat.ctimeMs &&
        destStat.birthtimeMs === srcStat.birthtimeMs) {
      // heuristic answer
      return true
    }
  }
  return false
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path$1.resolve(src).split(path$1.sep).filter(i => i);
  const destArr = path$1.resolve(dest).split(path$1.sep).filter(i => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

var stat_1 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir
};

const mkdirsSync = mkdirs.mkdirsSync;
const utimesMillisSync$1 = utimes.utimesMillisSync;


function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  const { srcStat, destStat } = stat_1.checkPathsSync(src, dest, 'copy');
  stat_1.checkParentPathsSync(src, srcStat, dest, 'copy');
  return handleFilterAndCopy(destStat, src, dest, opts)
}

function handleFilterAndCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path$1.dirname(dest);
  if (!gracefulFs.existsSync(destParent)) mkdirsSync(destParent);
  return startCopy(destStat, src, dest, opts)
}

function startCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats$1(destStat, src, dest, opts)
}

function getStats$1 (destStat, src, dest, opts) {
  const statSync = opts.dereference ? gracefulFs.statSync : gracefulFs.lstatSync;
  const srcStat = statSync(src);

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    gracefulFs.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  gracefulFs.copyFileSync(src, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
  return setDestMode(dest, srcStat.mode)
}

function handleTimestamps (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
  return setDestTimestamps(src, dest)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200)
}

function setDestMode (dest, srcMode) {
  return gracefulFs.chmodSync(dest, srcMode)
}

function setDestTimestamps (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = gracefulFs.statSync(src);
  return utimesMillisSync$1(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)
  if (destStat && !destStat.isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
  }
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcMode, src, dest, opts) {
  gracefulFs.mkdirSync(dest);
  copyDir(src, dest, opts);
  return setDestMode(dest, srcMode)
}

function copyDir (src, dest, opts) {
  gracefulFs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path$1.join(src, item);
  const destItem = path$1.join(dest, item);
  const { destStat } = stat_1.checkPathsSync(srcItem, destItem, 'copy');
  return startCopy(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = gracefulFs.readlinkSync(src);
  if (opts.dereference) {
    resolvedSrc = path$1.resolve(process.cwd(), resolvedSrc);
  }

  if (!destStat) {
    return gracefulFs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest;
    try {
      resolvedDest = gracefulFs.readlinkSync(dest);
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return gracefulFs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path$1.resolve(process.cwd(), resolvedDest);
    }
    if (stat_1.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (gracefulFs.statSync(dest).isDirectory() && stat_1.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  gracefulFs.unlinkSync(dest);
  return gracefulFs.symlinkSync(resolvedSrc, dest)
}

var copySync_1 = copySync;

var copySync$1 = {
  copySync: copySync_1
};

const u$1 = universalify.fromPromise;


function pathExists (path) {
  return fs_1.access(path).then(() => true).catch(() => false)
}

var pathExists_1 = {
  pathExists: u$1(pathExists),
  pathExistsSync: fs_1.existsSync
};

const mkdirs$1 = mkdirs.mkdirs;
const pathExists$1 = pathExists_1.pathExists;
const utimesMillis$1 = utimes.utimesMillis;


function copy (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  stat_1.checkPaths(src, dest, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats;
    stat_1.checkParentPaths(src, srcStat, dest, 'copy', err => {
      if (err) return cb(err)
      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
      return checkParentDir(destStat, src, dest, opts, cb)
    });
  });
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path$1.dirname(dest);
  pathExists$1(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return startCopy$1(destStat, src, dest, opts, cb)
    mkdirs$1(destParent, err => {
      if (err) return cb(err)
      return startCopy$1(destStat, src, dest, opts, cb)
    });
  });
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(destStat, src, dest, opts, cb)
    return cb()
  }, error => cb(error));
}

function startCopy$1 (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats$2, destStat, src, dest, opts, cb)
  return getStats$2(destStat, src, dest, opts, cb)
}

function getStats$2 (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? gracefulFs.stat : gracefulFs.lstat;
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src, dest, opts, cb)
  });
}

function onFile$1 (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return copyFile$1(srcStat, src, dest, opts, cb)
  return mayCopyFile$1(srcStat, src, dest, opts, cb)
}

function mayCopyFile$1 (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    gracefulFs.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile$1(srcStat, src, dest, opts, cb)
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile$1 (srcStat, src, dest, opts, cb) {
  gracefulFs.copyFile(src, dest, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)
    return setDestMode$1(dest, srcStat.mode, cb)
  });
}

function handleTimestampsAndMode (srcMode, src, dest, cb) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable$1(srcMode)) {
    return makeFileWritable$1(dest, srcMode, err => {
      if (err) return cb(err)
      return setDestTimestampsAndMode(srcMode, src, dest, cb)
    })
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb)
}

function fileIsNotWritable$1 (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable$1 (dest, srcMode, cb) {
  return setDestMode$1(dest, srcMode | 0o200, cb)
}

function setDestTimestampsAndMode (srcMode, src, dest, cb) {
  setDestTimestamps$1(src, dest, err => {
    if (err) return cb(err)
    return setDestMode$1(dest, srcMode, cb)
  });
}

function setDestMode$1 (dest, srcMode, cb) {
  return gracefulFs.chmod(dest, srcMode, cb)
}

function setDestTimestamps$1 (src, dest, cb) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  gracefulFs.stat(src, (err, updatedSrcStat) => {
    if (err) return cb(err)
    return utimesMillis$1(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)
  });
}

function onDir$1 (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy$1(srcStat.mode, src, dest, opts, cb)
  if (destStat && !destStat.isDirectory()) {
    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
  }
  return copyDir$1(src, dest, opts, cb)
}

function mkDirAndCopy$1 (srcMode, src, dest, opts, cb) {
  gracefulFs.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir$1(src, dest, opts, err => {
      if (err) return cb(err)
      return setDestMode$1(dest, srcMode, cb)
    });
  });
}

function copyDir$1 (src, dest, opts, cb) {
  gracefulFs.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  });
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb()
  return copyDirItem$1(items, item, src, dest, opts, cb)
}

function copyDirItem$1 (items, item, src, dest, opts, cb) {
  const srcItem = path$1.join(src, item);
  const destItem = path$1.join(dest, item);
  stat_1.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { destStat } = stats;
    startCopy$1(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    });
  });
}

function onLink$1 (destStat, src, dest, opts, cb) {
  gracefulFs.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)
    if (opts.dereference) {
      resolvedSrc = path$1.resolve(process.cwd(), resolvedSrc);
    }

    if (!destStat) {
      return gracefulFs.symlink(resolvedSrc, dest, cb)
    } else {
      gracefulFs.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return gracefulFs.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path$1.resolve(process.cwd(), resolvedDest);
        }
        if (stat_1.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && stat_1.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink$1(resolvedSrc, dest, cb)
      });
    }
  });
}

function copyLink$1 (resolvedSrc, dest, cb) {
  gracefulFs.unlink(dest, err => {
    if (err) return cb(err)
    return gracefulFs.symlink(resolvedSrc, dest, cb)
  });
}

var copy_1 = copy;

const u$2 = universalify.fromCallback;
var copy$1 = {
  copy: u$2(copy_1)
};

const isWindows = (process.platform === 'win32');

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ];
  methods.forEach(m => {
    options[m] = options[m] || gracefulFs[m];
    m = m + 'Sync';
    options[m] = options[m] || gracefulFs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf (p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    });
  });
}

function fixWinEPERM (p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync (p, options, er) {
  let stats;

  assert(p);
  assert(options);

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids (p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf(path$1.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p);
  assert(options);

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path$1.join(p, f), options));

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret
      } catch {}
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options);
    return ret
  }
}

var rimraf_1 = rimraf;
rimraf.sync = rimrafSync;

const u$3 = universalify.fromCallback;


var remove = {
  remove: u$3(rimraf_1),
  removeSync: rimraf_1.sync
};

const u$4 = universalify.fromCallback;





const emptyDir = u$4(function emptyDir (dir, callback) {
  callback = callback || function () {};
  gracefulFs.readdir(dir, (err, items) => {
    if (err) return mkdirs.mkdirs(dir, callback)

    items = items.map(item => path$1.join(dir, item));

    deleteItem();

    function deleteItem () {
      const item = items.pop();
      if (!item) return callback()
      remove.remove(item, err => {
        if (err) return callback(err)
        deleteItem();
      });
    }
  });
});

function emptyDirSync (dir) {
  let items;
  try {
    items = gracefulFs.readdirSync(dir);
  } catch {
    return mkdirs.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path$1.join(dir, item);
    remove.removeSync(item);
  });
}

var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

const u$5 = universalify.fromCallback;




function createFile (file, callback) {
  function makeFile () {
    gracefulFs.writeFile(file, '', err => {
      if (err) return callback(err)
      callback();
    });
  }

  gracefulFs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path$1.dirname(file);
    gracefulFs.stat(dir, (err, stats) => {
      if (err) {
        // if the directory doesn't exist, make it
        if (err.code === 'ENOENT') {
          return mkdirs.mkdirs(dir, err => {
            if (err) return callback(err)
            makeFile();
          })
        }
        return callback(err)
      }

      if (stats.isDirectory()) makeFile();
      else {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        gracefulFs.readdir(dir, err => {
          if (err) return callback(err)
        });
      }
    });
  });
}

function createFileSync (file) {
  let stats;
  try {
    stats = gracefulFs.statSync(file);
  } catch {}
  if (stats && stats.isFile()) return

  const dir = path$1.dirname(file);
  try {
    if (!gracefulFs.statSync(dir).isDirectory()) {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      gracefulFs.readdirSync(dir);
    }
  } catch (err) {
    // If the stat call above failed because the directory doesn't exist, create it
    if (err && err.code === 'ENOENT') mkdirs.mkdirsSync(dir);
    else throw err
  }

  gracefulFs.writeFileSync(file, '');
}

var file = {
  createFile: u$5(createFile),
  createFileSync
};

const u$6 = universalify.fromCallback;



const pathExists$2 = pathExists_1.pathExists;

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    gracefulFs.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null);
    });
  }

  pathExists$2(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    gracefulFs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err)
      }

      const dir = path$1.dirname(dstpath);
      pathExists$2(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdirs.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync (srcpath, dstpath) {
  const destinationExists = gracefulFs.existsSync(dstpath);
  if (destinationExists) return undefined

  try {
    gracefulFs.lstatSync(srcpath);
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err
  }

  const dir = path$1.dirname(dstpath);
  const dirExists = gracefulFs.existsSync(dir);
  if (dirExists) return gracefulFs.linkSync(srcpath, dstpath)
  mkdirs.mkdirsSync(dir);

  return gracefulFs.linkSync(srcpath, dstpath)
}

var link = {
  createLink: u$6(createLink),
  createLinkSync
};

const pathExists$3 = pathExists_1.pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths (srcpath, dstpath, callback) {
  if (path$1.isAbsolute(srcpath)) {
    return gracefulFs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err)
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      })
    })
  } else {
    const dstdir = path$1.dirname(dstpath);
    const relativeToDst = path$1.join(dstdir, srcpath);
    return pathExists$3(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        })
      } else {
        return gracefulFs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err)
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$1.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  let exists;
  if (path$1.isAbsolute(srcpath)) {
    exists = gracefulFs.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  } else {
    const dstdir = path$1.dirname(dstpath);
    const relativeToDst = path$1.join(dstdir, srcpath);
    exists = gracefulFs.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      }
    } else {
      exists = gracefulFs.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        toCwd: srcpath,
        toDst: path$1.relative(dstdir, srcpath)
      }
    }
  }
}

var symlinkPaths_1 = {
  symlinkPaths,
  symlinkPathsSync
};

function symlinkType (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;
  if (type) return callback(null, type)
  gracefulFs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync (srcpath, type) {
  let stats;

  if (type) return type
  try {
    stats = gracefulFs.lstatSync(srcpath);
  } catch {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

var symlinkType_1 = {
  symlinkType,
  symlinkTypeSync
};

const u$7 = universalify.fromCallback;



const mkdirs$2 = mkdirs.mkdirs;
const mkdirsSync$1 = mkdirs.mkdirsSync;


const symlinkPaths$1 = symlinkPaths_1.symlinkPaths;
const symlinkPathsSync$1 = symlinkPaths_1.symlinkPathsSync;


const symlinkType$1 = symlinkType_1.symlinkType;
const symlinkTypeSync$1 = symlinkType_1.symlinkTypeSync;

const pathExists$4 = pathExists_1.pathExists;

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback;
  type = (typeof type === 'function') ? false : type;

  pathExists$4(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    symlinkPaths$1(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err)
      srcpath = relative.toDst;
      symlinkType$1(relative.toCwd, type, (err, type) => {
        if (err) return callback(err)
        const dir = path$1.dirname(dstpath);
        pathExists$4(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return gracefulFs.symlink(srcpath, dstpath, type, callback)
          mkdirs$2(dir, err => {
            if (err) return callback(err)
            gracefulFs.symlink(srcpath, dstpath, type, callback);
          });
        });
      });
    });
  });
}

function createSymlinkSync (srcpath, dstpath, type) {
  const destinationExists = gracefulFs.existsSync(dstpath);
  if (destinationExists) return undefined

  const relative = symlinkPathsSync$1(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync$1(relative.toCwd, type);
  const dir = path$1.dirname(dstpath);
  const exists = gracefulFs.existsSync(dir);
  if (exists) return gracefulFs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync$1(dir);
  return gracefulFs.symlinkSync(srcpath, dstpath, type)
}

var symlink = {
  createSymlink: u$7(createSymlink),
  createSymlinkSync
};

var ensure = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

function stringify (obj, options = {}) {
  const EOL = options.EOL || '\n';

  const str = JSON.stringify(obj, options ? options.replacer : null, options.spaces);

  return str.replace(/\n/g, EOL) + EOL
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  return content.replace(/^\uFEFF/, '')
}

var utils = { stringify, stripBom };

let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = fs;
}

const { stringify: stringify$1, stripBom: stripBom$1 } = utils;

async function _readFile (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs;

  const shouldThrow = 'throws' in options ? options.throws : true;

  let data = await universalify.fromCallback(fs.readFile)(file, options);

  data = stripBom$1(data);

  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }

  return obj
}

const readFile = universalify.fromPromise(_readFile);

function readFileSync (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  const fs = options.fs || _fs;

  const shouldThrow = 'throws' in options ? options.throws : true;

  try {
    let content = fs.readFileSync(file, options);
    content = stripBom$1(content);
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`;
      throw err
    } else {
      return null
    }
  }
}

async function _writeFile (file, obj, options = {}) {
  const fs = options.fs || _fs;

  const str = stringify$1(obj, options);

  await universalify.fromCallback(fs.writeFile)(file, str, options);
}

const writeFile = universalify.fromPromise(_writeFile);

function writeFileSync (file, obj, options = {}) {
  const fs = options.fs || _fs;

  const str = stringify$1(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

const jsonfile = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};

var jsonfile_1 = jsonfile;

var jsonfile$1 = {
  // jsonfile exports
  readJson: jsonfile_1.readFile,
  readJsonSync: jsonfile_1.readFileSync,
  writeJson: jsonfile_1.writeFile,
  writeJsonSync: jsonfile_1.writeFileSync
};

const u$8 = universalify.fromCallback;



const pathExists$5 = pathExists_1.pathExists;

function outputFile (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path$1.dirname(file);
  pathExists$5(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return gracefulFs.writeFile(file, data, encoding, callback)

    mkdirs.mkdirs(dir, err => {
      if (err) return callback(err)

      gracefulFs.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync (file, ...args) {
  const dir = path$1.dirname(file);
  if (gracefulFs.existsSync(dir)) {
    return gracefulFs.writeFileSync(file, ...args)
  }
  mkdirs.mkdirsSync(dir);
  gracefulFs.writeFileSync(file, ...args);
}

var output = {
  outputFile: u$8(outputFile),
  outputFileSync
};

const { stringify: stringify$2 } = utils;
const { outputFile: outputFile$1 } = output;

async function outputJson (file, data, options = {}) {
  const str = stringify$2(data, options);

  await outputFile$1(file, str, options);
}

var outputJson_1 = outputJson;

const { stringify: stringify$3 } = utils;
const { outputFileSync: outputFileSync$1 } = output;

function outputJsonSync (file, data, options) {
  const str = stringify$3(data, options);

  outputFileSync$1(file, str, options);
}

var outputJsonSync_1 = outputJsonSync;

const u$9 = universalify.fromPromise;


jsonfile$1.outputJson = u$9(outputJson_1);
jsonfile$1.outputJsonSync = outputJsonSync_1;
// aliases
jsonfile$1.outputJSON = jsonfile$1.outputJson;
jsonfile$1.outputJSONSync = jsonfile$1.outputJsonSync;
jsonfile$1.writeJSON = jsonfile$1.writeJson;
jsonfile$1.writeJSONSync = jsonfile$1.writeJsonSync;
jsonfile$1.readJSON = jsonfile$1.readJson;
jsonfile$1.readJSONSync = jsonfile$1.readJsonSync;

var json = jsonfile$1;

const copySync$2 = copySync$1.copySync;
const removeSync = remove.removeSync;
const mkdirpSync = mkdirs.mkdirpSync;


function moveSync (src, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;

  const { srcStat } = stat_1.checkPathsSync(src, dest, 'move');
  stat_1.checkParentPathsSync(src, srcStat, dest, 'move');
  mkdirpSync(path$1.dirname(dest));
  return doRename(src, dest, overwrite)
}

function doRename (src, dest, overwrite) {
  if (overwrite) {
    removeSync(dest);
    return rename(src, dest, overwrite)
  }
  if (gracefulFs.existsSync(dest)) throw new Error('dest already exists.')
  return rename(src, dest, overwrite)
}

function rename (src, dest, overwrite) {
  try {
    gracefulFs.renameSync(src, dest);
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice(src, dest, overwrite)
  }
}

function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copySync$2(src, dest, opts);
  return removeSync(src)
}

var moveSync_1 = moveSync;

var moveSync$1 = {
  moveSync: moveSync_1
};

const copy$2 = copy$1.copy;
const remove$1 = remove.remove;
const mkdirp = mkdirs.mkdirp;
const pathExists$6 = pathExists_1.pathExists;


function move (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = {};
  }

  const overwrite = opts.overwrite || opts.clobber || false;

  stat_1.checkPaths(src, dest, 'move', (err, stats) => {
    if (err) return cb(err)
    const { srcStat } = stats;
    stat_1.checkParentPaths(src, srcStat, dest, 'move', err => {
      if (err) return cb(err)
      mkdirp(path$1.dirname(dest), err => {
        if (err) return cb(err)
        return doRename$1(src, dest, overwrite, cb)
      });
    });
  });
}

function doRename$1 (src, dest, overwrite, cb) {
  if (overwrite) {
    return remove$1(dest, err => {
      if (err) return cb(err)
      return rename$1(src, dest, overwrite, cb)
    })
  }
  pathExists$6(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename$1(src, dest, overwrite, cb)
  });
}

function rename$1 (src, dest, overwrite, cb) {
  gracefulFs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice$1(src, dest, overwrite, cb)
  });
}

function moveAcrossDevice$1 (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copy$2(src, dest, opts, err => {
    if (err) return cb(err)
    return remove$1(src, cb)
  });
}

var move_1 = move;

const u$a = universalify.fromCallback;
var move$1 = {
  move: u$a(move_1)
};

var lib = createCommonjsModule(function (module) {

module.exports = {
  // Export promiseified graceful-fs:
  ...fs_1,
  // Export extra methods:
  ...copySync$1,
  ...copy$1,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs,
  ...moveSync$1,
  ...move$1,
  ...output,
  ...pathExists_1,
  ...remove
};

// Export fs.promises as a getter property so that we don't trigger
// ExperimentalWarning before fs.promises is actually accessed.

if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
  Object.defineProperty(module.exports, 'promises', {
    get () { return fs.promises }
  });
}
});

var ansiRegex = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

var $jscomp={scope:{}};$jscomp.defineProperty="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){if(c.get||c.set)throw new TypeError("ES3 does not support getters and setters.");a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value);};$jscomp.getGlobal=function(a){return "undefined"!=typeof window&&window===a?a:"undefined"!=typeof commonjsGlobal&&null!=commonjsGlobal?commonjsGlobal:a};$jscomp.global=$jscomp.getGlobal(commonjsGlobal);$jscomp.SYMBOL_PREFIX="jscomp_symbol_";
$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol);};$jscomp.symbolCounter_=0;$jscomp.Symbol=function(a){return $jscomp.SYMBOL_PREFIX+(a||"")+$jscomp.symbolCounter_++};
$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var a=$jscomp.global.Symbol.iterator;a||(a=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&$jscomp.defineProperty(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return $jscomp.arrayIterator(this)}});$jscomp.initSymbolIterator=function(){};};$jscomp.arrayIterator=function(a){var b=0;return $jscomp.iteratorPrototype(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})};
$jscomp.iteratorPrototype=function(a){$jscomp.initSymbolIterator();a={next:a};a[$jscomp.global.Symbol.iterator]=function(){return this};return a};$jscomp.array=$jscomp.array||{};$jscomp.iteratorFromArray=function(a,b){$jscomp.initSymbolIterator();a instanceof String&&(a+="");var c=0,e={next:function(){if(c<a.length){var d=c++;return {value:b(d,a[d]),done:!1}}e.next=function(){return {done:!0,value:void 0}};return e.next()}};e[Symbol.iterator]=function(){return e};return e};
$jscomp.polyfill=function(a,b,c,e){if(b){c=$jscomp.global;a=a.split(".");for(e=0;e<a.length-1;e++){var d=a[e];d in c||(c[d]={});c=c[d];}a=a[a.length-1];e=c[a];b=b(e);b!=e&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b});}};$jscomp.polyfill("Array.prototype.keys",function(a){return a?a:function(){return $jscomp.iteratorFromArray(this,function(a){return a})}},"es6-impl","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
$jscomp.polyfill("String.prototype.endsWith",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===c&&(c=b.length);c=Math.max(0,Math.min(c|0,b.length));for(var d=a.length;0<d&&0<c;)if(b[--c]!=a[--d])return !1;return 0>=d}},"es6-impl","es3");var PS={};(function(a){a.arrayMap=function(a){return function(b){for(var c=b.length,d=Array(c),g=0;g<c;g++)d[g]=a(b[g]);return d}};})(PS["Data.Functor"]=PS["Data.Functor"]||{});
(function(a){var b=function(a){this.compose=a;},c=new b(function(a){return function(b){return function(c){return a(b(c))}}});a.Semigroupoid=b;a.compose=function(a){return a.compose};a.semigroupoidFn=c;})(PS["Control.Semigroupoid"]=PS["Control.Semigroupoid"]||{});
(function(a){var b=PS["Control.Semigroupoid"],c=function(a,b){this["__superclass_Control.Semigroupoid.Semigroupoid_0"]=a;this.id=b;},e=new c(function(){return b.semigroupoidFn},function(a){return a});a.Category=c;a.id=function(a){return a.id};a.categoryFn=e;})(PS["Control.Category"]=PS["Control.Category"]||{});
(function(a){a.applyFlipped=function(a){return function(b){return b(a)}};a["const"]=function(a){return function(b){return a}};a.flip=function(a){return function(b){return function(c){return a(c)(b)}}};a.on=function(a){return function(b){return function(c){return function(d){return a(b(c))(b(d))}}}};})(PS["Data.Function"]=PS["Data.Function"]||{});(function(a){a.unit={};})(PS["Data.Unit"]=PS["Data.Unit"]||{});
(function(a){a.showIntImpl=function(a){return a.toString()};a.showNumberImpl=function(a){a=a.toString();return isNaN(a+".0")?a:a+".0"};a.showCharImpl=function(a){var b=a.charCodeAt(0);if(32>b||127===b){switch(a){case "\u0007":return "'\\a'";case "\b":return "'\\b'";case "\f":return "'\\f'";case "\n":return "'\\n'";case "\r":return "'\\r'";case "\t":return "'\\t'";case "\v":return "'\\v'"}return "'\\"+b.toString(10)+"'"}return "'"===a||"\\"===a?"'\\"+a+"'":"'"+a+"'"};a.showStringImpl=function(a){var b=a.length;
return '"'+a.replace(/[\0-\x1F\x7F"\\]/g,function(c,d){switch(c){case '"':case "\\":return "\\"+c;case "\u0007":return "\\a";case "\b":return "\\b";case "\f":return "\\f";case "\n":return "\\n";case "\r":return "\\r";case "\t":return "\\t";case "\v":return "\\v"}d+=1;d=d<b&&"0"<=a[d]&&"9">=a[d]?"\\\x26":"";return "\\"+c.charCodeAt(0).toString(10)+d})+'"'};a.showArrayImpl=function(a){return function(b){for(var c=[],d=0,g=b.length;d<g;d++)c[d]=a(b[d]);return "["+c.join(",")+"]"}};})(PS["Data.Show"]=PS["Data.Show"]||
{});
(function(a){var b=PS["Data.Show"],c=function(a){this.show=a;},e=new c(b.showStringImpl),d=new c(b.showNumberImpl),g=new c(b.showIntImpl),k=new c(b.showCharImpl),l=new c(function(a){if(a)return "true";if(!a)return "false";throw Error("Failed pattern match at Data.Show line 13, column 3 - line 14, column 3: "+[a.constructor.name]);});a.Show=c;a.show=function(a){return a.show};a.showBoolean=l;a.showInt=g;a.showNumber=d;a.showChar=k;a.showString=e;a.showArray=function(a){return new c(b.showArrayImpl(a.show))};})(PS["Data.Show"]=PS["Data.Show"]||
{});(function(a){a.unit=PS["Data.Unit"].unit;})(PS["Data.Unit"]=PS["Data.Unit"]||{});
(function(a){var b=PS["Data.Functor"],c=PS["Data.Function"],e=PS["Data.Unit"],d=PS["Control.Semigroupoid"],g=function(a){this.map=a;},d=new g(d.compose(d.semigroupoidFn)),b=new g(b.arrayMap);a.Functor=g;a.map=function(a){return a.map};a.mapFlipped=function(a){return function(b){return function(c){return (0, a.map)(c)(b)}}};a["void"]=function(a){return (0, a.map)(c["const"](e.unit))};a.voidLeft=function(a){return function(b){return function(d){return (0, a.map)(c["const"](d))(b)}}};a.voidRight=function(a){return function(b){return (0, a.map)(c["const"](b))}};
a.functorFn=d;a.functorArray=b;})(PS["Data.Functor"]=PS["Data.Functor"]||{});(function(a){a.concatString=function(a){return function(b){return a+b}};a.concatArray=function(a){return function(b){return 0===a.length?b:0===b.length?a:a.concat(b)}};})(PS["Data.Semigroup"]=PS["Data.Semigroup"]||{});
(function(a){var b=PS["Data.Semigroup"],c=function(a){this.append=a;},e=new c(b.concatString),b=new c(b.concatArray);a.Semigroup=c;a.append=function(a){return a.append};a.semigroupString=e;a.semigroupArray=b;})(PS["Data.Semigroup"]=PS["Data.Semigroup"]||{});(function(a){a.Alt=function(a,c){this["__superclass_Data.Functor.Functor_0"]=a;this.alt=c;};a.alt=function(a){return a.alt};})(PS["Control.Alt"]=PS["Control.Alt"]||{});
(function(a){var b=PS["Data.Functor"],c=PS["Data.Function"],e=PS["Control.Category"];a.Apply=function(a,b){this["__superclass_Data.Functor.Functor_0"]=a;this.apply=b;};a.apply=function(a){return a.apply};a.applyFirst=function(a){return function(d){return function(e){return (0, a.apply)(b.map(a["__superclass_Data.Functor.Functor_0"]())(c["const"])(d))(e)}}};a.applySecond=function(a){return function(d){return function(k){return (0, a.apply)(b.map(a["__superclass_Data.Functor.Functor_0"]())(c["const"](e.id(e.categoryFn)))(d))(k)}}};
a.lift2=function(a){return function(c){return function(d){return function(e){return (0, a.apply)(b.map(a["__superclass_Data.Functor.Functor_0"]())(c)(d))(e)}}}};})(PS["Control.Apply"]=PS["Control.Apply"]||{});
(function(a){var b=PS["Control.Apply"],c=PS["Data.Unit"];a.Applicative=function(a,b){this["__superclass_Control.Apply.Apply_0"]=a;this.pure=b;};a.liftA1=function(a){return function(c){return function(d){return b.apply(a["__superclass_Control.Apply.Apply_0"]())((0, a.pure)(c))(d)}}};a.pure=function(a){return a.pure};a.unless=function(a){return function(b){return function(d){if(!b)return d;if(b)return (0, a.pure)(c.unit);throw Error("Failed pattern match at Control.Applicative line 63, column 1 - line 63, column 19: "+
[b.constructor.name,d.constructor.name]);}}};a.when=function(a){return function(b){return function(d){if(b)return d;if(!b)return (0, a.pure)(c.unit);throw Error("Failed pattern match at Control.Applicative line 58, column 1 - line 58, column 16: "+[b.constructor.name,d.constructor.name]);}}};})(PS["Control.Applicative"]=PS["Control.Applicative"]||{});
(function(a){a.Plus=function(a,c){this["__superclass_Control.Alt.Alt_0"]=a;this.empty=c;};a.empty=function(a){return a.empty};})(PS["Control.Plus"]=PS["Control.Plus"]||{});(function(a){a.Alternative=function(a,c){this["__superclass_Control.Applicative.Applicative_0"]=a;this["__superclass_Control.Plus.Plus_1"]=c;};})(PS["Control.Alternative"]=PS["Control.Alternative"]||{});
(function(a){var b=PS["Data.Function"];a.Bind=function(a,b){this["__superclass_Control.Apply.Apply_0"]=a;this.bind=b;};a.bind=function(a){return a.bind};a.bindFlipped=function(a){return b.flip(a.bind)};a.composeKleisli=function(a){return function(b){return function(c){return function(d){return (0, a.bind)(b(d))(c)}}}};})(PS["Control.Bind"]=PS["Control.Bind"]||{});(function(a){a.Lazy=function(a){this.defer=a;};a.defer=function(a){return a.defer};})(PS["Control.Lazy"]=PS["Control.Lazy"]||{});
(function(a){var b=PS["Control.Applicative"],c=PS["Control.Bind"];a.Monad=function(a,b){this["__superclass_Control.Applicative.Applicative_0"]=a;this["__superclass_Control.Bind.Bind_1"]=b;};a.ap=function(a){return function(d){return function(e){return c.bind(a["__superclass_Control.Bind.Bind_1"]())(d)(function(d){return c.bind(a["__superclass_Control.Bind.Bind_1"]())(e)(function(c){return b.pure(a["__superclass_Control.Applicative.Applicative_0"]())(d(c))})})}}};a.liftM1=function(a){return function(d){return function(e){return c.bind(a["__superclass_Control.Bind.Bind_1"]())(e)(function(c){return b.pure(a["__superclass_Control.Applicative.Applicative_0"]())(d(c))})}}};})(PS["Control.Monad"]=
PS["Control.Monad"]||{});(function(a){a.pureE=function(a){return function(){return a}};a.bindE=function(a){return function(b){return function(){return b(a())()}}};a.runPure=function(a){return a()};})(PS["Control.Monad.Eff"]=PS["Control.Monad.Eff"]||{});
(function(a){var b=PS["Control.Monad.Eff"],c=PS["Control.Applicative"],e=PS["Control.Apply"],d=PS["Control.Bind"],g=PS["Control.Monad"],k=PS["Data.Functor"],l=new g.Monad(function(){return m},function(){return h}),h=new d.Bind(function(){return f},b.bindE),f=new e.Apply(function(){return n},g.ap(l)),m=new c.Applicative(function(){return f},b.pureE),n=new k.Functor(c.liftA1(m));a.functorEff=n;a.applyEff=f;a.applicativeEff=m;a.bindEff=h;a.monadEff=l;a.runPure=b.runPure;})(PS["Control.Monad.Eff"]=PS["Control.Monad.Eff"]||
{});(function(a){a.log=function(a){return function(){console.log(a);return {}}};a.error=function(a){return function(){console.error(a);return {}}};})(PS["Control.Monad.Eff.Console"]=PS["Control.Monad.Eff.Console"]||{});(function(a){var b=PS["Control.Monad.Eff.Console"];a.error=b.error;a.log=b.log;})(PS["Control.Monad.Eff.Console"]=PS["Control.Monad.Eff.Console"]||{});
(function(a){a.error=function(a){return Error(a)};a.throwException=function(a){return function(){throw a;}};})(PS["Control.Monad.Eff.Exception"]=PS["Control.Monad.Eff.Exception"]||{});(function(a){var b=PS["Control.Category"];a.Bifunctor=function(a){this.bimap=a;};a.bimap=function(a){return a.bimap};a.lmap=function(a){return function(c){return (0, a.bimap)(c)(b.id(b.categoryFn))}};a.rmap=function(a){return (0, a.bimap)(b.id(b.categoryFn))};})(PS["Data.Bifunctor"]=PS["Data.Bifunctor"]||{});
(function(a){a.refEq=function(a){return function(b){return a===b}};a.eqArrayImpl=function(a){return function(b){return function(c){if(b.length!==c.length)return !1;for(var d=0;d<b.length;d++)if(!a(b[d])(c[d]))return !1;return !0}}};})(PS["Data.Eq"]=PS["Data.Eq"]||{});
(function(a){var b=PS["Data.Eq"],c=function(a){this.eq=a;},e=new c(function(a){return function(a){return !0}}),d=new c(b.refEq),g=new c(b.refEq),k=new c(b.refEq),l=new c(b.refEq),h=new c(b.refEq);a.Eq=c;a.eq=function(a){return a.eq};a.notEq=function(a){return function(b){return function(c){return (0, h.eq)((0, a.eq)(b)(c))(!1)}}};a.eqBoolean=h;a.eqInt=k;a.eqNumber=g;a.eqChar=l;a.eqString=d;a.eqUnit=e;a.eqArray=function(a){return new c(b.eqArrayImpl(a.eq))};})(PS["Data.Eq"]=PS["Data.Eq"]||{});
(function(a){a.foldrArray=function(a){return function(b){return function(c){for(var d=b,e=c.length-1;0<=e;e--)d=a(c[e])(d);return d}}};a.foldlArray=function(a){return function(b){return function(c){for(var d=b,e=c.length,k=0;k<e;k++)d=a(d)(c[k]);return d}}};})(PS["Data.Foldable"]=PS["Data.Foldable"]||{});
(function(a){var b=PS["Control.Applicative"],c=PS["Control.Plus"],e=PS["Data.Unit"];a.MonadZero=function(a,b){this["__superclass_Control.Alternative.Alternative_1"]=a;this["__superclass_Control.Monad.Monad_0"]=b;};a.guard=function(a){return function(d){if(d)return b.pure(a["__superclass_Control.Alternative.Alternative_1"]()["__superclass_Control.Applicative.Applicative_0"]())(e.unit);if(!d)return c.empty(a["__superclass_Control.Alternative.Alternative_1"]()["__superclass_Control.Plus.Plus_1"]());throw Error("Failed pattern match at Control.MonadZero line 52, column 1 - line 52, column 23: "+
[d.constructor.name]);}};})(PS["Control.MonadZero"]=PS["Control.MonadZero"]||{});(function(a){a.ordArrayImpl=function(a){return function(b){return function(c){for(var d=0,e=b.length,k=c.length;d<e&&d<k;){var l=c[d],l=a(b[d])(l);if(0!==l)return l;d++;}return e===k?0:e>k?-1:1}}};})(PS["Data.Ord"]=PS["Data.Ord"]||{});
(function(a){a.unsafeCompareImpl=function(a){return function(b){return function(c){return function(d){return function(e){return d<e?a:d===e?b:c}}}}};})(PS["Data.Ord.Unsafe"]=PS["Data.Ord.Unsafe"]||{});
(function(a){var b=PS["Data.Eq"],c=function(){function a(){}a.value=new a;return a}(),e=function(){function a(){}a.value=new a;return a}(),d=function(){function a(){}a.value=new a;return a}(),b=new b.Eq(function(a){return function(b){return a instanceof c&&b instanceof c||a instanceof e&&b instanceof e||a instanceof d&&b instanceof d?!0:!1}});a.LT=c;a.GT=e;a.EQ=d;a.eqOrdering=b;})(PS["Data.Ordering"]=PS["Data.Ordering"]||{});
(function(a){var b=PS["Data.Ordering"],b=PS["Data.Ord.Unsafe"].unsafeCompareImpl(b.LT.value)(b.EQ.value)(b.GT.value);a.unsafeCompare=b;})(PS["Data.Ord.Unsafe"]=PS["Data.Ord.Unsafe"]||{});(function(a){a.intAdd=function(a){return function(b){return a+b|0}};a.intMul=function(a){return function(b){return a*b|0}};})(PS["Data.Semiring"]=PS["Data.Semiring"]||{});
(function(a){var b=PS["Data.Semiring"],c=function(a,b,c,k){this.add=a;this.mul=b;this.one=c;this.zero=k;},b=new c(b.intAdd,b.intMul,1,0);a.Semiring=c;a.add=function(a){return a.add};a.mul=function(a){return a.mul};a.one=function(a){return a.one};a.zero=function(a){return a.zero};a.semiringInt=b;})(PS["Data.Semiring"]=PS["Data.Semiring"]||{});
(function(a){var b=PS["Data.Ord"],c=PS["Data.Eq"],e=PS["Data.Ord.Unsafe"],d=PS["Data.Ordering"],g=function(a,b){this["__superclass_Data.Eq.Eq_0"]=a;this.compare=b;},k=new g(function(){return c.eqString},e.unsafeCompare),l=new g(function(){return c.eqNumber},e.unsafeCompare),h=new g(function(){return c.eqInt},e.unsafeCompare),f=new g(function(){return c.eqChar},e.unsafeCompare),e=new g(function(){return c.eqBoolean},e.unsafeCompare);a.Ord=g;a.compare=function(a){return a.compare};a.greaterThan=function(a){return function(b){return function(c){return (0, a.compare)(b)(c)instanceof
d.GT?!0:!1}}};a.greaterThanOrEq=function(a){return function(b){return function(c){return (0, a.compare)(b)(c)instanceof d.LT?!1:!0}}};a.lessThan=function(a){return function(b){return function(c){return (0, a.compare)(b)(c)instanceof d.LT?!0:!1}}};a.ordBoolean=e;a.ordInt=h;a.ordNumber=l;a.ordString=k;a.ordChar=f;a.ordArray=function(a){return new g(function(){return c.eqArray(a["__superclass_Data.Eq.Eq_0"]())},function(){var c=function(b){return function(c){c=(0, a.compare)(b)(c);if(c instanceof d.EQ)return 0;
if(c instanceof d.LT)return 1;if(c instanceof d.GT)return -1;throw Error("Failed pattern match at Data.Ord line 61, column 7 - line 66, column 1: "+[c.constructor.name]);}};return function(a){return function(d){return (0, h.compare)(0)(b.ordArrayImpl(c)(a)(d))}}}())};})(PS["Data.Ord"]=PS["Data.Ord"]||{});(function(a){a.otherwise=!0;})(PS["Data.Boolean"]=PS["Data.Boolean"]||{});
(function(a){var b=PS["Data.Semigroup"],c=function(a,b){this["__superclass_Data.Semigroup.Semigroup_0"]=a;this.mempty=b;},e=new c(function(){return b.semigroupString},"");a.Monoid=c;a.mempty=function(a){return a.mempty};a.monoidString=e;})(PS["Data.Monoid"]=PS["Data.Monoid"]||{});
(function(a){var b=PS["Control.Alt"],c=PS["Control.Alternative"],e=PS["Control.MonadZero"],d=PS["Control.Plus"],g=PS["Data.Eq"],k=PS["Data.Ord"],l=PS["Data.Functor"],h=PS["Control.Apply"],f=PS["Control.Applicative"],m=PS["Control.Bind"],n=PS["Control.Monad"],r=PS["Data.Ordering"],p=PS["Data.Unit"],t=PS["Data.Function"],B=PS["Control.Category"],q=function(){function a(){}a.value=new a;return a}(),w=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),x=function(a){return function(b){return function(c){if(c instanceof
q)return a;if(c instanceof w)return b(c.value0);throw Error("Failed pattern match at Data.Maybe line 220, column 1 - line 220, column 22: "+[a.constructor.name,b.constructor.name,c.constructor.name]);}}},y=x(!0)(t["const"](!1)),t=x(!1)(t["const"](!0)),C=new l.Functor(function(a){return function(b){return b instanceof w?new w(a(b.value0)):q.value}}),u=function(a){return new g.Eq(function(b){return function(c){return b instanceof q&&c instanceof q?!0:b instanceof w&&c instanceof w?g.eq(a)(b.value0)(c.value0):
!1}})},A=new h.Apply(function(){return C},function(a){return function(b){if(a instanceof w)return l.map(C)(a.value0)(b);if(a instanceof q)return q.value;throw Error("Failed pattern match at Data.Maybe line 69, column 3 - line 69, column 31: "+[a.constructor.name,b.constructor.name]);}}),z=new m.Bind(function(){return A},function(a){return function(b){if(a instanceof w)return b(a.value0);if(a instanceof q)return q.value;throw Error("Failed pattern match at Data.Maybe line 128, column 3 - line 128, column 24: "+
[a.constructor.name,b.constructor.name]);}}),E=new f.Applicative(function(){return A},w.create),F=new n.Monad(function(){return E},function(){return z}),G=new b.Alt(function(){return C},function(a){return function(b){return a instanceof q?b:a}}),I=new d.Plus(function(){return G},q.value),v=new c.Alternative(function(){return E},function(){return I}),b=new e.MonadZero(function(){return v},function(){return F});a.Nothing=q;a.Just=w;a.fromJust=function(a){return function(b){var c=function(a){return function(a){return a}}();
if(b instanceof w)b=b.value0;else throw Error("Failed pattern match at Data.Maybe line 271, column 1 - line 271, column 21: "+[b.constructor.name]);return c(b)}};a.fromMaybe=function(a){return x(a)(B.id(B.categoryFn))};a.isJust=t;a.isNothing=y;a.maybe=x;a["maybe'"]=function(a){return function(b){return function(c){if(c instanceof q)return a(p.unit);if(c instanceof w)return b(c.value0);throw Error("Failed pattern match at Data.Maybe line 233, column 1 - line 233, column 28: "+[a.constructor.name,b.constructor.name,
c.constructor.name]);}}};a.functorMaybe=C;a.applyMaybe=A;a.applicativeMaybe=E;a.altMaybe=G;a.plusMaybe=I;a.alternativeMaybe=v;a.bindMaybe=z;a.monadMaybe=F;a.monadZeroMaybe=b;a.eqMaybe=u;a.ordMaybe=function(a){return new k.Ord(function(){return u(a["__superclass_Data.Eq.Eq_0"]())},function(b){return function(c){if(b instanceof q&&c instanceof q)return r.EQ.value;if(b instanceof q)return r.LT.value;if(c instanceof q)return r.GT.value;if(b instanceof w&&c instanceof w)return k.compare(a)(b.value0)(c.value0);
throw Error("Failed pattern match at Data.Maybe line 196, column 1 - line 196, column 51: "+[b.constructor.name,c.constructor.name]);}})};})(PS["Data.Maybe"]=PS["Data.Maybe"]||{});(function(a){a.boolConj=function(a){return function(b){return a&&b}};a.boolDisj=function(a){return function(b){return a||b}};a.boolNot=function(a){return !a};})(PS["Data.HeytingAlgebra"]=PS["Data.HeytingAlgebra"]||{});
(function(a){var b=PS["Data.HeytingAlgebra"],c=function(a,b,c,e,h,f){this.conj=a;this.disj=b;this.ff=c;this.implies=e;this.not=h;this.tt=f;},e=new c(b.boolConj,b.boolDisj,!1,function(a){return function(b){return (0, e.disj)((0, e.not)(a))(b)}},b.boolNot,!0);a.HeytingAlgebra=c;a.conj=function(a){return a.conj};a.disj=function(a){return a.disj};a.ff=function(a){return a.ff};a.implies=function(a){return a.implies};a.not=function(a){return a.not};a.tt=function(a){return a.tt};a.heytingAlgebraBoolean=e;a.heytingAlgebraFunction=
function(a){return new c(function(b){return function(c){return function(d){return (0, a.conj)(b(d))(c(d))}}},function(b){return function(c){return function(d){return (0, a.disj)(b(d))(c(d))}}},function(b){return a.ff},function(b){return function(c){return function(d){return (0, a.implies)(b(d))(c(d))}}},function(b){return function(c){return (0, a.not)(b(c))}},function(b){return a.tt})};})(PS["Data.HeytingAlgebra"]=PS["Data.HeytingAlgebra"]||{});
(function(a){var b=PS["Data.Functor"];a.Newtype=function(a,b){this.unwrap=a;this.wrap=b;};a.alaF=function(a){return function(c){return function(d){return function(e){return function(k){return function(k){return function(h){return b.map(c)(e.unwrap)(k(b.map(a)(d.wrap)(h)))}}}}}}};a.unwrap=function(a){return a.unwrap};a.wrap=function(a){return a.wrap};})(PS["Data.Newtype"]=PS["Data.Newtype"]||{});
(function(a){var b=PS["Data.HeytingAlgebra"],c=PS["Data.Monoid"],e=PS["Data.Semigroup"],d=function(a){return a},g=function(a){return new e.Semigroup(function(c){return function(d){return b.conj(a)(c)(d)}})},k=new PS["Data.Newtype"].Newtype(function(a){return a},d);a.Conj=d;a.newtypeConj=k;a.semigroupConj=g;a.monoidConj=function(a){return new c.Monoid(function(){return g(a)},b.tt(a))};})(PS["Data.Monoid.Conj"]=PS["Data.Monoid.Conj"]||{});
(function(a){var b=PS["Data.HeytingAlgebra"],c=PS["Data.Monoid"],e=PS["Data.Semigroup"],d=function(a){return a},g=function(a){return new e.Semigroup(function(c){return function(d){return b.disj(a)(c)(d)}})},k=new PS["Data.Newtype"].Newtype(function(a){return a},d);a.Disj=d;a.newtypeDisj=k;a.semigroupDisj=g;a.monoidDisj=function(a){return new c.Monoid(function(){return g(a)},b.ff(a))};})(PS["Data.Monoid.Disj"]=PS["Data.Monoid.Disj"]||{});
(function(a){var b=PS["Data.Foldable"],c=PS["Data.Maybe"],e=PS["Data.Monoid"],d=PS["Data.Monoid.Conj"],g=PS["Data.Monoid.Disj"],k=PS["Data.Newtype"],l=PS["Control.Apply"],h=PS["Control.Applicative"],f=PS["Data.Unit"],m=PS["Data.Function"],n=PS["Data.Semigroup"],r=PS["Data.Eq"],p=PS["Data.Ordering"],t=PS["Data.Ord"],B=PS["Data.Semiring"],q=PS["Data.Functor"],w=PS["Data.HeytingAlgebra"],x=function(a,b,c){this.foldMap=a;this.foldl=b;this.foldr=c;},y=function(a){return function(b){return function(c){return (0, b.foldr)(function(b){return l.applySecond(a["__superclass_Control.Apply.Apply_0"]())(c(b))})(h.pure(a)(f.unit))}}},
C=function(a){return function(b){return (0, a.foldl)(function(a){return function(d){if(a instanceof c.Nothing)return new c.Just(d);if(a instanceof c.Just){var e=c.Just;var f=r.eq(p.eqOrdering)(b(a.value0)(d))(p.GT.value);if(f)d=a.value0;else if(f)throw Error("Failed pattern match at Data.Foldable line 291, column 27 - line 291, column 57: "+[f.constructor.name]);return new e(d)}throw Error("Failed pattern match at Data.Foldable line 290, column 3 - line 290, column 27: "+[a.constructor.name,d.constructor.name]);
}})(c.Nothing.value)}},u=function(a){return function(b){return function(c){return function(d){return (0, a.foldr)(function(a){return function(d){return n.append(b["__superclass_Data.Semigroup.Semigroup_0"]())(c(a))(d)}})(e.mempty(b))(d)}}}},A=new x(function(a){return u(A)(a)},b.foldlArray,b.foldrArray),z=function(a){return function(b){return function(c){return k.alaF(q.functorFn)(q.functorFn)(g.newtypeDisj)(g.newtypeDisj)(g.Disj)((0, a.foldMap)(g.monoidDisj(b)))(c)}}};a.Foldable=x;a.all=function(a){return function(b){return function(c){return k.alaF(q.functorFn)(q.functorFn)(d.newtypeConj)(d.newtypeConj)(d.Conj)((0, a.foldMap)(d.monoidConj(b)))(c)}}};
a.any=z;a.elem=function(a){return function(b){return function(c){return z(a)(w.heytingAlgebraBoolean)(r.eq(b)(c))}}};a.foldMap=function(a){return a.foldMap};a.foldMapDefaultR=u;a.foldl=function(a){return a.foldl};a.foldr=function(a){return a.foldr};a.for_=function(a){return function(b){return m.flip(y(a)(b))}};a.intercalate=function(a){return function(b){return function(c){return function(d){return (0, a.foldl)(function(a){return function(d){return a.init?{init:!1,acc:d}:{init:!1,acc:n.append(b["__superclass_Data.Semigroup.Semigroup_0"]())(a.acc)(n.append(b["__superclass_Data.Semigroup.Semigroup_0"]())(c)(d))}}})({init:!0,
acc:e.mempty(b)})(d).acc}}}};a.maximum=function(a){return function(b){return C(b)(t.compare(a))}};a.maximumBy=C;a.sum=function(a){return function(b){return (0, a.foldl)(B.add(b))(B.zero(b))}};a.traverse_=y;a.foldableArray=A;})(PS["Data.Foldable"]=PS["Data.Foldable"]||{});
(function(a){a.traverseArrayImpl=function(){function a(a){this.fn=a;}function c(a){return function(b){return new g(a,b)}}function e(a){for(var b=[];a!==d;)b.push(a.head),a=a.tail;return b}var d={},g=function(a,b){this.head=a;this.tail=b;};return function(b){return function(k){return function(h){return function(f){var l=function(d,e,h){if(0===e)return d;var p=h[e-1];return new a(function(){var a=l,m;m=b(k(c)(f(p)))(d);return a(m,e-1,h)})};return function(b){for(b=l(h(d),b.length,b);b instanceof a;)b=
b.fn();return k(e)(b)}}}}}}();})(PS["Data.Traversable"]=PS["Data.Traversable"]||{});
(function(a){var b=PS["Data.Traversable"],c=PS["Data.Foldable"],e=PS["Control.Apply"],d=PS["Data.Functor"],g=PS["Control.Applicative"],k=PS["Control.Category"],l=function(a,b,c,d){this["__superclass_Data.Foldable.Foldable_1"]=a;this["__superclass_Data.Functor.Functor_0"]=b;this.sequence=c;this.traverse=d;},h=function(a){return function(b){return function(c){return (0, a.traverse)(b)(k.id(k.categoryFn))(c)}}},f=new l(function(){return c.foldableArray},function(){return d.functorArray},function(a){return h(f)(a)},
function(a){return b.traverseArrayImpl(e.apply(a["__superclass_Control.Apply.Apply_0"]()))(d.map(a["__superclass_Control.Apply.Apply_0"]()["__superclass_Data.Functor.Functor_0"]()))(g.pure(a))});a.Traversable=l;a["for"]=function(a){return function(b){return function(c){return function(d){return (0, b.traverse)(a)(d)(c)}}}};a.sequence=function(a){return a.sequence};a.sequenceDefault=h;a.traverse=function(a){return a.traverse};a.traversableArray=f;})(PS["Data.Traversable"]=PS["Data.Traversable"]||{});
(function(a){var b=PS["Control.Alt"],c=PS["Data.Bifunctor"],e=PS["Data.Functor"],d=PS["Control.Apply"],g=PS["Control.Applicative"],k=PS["Control.Bind"],l=PS["Control.Monad"],h=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),f=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),m=new e.Functor(function(a){return function(b){if(b instanceof h)return new h(b.value0);if(b instanceof f)return new f(a(b.value0));throw Error("Failed pattern match at Data.Either line 37, column 3 - line 37, column 26: "+
[a.constructor.name,b.constructor.name]);}}),n=function(a){return function(b){return function(c){if(c instanceof h)return a(c.value0);if(c instanceof f)return b(c.value0);throw Error("Failed pattern match at Data.Either line 230, column 1 - line 230, column 26: "+[a.constructor.name,b.constructor.name,c.constructor.name]);}}},c=new c.Bifunctor(function(a){return function(b){return function(c){if(c instanceof h)return new h(a(c.value0));if(c instanceof f)return new f(b(c.value0));throw Error("Failed pattern match at Data.Either line 44, column 3 - line 44, column 34: "+
[a.constructor.name,b.constructor.name,c.constructor.name]);}}}),r=new d.Apply(function(){return m},function(a){return function(b){if(a instanceof h)return new h(a.value0);if(a instanceof f)return e.map(m)(a.value0)(b);throw Error("Failed pattern match at Data.Either line 80, column 3 - line 80, column 28: "+[a.constructor.name,b.constructor.name]);}}),p=new k.Bind(function(){return r},n(function(a){return function(b){return new h(a)}})(function(a){return function(b){return b(a)}})),t=new g.Applicative(function(){return r},
f.create),d=new l.Monad(function(){return t},function(){return p}),b=new b.Alt(function(){return m},function(a){return function(b){return a instanceof h?b:a}});a.Left=h;a.Right=f;a.either=n;a.fromRight=function(a){return function(b){var c=function(a){return function(a){return a}}();if(b instanceof f)b=b.value0;else throw Error("Failed pattern match at Data.Either line 253, column 1 - line 253, column 23: "+[b.constructor.name]);return c(b)}};a.functorEither=m;a.bifunctorEither=c;a.applyEither=r;
a.applicativeEither=t;a.altEither=b;a.bindEither=p;a.monadEither=d;})(PS["Data.Either"]=PS["Data.Either"]||{});(function(a){var b=PS["Control.Monad.Eff.Exception"];a.error=b.error;a.throwException=b.throwException;})(PS["Control.Monad.Eff.Exception"]=PS["Control.Monad.Eff.Exception"]||{});(function(a){a.unsafeCoerceEff=function(a){return a};})(PS["Control.Monad.Eff.Unsafe"]=PS["Control.Monad.Eff.Unsafe"]||{});
(function(a){var b=PS["Control.Monad.Eff.Unsafe"],c=PS["Control.Monad.Eff"];a.unsafePerformEff=function(a){return c.runPure(b.unsafeCoerceEff(a))};})(PS["Control.Monad.Eff.Unsafe"]=PS["Control.Monad.Eff.Unsafe"]||{});(function(a){a.MonadError=function(a,c,e){this["__superclass_Control.Monad.Monad_0"]=a;this.catchError=c;this.throwError=e;};a.catchError=function(a){return a.catchError};a.throwError=function(a){return a.throwError};})(PS["Control.Monad.Error.Class"]=PS["Control.Monad.Error.Class"]||{});
(function(a){var b=PS["Data.Bifunctor"],c=PS["Data.Eq"],e=PS["Data.Show"],d=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),b=new b.Bifunctor(function(a){return function(b){return function(c){return new d(a(c.value0),b(c.value1))}}});a.Tuple=d;a.fst=function(a){return a.value0};a.snd=function(a){return a.value1};a.showTuple=function(a){return function(b){return new e.Show(function(c){return "(Tuple "+(e.show(a)(c.value0)+
(" "+(e.show(b)(c.value1)+")")))})}};a.eqTuple=function(a){return function(b){return new c.Eq(function(d){return function(e){return c.eq(a)(d.value0)(e.value0)&&c.eq(b)(d.value1)(e.value1)}})}};a.bifunctorTuple=b;})(PS["Data.Tuple"]=PS["Data.Tuple"]||{});
(function(a){var b=PS["Data.Tuple"],c=PS["Data.Unit"];a.MonadState=function(a,b){this["__superclass_Control.Monad.Monad_0"]=a;this.state=b;};a.get=function(a){return (0, a.state)(function(a){return new b.Tuple(a,a)})};a.modify=function(a){return function(d){return (0, a.state)(function(a){return new b.Tuple(c.unit,d(a))})}};a.put=function(a){return function(d){return (0, a.state)(function(a){return new b.Tuple(c.unit,d)})}};a.state=function(a){return a.state};})(PS["Control.Monad.State.Class"]=PS["Control.Monad.State.Class"]||
{});(function(a){a.MonadPlus=function(a){this["__superclass_Control.MonadZero.MonadZero_0"]=a;};})(PS["Control.MonadPlus"]=PS["Control.MonadPlus"]||{});
(function(a){var b=PS["Control.Alt"],c=PS["Control.Monad.Error.Class"],e=PS["Data.Either"],d=PS["Data.Functor"],g=PS["Control.Apply"],k=PS["Control.Monad"],l=PS["Control.Applicative"],h=PS["Control.Bind"],f=PS["Data.Semigroup"],m=function(a){return function(b){return a(b)}},n=function(a){return new d.Functor(function(b){return m(d.map(a)(d.map(e.functorEither)(b)))})},r=function(a){return new k.Monad(function(){return B(a)},function(){return p(a)})},p=function(a){return new h.Bind(function(){return t(a)},
function(b){return function(c){return h.bind(a["__superclass_Control.Bind.Bind_1"]())(b)(e.either(function(b){return l.pure(a["__superclass_Control.Applicative.Applicative_0"]())(e.Left.create(b))})(function(a){return c(a)}))}})},t=function(a){return new g.Apply(function(){return n(a["__superclass_Control.Bind.Bind_1"]()["__superclass_Control.Apply.Apply_0"]()["__superclass_Data.Functor.Functor_0"]())},k.ap(r(a)))},B=function(a){return new l.Applicative(function(){return t(a)},function(b){return l.pure(a["__superclass_Control.Applicative.Applicative_0"]())(e.Right.create(b))})};
a.ExceptT=function(a){return a};a.mapExceptT=m;a.runExceptT=function(a){return a};a.functorExceptT=n;a.applyExceptT=t;a.applicativeExceptT=B;a.bindExceptT=p;a.monadExceptT=r;a.altExceptT=function(a){return function(c){return new b.Alt(function(){return n(c["__superclass_Control.Bind.Bind_1"]()["__superclass_Control.Apply.Apply_0"]()["__superclass_Data.Functor.Functor_0"]())},function(b){return function(d){return h.bind(c["__superclass_Control.Bind.Bind_1"]())(b)(function(b){if(b instanceof e.Right)return l.pure(c["__superclass_Control.Applicative.Applicative_0"]())(new e.Right(b.value0));
if(b instanceof e.Left)return h.bind(c["__superclass_Control.Bind.Bind_1"]())(d)(function(d){if(d instanceof e.Right)return l.pure(c["__superclass_Control.Applicative.Applicative_0"]())(new e.Right(d.value0));if(d instanceof e.Left)return l.pure(c["__superclass_Control.Applicative.Applicative_0"]())(new e.Left(f.append(a)(b.value0)(d.value0)));throw Error("Failed pattern match at Control.Monad.Except.Trans line 88, column 9 - line 90, column 49: "+[d.constructor.name]);});throw Error("Failed pattern match at Control.Monad.Except.Trans line 84, column 5 - line 90, column 49: "+
[b.constructor.name]);})}})}};a.monadErrorExceptT=function(a){return new c.MonadError(function(){return r(a)},function(b){return function(c){return h.bind(a["__superclass_Control.Bind.Bind_1"]())(b)(e.either(function(a){return c(a)})(function(b){return l.pure(a["__superclass_Control.Applicative.Applicative_0"]())(e.Right.create(b))}))}},function(b){return l.pure(a["__superclass_Control.Applicative.Applicative_0"]())(e.Left.create(b))})};})(PS["Control.Monad.Except.Trans"]=PS["Control.Monad.Except.Trans"]||
{});
(function(a){var b=PS["Data.Functor"],c=PS["Control.Apply"],e=PS["Control.Applicative"],d=PS["Control.Bind"],g=PS["Control.Monad"],k=function(a){return a},l=new PS["Data.Newtype"].Newtype(function(a){return a},k),h=new b.Functor(function(a){return function(b){return a(b)}}),f=new c.Apply(function(){return h},function(a){return function(b){return a(b)}}),m=new d.Bind(function(){return f},function(a){return function(b){return b(a)}}),n=new e.Applicative(function(){return f},k),b=new g.Monad(function(){return n},function(){return m});
a.Identity=k;a.newtypeIdentity=l;a.functorIdentity=h;a.applyIdentity=f;a.applicativeIdentity=n;a.bindIdentity=m;a.monadIdentity=b;})(PS["Data.Identity"]=PS["Data.Identity"]||{});
(function(a){var b=PS["Control.Monad.Except.Trans"],c=PS["Data.Identity"],e=PS["Data.Newtype"];a.mapExcept=function(a){return b.mapExceptT(function(b){return c.Identity(a(e.unwrap(c.newtypeIdentity)(b)))})};a.runExcept=function(a){return e.unwrap(c.newtypeIdentity)(b.runExceptT(a))};})(PS["Control.Monad.Except"]=PS["Control.Monad.Except"]||{});
(function(a){var b=PS["Control.Monad.State.Class"],c=PS["Data.Tuple"],e=PS["Data.Functor"],d=PS["Control.Apply"],g=PS["Control.Monad"],k=PS["Control.Applicative"],l=PS["Control.Bind"],h=function(a){return new e.Functor(function(b){return function(d){return function(f){return e.map(a)(function(a){return new c.Tuple(b(a.value0),a.value1)})(d(f))}}})},f=function(a){return new g.Monad(function(){return r(a)},function(){return m(a)})},m=function(a){return new l.Bind(function(){return n(a)},function(b){return function(c){return function(d){return l.bind(a["__superclass_Control.Bind.Bind_1"]())(b(d))(function(a){return c(a.value0)(a.value1)})}}})},
n=function(a){return new d.Apply(function(){return h(a["__superclass_Control.Bind.Bind_1"]()["__superclass_Control.Apply.Apply_0"]()["__superclass_Data.Functor.Functor_0"]())},g.ap(f(a)))},r=function(a){return new k.Applicative(function(){return n(a)},function(b){return function(d){return k.pure(a["__superclass_Control.Applicative.Applicative_0"]())(new c.Tuple(b,d))}})};a.StateT=function(a){return a};a.functorStateT=h;a.applyStateT=n;a.applicativeStateT=r;a.bindStateT=m;a.monadStateT=f;a.monadStateStateT=
function(a){return new b.MonadState(function(){return f(a)},function(b){return function(c){return k.pure(a["__superclass_Control.Applicative.Applicative_0"]())(b(c))}})};})(PS["Control.Monad.State.Trans"]=PS["Control.Monad.State.Trans"]||{});(function(a){a.evalState=function(a){return function(b){return a(b).value0}};})(PS["Control.Monad.State"]=PS["Control.Monad.State"]||{});
(function(a){var b=PS["Control.Plus"],c=PS["Data.Either"],e=PS["Data.Maybe"],d=PS["Control.Applicative"],g=PS["Control.Bind"],k=PS["Control.Monad"],l=function(a){return e.maybe(b.empty(a["__superclass_Control.MonadZero.MonadZero_0"]()["__superclass_Control.Alternative.Alternative_1"]()["__superclass_Control.Plus.Plus_1"]()))(d.pure(a["__superclass_Control.MonadZero.MonadZero_0"]()["__superclass_Control.Alternative.Alternative_1"]()["__superclass_Control.Applicative.Applicative_0"]()))},h=function(a){return function(b){return g.bind(a["__superclass_Control.MonadZero.MonadZero_0"]()["__superclass_Control.Monad.Monad_0"]()["__superclass_Control.Bind.Bind_1"]())(b)(l(a))}};
a.mcatMaybes=h;a.mfromMaybe=l;a.mlefts=function(a){var b=function(a){if(a instanceof c.Left)return new e.Just(a.value0);if(a instanceof c.Right)return e.Nothing.value;throw Error("Failed pattern match at Control.MonadPlus.Partial line 41, column 3 - line 41, column 23: "+[a.constructor.name]);};return function(c){return h(a)(k.liftM1(a["__superclass_Control.MonadZero.MonadZero_0"]()["__superclass_Control.Monad.Monad_0"]())(b)(c))}};a.mrights=function(a){var b=function(a){if(a instanceof c.Left)return e.Nothing.value;
if(a instanceof c.Right)return new e.Just(a.value0);throw Error("Failed pattern match at Control.MonadPlus.Partial line 47, column 3 - line 47, column 24: "+[a.constructor.name]);};return function(c){return h(a)(k.liftM1(a["__superclass_Control.MonadZero.MonadZero_0"]()["__superclass_Control.Monad.Monad_0"]())(b)(c))}};})(PS["Control.MonadPlus.Partial"]=PS["Control.MonadPlus.Partial"]||{});
(function(a){a.range=function(a){return function(b){for(var c=a>b?-1:1,d=[],g=a,k=0;g!==b;g+=c)d[k++]=g;d[k]=g;return d}};a.fromFoldableImpl=function(){function a(a,b){this.head=a;this.tail=b;}function c(b){return function(c){return new a(b,c)}}var e={};return function(a){return function(b){b=a(c)(e)(b);for(var d=[],l=0;b!==e;)d[l++]=b.head,b=b.tail;return d}}}();a.length=function(a){return a.length};a.cons=function(a){return function(b){return [a].concat(b)}};a["uncons'"]=function(a){return function(b){return function(c){return 0===
c.length?a({}):b(c[0])(c.slice(1))}}};a.indexImpl=function(a){return function(b){return function(c){return function(d){return 0>d||d>=c.length?b:a(c[d])}}}};a.findIndexImpl=function(a){return function(b){return function(c){return function(d){for(var e=0,k=d.length;e<k;e++)if(c(d[e]))return a(e);return b}}}};a.concat=function(a){for(var b=[],e=0,d=a.length;e<d;e++)for(var g=a[e],k=0,l=g.length;k<l;k++)b.push(g[k]);return b};a.filter=function(a){return function(b){return b.filter(a)}};a.sortImpl=function(a){return function(b){return b.slice().sort(function(b,
c){return a(b)(c)})}};a.slice=function(a){return function(b){return function(c){return c.slice(a,b)}}};a.drop=function(a){return function(b){return 1>a?b:b.slice(a)}};a.zipWith=function(a){return function(b){return function(c){for(var d=b.length<c.length?b.length:c.length,e=Array(d),k=0;k<d;k++)e[k]=a(b[k])(c[k]);return e}}};})(PS["Data.Array"]=PS["Data.Array"]||{});
(function(a){var b=PS["Control.Plus"],c=PS["Data.Foldable"],e=PS["Data.Traversable"],d=PS["Data.Show"],g=PS["Data.Semigroup"],k=PS["Data.Functor"],l=PS["Control.Apply"],h=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),f=function(a){return new k.Functor(function(b){return function(c){return new h(b(c.value0),k.map(a)(b)(c.value1))}})},m=function(a){return new c.Foldable(function(b){return function(d){return function(e){return g.append(b["__superclass_Data.Semigroup.Semigroup_0"]())(d(e.value0))(c.foldMap(a)(b)(d)(e.value1))}}},
function(b){return function(d){return function(e){return c.foldl(a)(b)(b(d)(e.value0))(e.value1)}}},function(b){return function(d){return function(e){return b(e.value0)(c.foldr(a)(b)(d)(e.value1))}}})};a.NonEmpty=h;a.singleton=function(a){return function(c){return new h(c,b.empty(a))}};a.showNonEmpty=function(a){return function(b){return new d.Show(function(c){return "(NonEmpty "+(d.show(a)(c.value0)+(" "+(d.show(b)(c.value1)+")")))})}};a.functorNonEmpty=f;a.foldableNonEmpty=m;a.traversableNonEmpty=
function(a){return new e.Traversable(function(){return m(a["__superclass_Data.Foldable.Foldable_1"]())},function(){return f(a["__superclass_Data.Functor.Functor_0"]())},function(b){return function(c){return l.apply(b["__superclass_Control.Apply.Apply_0"]())(k.map(b["__superclass_Control.Apply.Apply_0"]()["__superclass_Data.Functor.Functor_0"]())(h.create)(c.value0))(e.sequence(a)(b)(c.value1))}},function(b){return function(c){return function(d){return l.apply(b["__superclass_Control.Apply.Apply_0"]())(k.map(b["__superclass_Control.Apply.Apply_0"]()["__superclass_Data.Functor.Functor_0"]())(h.create)(c(d.value0)))(e.traverse(a)(b)(c)(d.value1))}}})};})(PS["Data.NonEmpty"]=
PS["Data.NonEmpty"]||{});(function(a){a.unfoldrArrayImpl=function(a){return function(b){return function(c){return function(d){return function(e){return function(k){for(var l=[];;){k=e(k);if(a(k))return l;k=b(k);l.push(c(k));k=d(k);}}}}}}};})(PS["Data.Unfoldable"]=PS["Data.Unfoldable"]||{});
(function(a){var b=PS["Data.Maybe"],c=PS["Data.Tuple"],e=function(a){this.unfoldr=a;},b=new e(PS["Data.Unfoldable"].unfoldrArrayImpl(b.isNothing)(b.fromJust())(c.fst)(c.snd));a.Unfoldable=e;a.unfoldr=function(a){return a.unfoldr};a.unfoldableArray=b;})(PS["Data.Unfoldable"]=PS["Data.Unfoldable"]||{});
(function(a){var b=PS["Data.Array"],c=PS["Control.Alt"],e=PS["Control.Lazy"],d=PS["Data.Foldable"],g=PS["Data.Maybe"],k=PS["Data.Ord"],l=PS["Data.Boolean"],h=PS["Data.Ordering"],f=PS["Data.Eq"],m=PS["Control.Apply"],n=PS["Data.Functor"],r=PS["Control.Applicative"],p=b["uncons'"](PS["Data.Function"]["const"](g.Nothing.value))(function(a){return function(b){return new g.Just({head:a,tail:b})}}),t=function(a){return function(c){return b.sortImpl(function(b){return function(c){c=a(b)(c);if(c instanceof
h.GT)return 1;if(c instanceof h.EQ)return 0;if(c instanceof h.LT)return -1;throw Error("Failed pattern match at Data.Array line 467, column 15 - line 472, column 1: "+[c.constructor.name]);}})(c)}},B=function(a){return 0===b.length(a)},q=function(a){return function(c){return function(d){return m.apply(a["__superclass_Control.Applicative.Applicative_0"]()["__superclass_Control.Apply.Apply_0"]())(n.map(a["__superclass_Control.Plus.Plus_1"]()["__superclass_Control.Alt.Alt_0"]()["__superclass_Data.Functor.Functor_0"]())(b.cons)(d))(e.defer(c)(function(b){return w(a)(c)(d)}))}}},
w=function(a){return function(b){return function(d){return c.alt(a["__superclass_Control.Plus.Plus_1"]()["__superclass_Control.Alt.Alt_0"]())(q(a)(b)(d))(r.pure(a["__superclass_Control.Applicative.Applicative_0"]())([]))}}},x=b.indexImpl(g.Just.create)(g.Nothing.value),y=function(a){return function(c){var d;a:b:for(d=0;;){var e=x(c)(d);if(e instanceof g.Just){if(e=a(e.value0)){d=d+1|0;continue b}if(!e){d=new g.Just(d);break a}throw Error("Failed pattern match at Data.Array line 529, column 17 - line 529, column 49: "+
[e.constructor.name]);}if(e instanceof g.Nothing){d=g.Nothing.value;break a}throw Error("Failed pattern match at Data.Array line 528, column 5 - line 530, column 25: "+[e.constructor.name]);}if(d instanceof g.Just&&0===d.value0)return {init:[],rest:c};if(d instanceof g.Just)return {init:b.slice(0)(d.value0)(c),rest:b.slice(d.value0)(b.length(c))(c)};if(d instanceof g.Nothing)return {init:c,rest:[]};throw Error("Failed pattern match at Data.Array line 515, column 3 - line 521, column 30: "+[d.constructor.name]);
}},C=b.findIndexImpl(g.Just.create)(g.Nothing.value);a.elemIndex=function(a){return function(b){return C(function(c){return f.eq(a)(c)(b)})}};a.findIndex=C;a.fromFoldable=function(a){return b.fromFoldableImpl(d.foldr(a))};a.head=function(a){return x(a)(0)};a.index=x;a.init=function(a){if(B(a))return g.Nothing.value;if(l.otherwise)return new g.Just(b.slice(0)(b.length(a)-1|0)(a));throw Error("Failed pattern match at Data.Array line 249, column 1 - line 251, column 55: "+[a.constructor.name]);};a.last=
function(a){return x(a)(b.length(a)-1|0)};a.many=w;a["null"]=B;a.singleton=function(a){return [a]};a.some=q;a.sort=function(a){return function(b){return t(k.compare(a))(b)}};a.sortBy=t;a.span=y;a.takeWhile=function(a){return function(b){return y(a)(b).init}};a.uncons=p;a.cons=b.cons;a.drop=b.drop;a.filter=b.filter;a.length=b.length;a.range=b.range;a.slice=b.slice;a.zipWith=b.zipWith;})(PS["Data.Array"]=PS["Data.Array"]||{});
(function(a){var b=PS["Data.Array"];a.head=function(a){return function(a){return a[0]}};a.tail=function(a){return function(a){return b.slice(1)(b.length(a))(a)}};})(PS["Data.Array.Partial"]=PS["Data.Array.Partial"]||{});(function(a){a.toCharCode=function(a){return a.charCodeAt(0)};a.toLower=function(a){return a.toLowerCase()};})(PS["Data.Char"]=PS["Data.Char"]||{});(function(a){var b=PS["Data.Char"];a.toCharCode=b.toCharCode;a.toLower=b.toLower;})(PS["Data.Char"]=PS["Data.Char"]||{});
(function(a){a.toForeign=function(a){return a};a.unsafeFromForeign=function(a){return a};a.typeOf=function(a){return typeof a};a.tagOf=function(a){return Object.prototype.toString.call(a).slice(8,-1)};a.isNull=function(a){return null===a};a.isUndefined=function(a){return void 0===a};a.isArray=Array.isArray||function(a){return "[object Array]"===Object.prototype.toString.call(a)};})(PS["Data.Foreign"]=PS["Data.Foreign"]||{});
(function(a){a.mkFn2=function(a){return function(b,e){return a(b)(e)}};a.runFn2=function(a){return function(b){return function(c){return a(b,c)}}};a.runFn4=function(a){return function(b){return function(c){return function(d){return function(e){return a(b,c,d,e)}}}}};})(PS["Data.Function.Uncurried"]=PS["Data.Function.Uncurried"]||{});
(function(a){var b=PS["Data.Function.Uncurried"];a.mkFn1=function(a){return a};a.mkFn2=b.mkFn2;a.runFn2=b.runFn2;a.runFn4=b.runFn4;})(PS["Data.Function.Uncurried"]=PS["Data.Function.Uncurried"]||{});
(function(a){a.fromNumberImpl=function(a){return function(b){return function(c){return (c|0)===c?a(c):b}}};a.toNumber=function(a){return a};a.fromStringAsImpl=function(a){return function(b){return function(c){var d;d=11>c?"[0-"+(c-1).toString()+"]":11===c?"[0-9a]":"[0-9a-"+String.fromCharCode(86+c)+"]";var e=new RegExp("^[\\+\\-]?"+d+"+$","i");return function(d){return e.test(d)?(d=parseInt(d,c),(d|0)===d?a(d):b):b}}}};})(PS["Data.Int"]=PS["Data.Int"]||{});
(function(a){a.readFloat=parseFloat;})(PS.Global=PS.Global||{});(function(a){a.readFloat=PS.Global.readFloat;})(PS.Global=PS.Global||{});(function(a){var b=PS["Data.Int"],c=PS["Data.Maybe"],e=b.fromStringAsImpl(c.Just.create)(c.Nothing.value),d=e(10),c=b.fromNumberImpl(c.Just.create)(c.Nothing.value);a.fromNumber=c;a.fromString=d;a.fromStringAs=e;a.toNumber=b.toNumber;})(PS["Data.Int"]=PS["Data.Int"]||{});
(function(a){a._charAt=function(a){return function(b){return function(c){return function(d){return 0<=c&&c<d.length?a(d.charAt(c)):b}}}};a.singleton=function(a){return a};a._toChar=function(a){return function(b){return function(c){return 1===c.length?a(c):b}}};a.fromCharArray=function(a){return a.join("")};a._indexOf=function(a){return function(b){return function(c){return function(d){d=d.indexOf(c);return -1===d?b:a(d)}}}};a._lastIndexOf=function(a){return function(b){return function(c){return function(d){d=
d.lastIndexOf(c);return -1===d?b:a(d)}}}};a.length=function(a){return a.length};a.take=function(a){return function(b){return b.substr(0,a)}};a.drop=function(a){return function(b){return b.substring(a)}};a.split=function(a){return function(b){return b.split(a)}};a.toCharArray=function(a){return a.split("")};a.toUpper=function(a){return a.toUpperCase()};a.trim=function(a){return a.trim()};a.joinWith=function(a){return function(b){return b.join(a)}};})(PS["Data.String"]=PS["Data.String"]||{});
(function(a){a.charAt=function(a){return function(b){if(0<=a&&a<b.length)return b.charAt(a);throw Error("Data.String.Unsafe.charAt: Invalid index.");}};})(PS["Data.String.Unsafe"]=PS["Data.String.Unsafe"]||{});(function(a){a.charAt=PS["Data.String.Unsafe"].charAt;})(PS["Data.String.Unsafe"]=PS["Data.String.Unsafe"]||{});
(function(a){var b=PS["Data.String"],c=PS["Data.Maybe"],e=PS["Data.Newtype"],d=PS["Data.String.Unsafe"],g=function(a){return a},k=b._toChar(c.Just.create)(c.Nothing.value),e=new e.Newtype(function(a){return a},g),l=b._lastIndexOf(c.Just.create)(c.Nothing.value),h=b._indexOf(c.Just.create)(c.Nothing.value),f=b._charAt(c.Just.create)(c.Nothing.value);a.Pattern=g;a.charAt=f;a.contains=function(a){return function(b){return c.isJust(h(a)(b))}};a.indexOf=h;a.lastIndexOf=l;a["null"]=function(a){return ""===
a};a.stripPrefix=function(a){return function(d){var f=h(a)(d);return f instanceof c.Just&&0===f.value0?c.Just.create(b.drop(b.length(a))(d)):c.Nothing.value}};a.stripSuffix=function(a){return function(d){var f=l(a)(d);return f instanceof c.Just&&f.value0===(b.length(d)-b.length(a)|0)?c.Just.create(b.take(f.value0)(d)):c.Nothing.value}};a.toChar=k;a.uncons=function(a){return ""===a?c.Nothing.value:new c.Just({head:d.charAt(0)(a),tail:b.drop(1)(a)})};a.newtypePattern=e;a.drop=b.drop;a.fromCharArray=
b.fromCharArray;a.joinWith=b.joinWith;a.length=b.length;a.singleton=b.singleton;a.split=b.split;a.take=b.take;a.toCharArray=b.toCharArray;a.toUpper=b.toUpper;a.trim=b.trim;})(PS["Data.String"]=PS["Data.String"]||{});(function(a){var b=function(){function a(){}a.value=new a;return a}();a.Proxy=b;})(PS["Type.Proxy"]=PS["Type.Proxy"]||{});
(function(a){var b=PS["Data.Array"],c=PS["Data.Maybe"],e=PS["Data.NonEmpty"],d=PS["Data.String"],g=PS["Data.Traversable"],k=PS["Type.Proxy"],l=PS["Data.Functor"],h=PS["Data.Unit"],f=PS["Control.Apply"],m=PS["Control.Applicative"],n=PS["Data.Show"],r=PS["Data.Boolean"],p=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),t=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),B=function(){function a(a){this.value0=
a;}a.create=function(b){return new a(b)};return a}(),q=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),w=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),x=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),y=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),C=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),
u=function(){function a(){}a.value=new a;return a}(),A=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),z=function(){function a(){}a.value=new a;return a}(),E=function(){function a(){}a.value=new a;return a}(),F=function(){function a(){}a.value=new a;return a}(),G=function(){function a(){}a.value=new a;return a}(),I=function(){function a(){}a.value=new a;return a}(),v=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};
return a}(),H=function(a,b,c){this.fromSpine=a;this.toSignature=b;this.toSpine=c;},L=new H(function(a){return a instanceof x?new c.Just(a.value0):c.Nothing.value},function(a){return G.value},x.create),J=new H(function(a){return a instanceof B?new c.Just(a.value0):c.Nothing.value},function(a){return z.value},B.create),K=new H(function(a){return a instanceof w?new c.Just(a.value0):c.Nothing.value},function(a){return F.value},w.create),S=new H(function(a){return a instanceof y?new c.Just(a.value0):c.Nothing.value},
function(a){return I.value},y.create),R=new H(function(a){return a instanceof q?new c.Just(a.value0):c.Nothing.value},function(a){return E.value},q.create),P=function(a){return function(c){if(c instanceof p){if(b["null"](c.value1))return c.value0;if(r.otherwise)return function(a){return function(b){if(!a)return b;if(a)return "("+(b+")");throw Error("Failed pattern match at Data.Generic line 380, column 7 - line 380, column 28: "+[a.constructor.name,b.constructor.name]);}}(10<a)(c.value0+(" "+d.joinWith(" ")(l.map(l.functorArray)(function(a){return P(11)(a(h.unit))})(c.value1))))}if(c instanceof
t)return "{"+(d.joinWith(", ")(l.map(l.functorArray)(function(a){return a.recLabel+(": "+P(0)((0, a.recValue)(h.unit)))})(c.value0))+"}");if(c instanceof q)return n.show(n.showBoolean)(c.value0);if(c instanceof w)return n.show(n.showInt)(c.value0);if(c instanceof B)return n.show(n.showNumber)(c.value0);if(c instanceof x)return n.show(n.showString)(c.value0);if(c instanceof y)return n.show(n.showChar)(c.value0);if(c instanceof C)return "["+(d.joinWith(", ")(l.map(l.functorArray)(function(a){return P(0)(a(h.unit))})(c.value0))+
"]");if(c instanceof u)return "unit";throw Error("Failed pattern match at Data.Generic line 374, column 1 - line 382, column 1: "+[a.constructor.name,c.constructor.name]);}};a.SigProd=A;a.SigNumber=z;a.SigBoolean=E;a.SigInt=F;a.SigString=G;a.SigChar=I;a.SigArray=v;a.SProd=p;a.SRecord=t;a.SNumber=B;a.SBoolean=q;a.SInt=w;a.SString=x;a.SChar=y;a.SArray=C;a.SUnit=u;a.Generic=H;a.fromSpine=function(a){return a.fromSpine};a.gShow=function(a){return function(b){return P(0)((0, a.toSpine)(b))}};a.toSignature=
function(a){return a.toSignature};a.toSpine=function(a){return a.toSpine};a.genericNumber=J;a.genericInt=K;a.genericString=L;a.genericChar=S;a.genericBool=R;a.genericArray=function(a){return new H(function(b){return b instanceof C?g.traverse(g.traversableArray)(c.applicativeMaybe)(function(b){return (0, a.fromSpine)(b(h.unit))})(b.value0):c.Nothing.value},function(b){return new v(function(b){return (0, a.toSignature)(k.Proxy.value)})},function(b){return C.create(l.map(l.functorArray)(function(b){return function(c){return (0, a.toSpine)(b)}})(b))})};
a.genericMaybe=function(a){return new H(function(b){return b instanceof p&&"Data.Maybe.Just"===b.value0&&1===b.value1.length?l.map(c.functorMaybe)(c.Just.create)((0, a.fromSpine)((0, b.value1[0])(h.unit))):b instanceof p&&"Data.Maybe.Nothing"===b.value0&&0===b.value1.length?m.pure(c.applicativeMaybe)(c.Nothing.value):c.Nothing.value},function(b){return new A("Data.Maybe.Maybe",[{sigConstructor:"Data.Maybe.Just",sigValues:[function(b){return (0, a.toSignature)(k.Proxy.value)}]},{sigConstructor:"Data.Maybe.Nothing",
sigValues:[]}])},function(b){if(b instanceof c.Just)return new p("Data.Maybe.Just",[function(c){return (0, a.toSpine)(b.value0)}]);if(b instanceof c.Nothing)return new p("Data.Maybe.Nothing",[]);throw Error("Failed pattern match at Data.Generic line 110, column 3 - line 110, column 63: "+[b.constructor.name]);})};a.genericNonEmpty=function(a){return function(b){return new H(function(d){return d instanceof p&&"Data.NonEmpty.NonEmpty"===d.value0&&2===d.value1.length?f.apply(c.applyMaybe)(l.map(c.functorMaybe)(e.NonEmpty.create)((0, b.fromSpine)((0, d.value1[0])(h.unit))))((0, a.fromSpine)((0, d.value1[1])(h.unit))):
c.Nothing.value},function(c){return new A("Data.NonEmpty.NonEmpty",[{sigConstructor:"Data.NonEmpty.NonEmpty",sigValues:[function(a){return (0, b.toSignature)(k.Proxy.value)},function(b){return (0, a.toSignature)(k.Proxy.value)}]}])},function(c){return new p("Data.NonEmpty.NonEmpty",[function(a){return (0, b.toSpine)(c.value0)},function(b){return (0, a.toSpine)(c.value1)}])})}};})(PS["Data.Generic"]=PS["Data.Generic"]||{});
(function(a){var b=PS["Control.Alt"],c=PS["Control.Alternative"],e=PS["Control.Apply"],d=PS["Control.MonadPlus"],g=PS["Control.MonadZero"],k=PS["Control.Plus"],l=PS["Data.Foldable"],h=PS["Data.Maybe"],f=PS["Data.Monoid"],m=PS["Data.Newtype"],n=PS["Data.NonEmpty"],r=PS["Data.Traversable"],p=PS["Data.Unfoldable"],t=PS["Data.Show"],B=PS["Data.Semigroup"],q=PS["Data.Functor"],w=PS["Data.Eq"],x=PS["Data.Function"],y=PS["Data.Ord"],C=PS["Data.Ordering"],u=PS["Control.Applicative"],A=PS["Control.Category"],
z=PS["Control.Bind"],E=PS["Control.Monad"],F=function(){function a(){}a.value=new a;return a}(),G=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),I=function(a){return a},v=function(a){return new G(a.value0,a.value1)},m=new m.Newtype(function(a){return a},I),H=new l.Foldable(function(a){return function(b){return l.foldl(H)(function(c){return function(d){return B.append(a["__superclass_Data.Semigroup.Semigroup_0"]())(c)(b(d))}})(f.mempty(a))}},
function(a){return function(b){return function(c){var d=b;a:for(;;){if(c instanceof F)return d;if(c instanceof G){d=a(d)(c.value0);c=c.value1;continue a}throw Error("Failed pattern match at Data.List.Types line 66, column 3 - line 69, column 34: "+[d.constructor.name,c.constructor.name]);}}}},function(a){return function(b){return function(c){return l.foldl(H)(x.flip(a))(b)(function(a){return function(b){var c=a;a:for(;;){if(b instanceof F)return c;if(b instanceof G){c=new G(b.value0,c);b=b.value1;
continue a}throw Error("Failed pattern match at Data.List.Types line 62, column 3 - line 65, column 40: "+[c.constructor.name,b.constructor.name]);}}}(F.value)(c))}}}),L=n.foldableNonEmpty(H),J=new q.Functor(function(a){return l.foldr(H)(function(b){return function(c){return new G(a(b),c)}})(F.value)}),K=n.functorNonEmpty(J),S=new B.Semigroup(function(a){return function(b){return l.foldr(H)(G.create)(b)(a)}}),R=new B.Semigroup(function(a){return function(b){return new n.NonEmpty(a.value0,B.append(S)(a.value1)(v(b)))}}),
P=function(a){return new t.Show(function(b){return b instanceof F?"Nil":"("+(l.intercalate(H)(f.monoidString)(" : ")(q.map(J)(t.show(a))(b))+" : Nil)")})},N=new r.Traversable(function(){return H},function(){return J},function(a){return r.traverse(N)(a)(A.id(A.categoryFn))},function(a){return function(b){return function(c){return q.map(a["__superclass_Control.Apply.Apply_0"]()["__superclass_Data.Functor.Functor_0"]())(l.foldl(H)(x.flip(G.create))(F.value))(l.foldl(H)(function(c){return function(d){return e.lift2(a["__superclass_Control.Apply.Apply_0"]())(x.flip(G.create))(c)(b(d))}})(u.pure(a)(F.value))(c))}}}),
p=new p.Unfoldable(function(a){return function(b){return function(b){return function(c){var d=b;a:for(;;){d=a(d);if(d instanceof h.Nothing)return l.foldl(H)(x.flip(G.create))(F.value)(c);if(d instanceof h.Just){c=new G(d.value0.value0,c);d=d.value0.value1;continue a}throw Error("Failed pattern match at Data.List.Types line 75, column 24 - line 77, column 54: "+[d.constructor.name]);}}}(b)(F.value)}}),O=function(a){return new w.Eq(function(b){return function(c){return function(b){return function(c){return function(d){var f=
b,e=c,h=d;a:for(;;){if(!h)return !1;if(f instanceof F&&e instanceof F)return h;if(f instanceof G&&e instanceof G){d=f.value1;var k=e.value1,h=h&&w.eq(a)(e.value0)(f.value0),f=d,e=k;continue a}return !1}}}}(b)(c)(!0)}})},D=new e.Apply(function(){return J},function(a){return function(b){if(a instanceof F)return F.value;if(a instanceof G)return B.append(S)(q.map(J)(a.value0)(b))(e.apply(D)(a.value1)(b));throw Error("Failed pattern match at Data.List.Types line 84, column 3 - line 84, column 20: "+[a.constructor.name,
b.constructor.name]);}}),M=new z.Bind(function(){return D},function(a){return function(b){if(a instanceof F)return F.value;if(a instanceof G)return B.append(S)(b(a.value0))(z.bind(M)(a.value1)(b));throw Error("Failed pattern match at Data.List.Types line 91, column 3 - line 91, column 19: "+[a.constructor.name,b.constructor.name]);}}),U=new u.Applicative(function(){return D},function(a){return new G(a,F.value)}),X=new E.Monad(function(){return U},function(){return M}),T=new b.Alt(function(){return J},
B.append(S)),ca=new k.Plus(function(){return T},F.value),da=new c.Alternative(function(){return U},function(){return ca}),Q=new g.MonadZero(function(){return da},function(){return X}),b=new d.MonadPlus(function(){return Q});a.Nil=F;a.Cons=G;a.NonEmptyList=I;a.toList=v;a.showList=P;a.eqList=O;a.ordList=function(a){return new y.Ord(function(){return O(a["__superclass_Data.Eq.Eq_0"]())},function(b){return function(c){return function(b){return function(c){var d=b;a:for(;;){if(d instanceof F&&c instanceof
F)return C.EQ.value;if(d instanceof F)return C.LT.value;if(c instanceof F)return C.GT.value;if(d instanceof G&&c instanceof G){var f=y.compare(a)(d.value0)(c.value0);if(f instanceof C.EQ){c=c.value1;d=d.value1;continue a}return f}throw Error("Failed pattern match at Data.List.Types line 42, column 3 - line 50, column 23: "+[d.constructor.name,c.constructor.name]);}}}(b)(c)}})};a.semigroupList=S;a.functorList=J;a.foldableList=H;a.unfoldableList=p;a.traversableList=N;a.applyList=D;a.applicativeList=
U;a.bindList=M;a.monadList=X;a.altList=T;a.plusList=ca;a.alternativeList=da;a.monadZeroList=Q;a.monadPlusList=b;a.newtypeNonEmptyList=m;a.showNonEmptyList=function(a){return new t.Show(function(b){return "(NonEmptyList "+(t.show(n.showNonEmpty(a)(P(a)))(b)+")")})};a.functorNonEmptyList=K;a.semigroupNonEmptyList=R;a.foldableNonEmptyList=L;})(PS["Data.List.Types"]=PS["Data.List.Types"]||{});
(function(a){var b=PS["Control.Alt"],c=PS["Control.Lazy"],e=PS["Data.Foldable"],d=PS["Data.List.Types"],g=PS["Data.Maybe"],k=PS["Data.NonEmpty"],l=PS["Data.Tuple"],h=PS["Data.Unfoldable"],f=PS["Data.Functor"],m=PS["Data.Eq"],n=PS["Data.Ordering"],r=PS["Data.Boolean"],p=PS["Control.Bind"],t=PS["Control.Applicative"],B=PS["Control.Apply"],q=PS["Control.Category"],w=function(a){if(a instanceof d.Nil)return g.Nothing.value;if(a instanceof d.Cons)return new g.Just({head:a.value0,tail:a.value1});throw Error("Failed pattern match at Data.List line 253, column 1 - line 253, column 21: "+
[a.constructor.name]);},x=function(a){return function(b){if(b instanceof d.Cons&&a(b.value0)){var c=x(a)(b.value1);return {init:new d.Cons(b.value0,c.init),rest:c.rest}}return {init:d.Nil.value,rest:b}}},y=function(a){return new d.Cons(a,d.Nil.value)},C=function(){return function(a){return function(b){var c=a;a:for(;;){if(b instanceof d.Nil)return c;if(b instanceof d.Cons){c=new d.Cons(b.value0,c);b=b.value1;continue a}throw Error("Failed pattern match at Data.List line 359, column 1 - line 362, column 36: "+
[c.constructor.name,b.constructor.name]);}}}(d.Nil.value)}(),u=function(a){return f.map(g.functorMaybe)(function(a){return {init:C(a.revInit),last:a.last}})(function(a){return function(b){var c=a,f=b;a:for(;;){if(c instanceof d.Nil)return g.Nothing.value;if(c instanceof d.Cons&&c.value1 instanceof d.Nil)return new g.Just({revInit:f,last:c.value0});if(c instanceof d.Cons){b=c.value1;f=new d.Cons(c.value0,f);c=b;continue a}throw Error("Failed pattern match at Data.List line 261, column 1 - line 265, column 36: "+
[c.constructor.name,f.constructor.name]);}}}(a)(d.Nil.value))},A=function(a){return function(b){return function(c){var f=b;a:for(;;){if(c instanceof d.Nil)return C(f);if(c instanceof d.Cons){var e=a(c.value0);if(e instanceof g.Nothing){c=c.value1;continue a}if(e instanceof g.Just){f=new d.Cons(e.value0,f);c=c.value1;continue a}throw Error("Failed pattern match at Data.List line 412, column 5 - line 414, column 32: "+[e.constructor.name]);}throw Error("Failed pattern match at Data.List line 408, column 1 - line 414, column 32: "+
[f.constructor.name,c.constructor.name]);}}}(d.Nil.value)},z=function(a){return function(b){return function(e){return B.apply(a["__superclass_Control.Applicative.Applicative_0"]()["__superclass_Control.Apply.Apply_0"]())(f.map(a["__superclass_Control.Plus.Plus_1"]()["__superclass_Control.Alt.Alt_0"]()["__superclass_Data.Functor.Functor_0"]())(d.Cons.create)(e))(c.defer(b)(function(c){return E(a)(b)(e)}))}}},E=function(a){return function(c){return function(f){return b.alt(a["__superclass_Control.Plus.Plus_1"]()["__superclass_Control.Alt.Alt_0"]())(z(a)(c)(f))(t.pure(a["__superclass_Control.Applicative.Applicative_0"]())(d.Nil.value))}}},
F=e.foldl(d.foldableList)(function(a){return function(b){return a+1|0}})(0),G=function(a){return function(b){if(b instanceof d.Nil)return d.Nil.value;if(b instanceof d.Cons){var c=x(a(b.value0))(b.value1);return new d.Cons(new k.NonEmpty(b.value0,c.init),G(a)(c.rest))}throw Error("Failed pattern match at Data.List line 560, column 1 - line 560, column 20: "+[a.constructor.name,b.constructor.name]);}},I=function(a){return function(b){return function(c){return function(f){if(f instanceof d.Nil)return t.pure(a["__superclass_Control.Applicative.Applicative_0"]())(c);
if(f instanceof d.Cons)return p.bind(a["__superclass_Control.Bind.Bind_1"]())(b(c)(f.value0))(function(c){return I(a)(b)(c)(f.value1)});throw Error("Failed pattern match at Data.List line 698, column 1 - line 698, column 23: "+[b.constructor.name,c.constructor.name,f.constructor.name]);}}}},v=function(a){return function(b){return function(c){var f=b;a:for(;;){if(c instanceof d.Nil)return C(f);if(c instanceof d.Cons){if(a(c.value0)){f=new d.Cons(c.value0,f);c=c.value1;continue a}if(r.otherwise){c=
c.value1;continue a}}throw Error("Failed pattern match at Data.List line 381, column 1 - line 386, column 28: "+[f.constructor.name,c.constructor.name]);}}}(d.Nil.value)},H=function(a){return function(b){if(b instanceof d.Nil)return d.Nil.value;if(b instanceof d.Cons)return new d.Cons(b.value0,H(a)(v(function(c){return !a(b.value0)(c)})(b.value1)));throw Error("Failed pattern match at Data.List line 579, column 1 - line 579, column 22: "+[a.constructor.name,b.constructor.name]);}},L=A(q.id(q.categoryFn));
a.catMaybes=L;a.concat=function(a){return p.bind(d.bindList)(a)(q.id(q.categoryFn))};a.filter=v;a.foldM=I;a.fromFoldable=function(a){return e.foldr(a)(d.Cons.create)(d.Nil.value)};a.groupBy=G;a.head=function(a){if(a instanceof d.Nil)return g.Nothing.value;if(a instanceof d.Cons)return new g.Just(a.value0);throw Error("Failed pattern match at Data.List line 224, column 1 - line 224, column 19: "+[a.constructor.name]);};a.init=function(a){return f.map(g.functorMaybe)(function(a){return a.init})(u(a))};
a.last=function(a){a:for(;;){if(a instanceof d.Cons&&a.value1 instanceof d.Nil)return new g.Just(a.value0);if(a instanceof d.Cons){a=a.value1;continue a}return g.Nothing.value}};a.length=F;a.many=E;a.mapMaybe=A;a.nub=function(a){return H(m.eq(a))};a.nubBy=H;a["null"]=function(a){return a instanceof d.Nil?!0:!1};a.reverse=C;a.singleton=y;a.some=z;a.sortBy=function(a){var b=function(c){return function(f){if(c instanceof d.Cons&&f instanceof d.Cons){if(m.eq(n.eqOrdering)(a(c.value0)(f.value0))(n.GT.value))return new d.Cons(f.value0,
b(c)(f.value1));if(r.otherwise)return new d.Cons(c.value0,b(c.value1)(f))}if(c instanceof d.Nil)return f;if(f instanceof d.Nil)return c;throw Error("Failed pattern match at Data.List line 468, column 3 - line 470, column 41: "+[c.constructor.name,f.constructor.name]);}},c=function(a){return a instanceof d.Cons&&a.value1 instanceof d.Cons?new d.Cons(b(a.value0)(a.value1.value0),c(a.value1.value1)):a},f=function(b){if(b instanceof d.Cons&&b.value1 instanceof d.Cons){if(m.eq(n.eqOrdering)(a(b.value0)(b.value1.value0))(n.GT.value))return e(b.value1.value0)(y(b.value0))(b.value1.value1);
if(r.otherwise)return h(b.value1.value0)(function(a){return new d.Cons(b.value0,a)})(b.value1.value1)}return y(b)},e=function(b){return function(c){return function(e){var h=b,k=c,l=e;a:for(;;){if(l instanceof d.Cons&&m.eq(n.eqOrdering)(a(h)(l.value0))(n.GT.value)){e=l.value0;k=new d.Cons(h,k);l=l.value1;h=e;continue a}return new d.Cons(new d.Cons(h,k),f(l))}}}},h=function(b){return function(c){return function(e){return e instanceof d.Cons&&m.notEq(n.eqOrdering)(a(b)(e.value0))(n.GT.value)?h(e.value0)(function(a){return c(new d.Cons(b,
a))})(e.value1):new d.Cons(c(y(b)),f(e))}}};return function(a){a:for(a=f(a);;){if(a instanceof d.Cons&&a.value1 instanceof d.Nil){a=a.value0;break a}a=c(a);}return a}};a.span=x;a.tail=function(a){if(a instanceof d.Nil)return g.Nothing.value;if(a instanceof d.Cons)return new g.Just(a.value1);throw Error("Failed pattern match at Data.List line 239, column 1 - line 239, column 19: "+[a.constructor.name]);};a.toUnfoldable=function(a){return h.unfoldr(a)(function(a){return f.map(g.functorMaybe)(function(a){return new l.Tuple(a.head,
a.tail)})(w(a))})};a.uncons=w;a.unsnoc=u;})(PS["Data.List"]=PS["Data.List"]||{});(function(a){var b=PS["Data.List.Types"],c=PS["Data.NonEmpty"];a.head=function(a){return a.value0};a.singleton=function(a){return b.NonEmptyList(c.singleton(b.plusList)(a))};a.toList=function(a){return new b.Cons(a.value0,a.value1)};})(PS["Data.List.NonEmpty"]=PS["Data.List.NonEmpty"]||{});
(function(a){var b=PS["Data.Foreign"],c=PS["Control.Monad.Except"],e=PS["Data.Either"],d=PS["Data.Int"],g=PS["Data.List.NonEmpty"],k=PS["Data.Maybe"],l=PS["Data.String"],h=PS["Data.Show"],f=PS["Control.Monad.Error.Class"],m=PS["Control.Monad.Except.Trans"],n=PS["Data.Identity"],r=PS["Control.Applicative"],p=PS["Data.Function"],t=PS["Data.Boolean"],B=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),q=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=
function(b){return function(c){return new a(b,c)}};return a}(),w=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),x=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),y=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),C=new h.Show(function(a){if(a instanceof B)return "(ForeignError "+(a.value0+")");if(a instanceof
w)return "(ErrorAtIndex "+(h.show(h.showInt)(a.value0)+(" "+(h.show(C)(a.value1)+")")));if(a instanceof x)return "(ErrorAtProperty "+(h.show(h.showString)(a.value0)+(" "+(h.show(C)(a.value1)+")")));if(a instanceof y)return "(JSONError "+(h.show(h.showString)(a.value0)+")");if(a instanceof q)return "(TypeMismatch "+(h.show(h.showString)(a.value0)+(" "+(h.show(h.showString)(a.value1)+")")));throw Error("Failed pattern match at Data.Foreign line 66, column 3 - line 67, column 3: "+[a.constructor.name]);
}),u=function(a){return f.throwError(m.monadErrorExceptT(n.monadIdentity))(g.singleton(a))},A=function(a){return function(c){if(b.tagOf(c)===a)return r.pure(m.applicativeExceptT(n.monadIdentity))(b.unsafeFromForeign(c));if(t.otherwise)return u(new q(a,b.tagOf(c)));throw Error("Failed pattern match at Data.Foreign line 109, column 1 - line 111, column 54: "+[a.constructor.name,c.constructor.name]);}},z=A("Boolean"),E=A("Number"),F=A("String");a.ForeignError=B;a.TypeMismatch=q;a.ErrorAtIndex=w;a.ErrorAtProperty=
x;a.JSONError=y;a.fail=u;a.readArray=function(a){if(b.isArray(a))return r.pure(m.applicativeExceptT(n.monadIdentity))(b.unsafeFromForeign(a));if(t.otherwise)return u(new q("array",b.tagOf(a)));throw Error("Failed pattern match at Data.Foreign line 150, column 1 - line 152, column 58: "+[a.constructor.name]);};a.readBoolean=z;a.readChar=function(a){var d=e.Left.create(g.singleton(new q("Char",b.tagOf(a))));return c.mapExcept(e.either(p["const"](d))(function(a){return k.maybe(d)(r.pure(e.applicativeEither))(l.toChar(a))}))(F(a))};
a.readInt=function(a){var f=e.Left.create(g.singleton(new q("Int",b.tagOf(a))));return c.mapExcept(e.either(p["const"](f))(function(a){return k.maybe(f)(r.pure(e.applicativeEither))(d.fromNumber(a))}))(E(a))};a.readNumber=E;a.readString=F;a.unsafeReadTagged=A;a.showForeignError=C;a.isNull=b.isNull;a.isUndefined=b.isUndefined;a.toForeign=b.toForeign;a.typeOf=b.typeOf;a.unsafeFromForeign=b.unsafeFromForeign;})(PS["Data.Foreign"]=PS["Data.Foreign"]||{});
(function(a){a.unsafeReadPropImpl=function(a,c,e,d){return null==d?a:c(d[e])};a.unsafeHasOwnProperty=function(a,c){return Object.prototype.hasOwnProperty.call(c,a)};a.unsafeHasProperty=function(a,c){return a in c};})(PS["Data.Foreign.Index"]=PS["Data.Foreign.Index"]||{});
(function(a){var b=PS["Data.Foreign.Index"],c=PS["Data.Foreign"],e=PS["Control.Applicative"],d=PS["Control.Monad.Except.Trans"],g=PS["Data.Identity"],k=function(a,b,c,d){this.errorAt=a;this.hasOwnProperty=b;this.hasProperty=c;this.ix=d;},l=function(a){return function(f){return b.unsafeReadPropImpl(c.fail(new c.TypeMismatch("object",c.typeOf(f))),e.pure(d.applicativeExceptT(g.monadIdentity)),a,f)}},h=new k(c.ErrorAtProperty.create,function(a){return function(d){return c.isNull(d)||c.isUndefined(d)?
!1:"object"===c.typeOf(d)||"function"===c.typeOf(d)?b.unsafeHasOwnProperty(a,d):!1}},function(a){return function(d){return c.isNull(d)||c.isUndefined(d)?!1:"object"===c.typeOf(d)||"function"===c.typeOf(d)?b.unsafeHasProperty(a,d):!1}},PS["Data.Function"].flip(l));a.Index=k;a.errorAt=function(a){return a.errorAt};a.hasOwnProperty=function(a){return a.hasOwnProperty};a.hasProperty=function(a){return a.hasProperty};a.ix=function(a){return a.ix};a.prop=l;a.indexString=h;})(PS["Data.Foreign.Index"]=PS["Data.Foreign.Index"]||
{});
(function(a){var b=PS["Data.Maybe"],c=PS["Data.Foreign"],e=PS["Control.Applicative"],d=PS["Control.Monad.Except.Trans"],g=PS["Data.Identity"],k=PS["Data.Functor"];a.NullOrUndefined=function(a){return a};a.readNullOrUndefined=function(a){return function(h){return c.isNull(h)||c.isUndefined(h)?e.pure(d.applicativeExceptT(g.monadIdentity))(b.Nothing.value):k.map(d.functorExceptT(g.functorIdentity))(function(a){return b.Just.create(a)})(a(h))}};a.unNullOrUndefined=function(a){return a};})(PS["Data.Foreign.NullOrUndefined"]=PS["Data.Foreign.NullOrUndefined"]||
{});
(function(a){var b=PS["Control.Monad.Except"],c=PS["Data.Array"],e=PS["Data.Bifunctor"],d=PS["Data.Either"],g=PS["Data.Foreign"],k=PS["Data.Foreign.Index"],l=PS["Data.Foreign.NullOrUndefined"],h=PS["Data.Traversable"],f=PS["Control.Applicative"],m=PS["Data.Functor"],n=PS["Control.Bind"],r=PS["Control.Monad.Except.Trans"],p=PS["Data.List.Types"],t=PS["Data.Identity"],B=function(a){this.read=a;},q=function(a){this.write=a;},w=new B(g.readString),x=new q(g.toForeign),y=function(a){return function(c){return function(f){return b.mapExcept(e.lmap(d.bifunctorEither)(c))((0, a.read)(f))}}},f=
new B(f.pure(r.applicativeExceptT(t.monadIdentity))),C=new B(g.readChar),u=new q(g.toForeign),A=new B(g.readBoolean),z=new q(g.toForeign);a.AsForeign=q;a.IsForeign=B;a.read=function(a){return a.read};a.readProp=function(a){return function(b){return function(c){return function(d){return n.bind(r.bindExceptT(t.monadIdentity))(k.ix(b)(d)(c))(y(a)(m.map(p.functorNonEmptyList)(k.errorAt(b)(c))))}}}};a.readWith=y;a.write=function(a){return a.write};a.foreignIsForeign=f;a.stringIsForeign=w;a.charIsForeign=
C;a.booleanIsForeign=A;a.arrayIsForeign=function(a){return new B(function(){var b=function(b){return function(c){return y(a)(m.map(p.functorNonEmptyList)(g.ErrorAtIndex.create(b)))(c)}};return n.composeKleisli(r.bindExceptT(t.monadIdentity))(g.readArray)(function(a){return h.sequence(h.traversableArray)(r.applicativeExceptT(t.monadIdentity))(c.zipWith(b)(c.range(0)(c.length(a)))(a))})}())};a.nullOrUndefinedIsForeign=function(a){return new B(l.readNullOrUndefined(a.read))};a.stringAsForeign=x;a.charAsForeign=
u;a.booleanAsForeign=z;a.arrayAsForeign=function(a){return new q(function(b){return g.toForeign(m.map(m.functorArray)(a.write)(b))})};})(PS["Data.Foreign.Class"]=PS["Data.Foreign.Class"]||{});(function(a){a._isTruthy=function(a){return !!a};a.undefined=void 0;})(PS["Data.Foreign.Extra"]=PS["Data.Foreign.Extra"]||{});
(function(a){a._copyEff=function(a){return function(){var b={},e;for(e in a)hasOwnProperty.call(a,e)&&(b[e]=a[e]);return b}};a.empty={};a.runST=function(a){return a};a._fmapStrMap=function(a,c){var b={},d;for(d in a)hasOwnProperty.call(a,d)&&(b[d]=c(a[d]));return b};a._lookup=function(a,c,e,d){return e in d?c(d[e]):a};a._collect=function(a){return function(b){var c=[],d;for(d in b)hasOwnProperty.call(b,d)&&c.push(a(d)(b[d]));return c}};})(PS["Data.StrMap"]=PS["Data.StrMap"]||{});
(function(a){a["new"]=function(){return {}};a.poke=function(a){return function(b){return function(c){return function(){a[b]=c;return a}}}};})(PS["Data.StrMap.ST"]=PS["Data.StrMap.ST"]||{});(function(a){var b=PS["Data.StrMap.ST"];a["new"]=b["new"];a.poke=b.poke;})(PS["Data.StrMap.ST"]=PS["Data.StrMap.ST"]||{});
(function(a){var b=PS["Data.StrMap"],c=PS["Control.Monad.Eff"],e=PS["Data.Foldable"],d=PS["Data.List"],g=PS["Data.Maybe"],k=PS["Data.StrMap.ST"],l=PS["Data.Tuple"],h=PS["Data.Functor"],f=PS["Data.Show"],m=PS["Data.List.Types"],n=function(a){return d.fromFoldable(e.foldableArray)(b._collect(l.Tuple.create)(a))},r=b._copyEff,p=function(a){return c.runPure(b.runST(a))},t=function(a){return function(b){return p(function(){var c=r(b)();a(c)();return c})}},g=PS["Data.Function.Uncurried"].runFn4(b._lookup)(g.Nothing.value)(g.Just.create),
B=new h.Functor(function(a){return function(c){return b._fmapStrMap(c,a)}});a.fromFoldable=function(a){return function(b){return p(function(){var d=k["new"]();e.for_(c.applicativeEff)(a)(b)(function(a){return k.poke(d)(a.value0)(a.value1)})();return d})}};a.insert=function(a){return function(b){return t(function(d){return h["void"](c.functorEff)(k.poke(d)(a)(b))})}};a.lookup=g;a.pureST=p;a.thawST=r;a.toList=n;a.functorStrMap=B;a.showStrMap=function(a){return new f.Show(function(b){return "fromList "+
f.show(m.showList(l.showTuple(f.showString)(a)))(n(b))})};a.empty=b.empty;})(PS["Data.StrMap"]=PS["Data.StrMap"]||{});
(function(a){var b=PS["Data.Foreign.Extra"],c=PS["Data.Maybe"],e=PS["Data.Array"],d=PS["Data.NonEmpty"],g=PS["Data.List"],k=PS["Data.List.NonEmpty"],l=PS["Data.Foreign"],h=PS["Data.Foreign.NullOrUndefined"],f=PS["Data.Foreign.Index"],m=PS["Data.Foreign.Class"],n=PS["Control.Applicative"],r=PS["Control.Bind"],p=PS["Control.Monad.Except.Trans"],t=PS["Data.Identity"],B=PS["Data.Foldable"],q=PS["Data.List.Types"],w=PS["Data.Show"],x=PS["Control.Monad.Error.Class"],y=function(a){return function(b){return function(d){return function(e){var k=
f.hasOwnProperty(b)(d)(e);if(k)return r.bind(p.bindExceptT(t.monadIdentity))(m.readProp(m.nullOrUndefinedIsForeign(a))(b)(d)(e))(function(a){return n.pure(p.applicativeExceptT(t.monadIdentity))(h.unNullOrUndefined(a))});if(!k)return n.pure(p.applicativeExceptT(t.monadIdentity))(c.Nothing.value);throw Error("Failed pattern match at Data.Foreign.Extra line 32, column 3 - line 36, column 22: "+[k.constructor.name]);}}}},C=function(){var a=function(b){return b instanceof l.ErrorAtIndex?"["+(w.show(w.showInt)(b.value0)+
("]"+a(b.value1))):b instanceof l.ErrorAtProperty?"["+(w.show(w.showString)(b.value0)+("]"+a(b.value1))):": "+w.show(l.showForeignError)(b)};return function(b){return b instanceof l.ErrorAtIndex?"Error at ["+(w.show(w.showInt)(b.value0)+("]"+a(b.value1))):b instanceof l.ErrorAtProperty?"Error at ["+(w.show(w.showString)(b.value0)+("]"+a(b.value1))):w.show(l.showForeignError)(b)}}(),u=function(a){return "object"===l.typeOf(a)},A=new m.IsForeign(function(a){return n.pure(p.applicativeExceptT(t.monadIdentity))(a)});
a.defaultIfUndefined=function(a){return function(b){return function(d){return function(f){return function(e){return r.bind(p.bindExceptT(t.monadIdentity))(y(m.foreignIsForeign)(b)(d)(e))(function(b){return c.maybe(n.pure(p.applicativeExceptT(t.monadIdentity))(f))(m.read(a))(b)})}}}}};a.errorAtIndex=function(a){return function(b){return x.catchError(p.monadErrorExceptT(t.monadIdentity))(b)(function(b){return l.fail(new l.ErrorAtIndex(a,k.head(b)))})}};a.isObject=u;a.isTruthy=function(a){return b._isTruthy(a)};
a.prettyForeignError=C;a.readNonemptyArray=function(a){return function(b){return r.bind(p.bindExceptT(t.monadIdentity))(m.read(m.arrayIsForeign(a))(b))(function(a){a=e.uncons(a);return a instanceof c.Just?n.pure(p.applicativeExceptT(t.monadIdentity))(new d.NonEmpty(a.value0.head,a.value0.tail)):l.fail(l.JSONError.create("array is empty"))})}};a.readNonemptyList=function(a){return function(b){return r.bind(p.bindExceptT(t.monadIdentity))(m.read(m.arrayIsForeign(a))(b))(function(a){a=g.fromFoldable(B.foldableArray)(a);
return a instanceof q.Cons?n.pure(p.applicativeExceptT(t.monadIdentity))(new d.NonEmpty(a.value0,a.value1)):l.fail(l.JSONError.create("list is empty"))})}};a.readObject=function(a){return u(a)?n.pure(p.applicativeExceptT(t.monadIdentity))(l.unsafeFromForeign(a)):l.fail(new l.TypeMismatch("object",l.typeOf(a)))};a.readPropMaybe=y;a.truthy=function(a){return l.toForeign(a)};a.isForeignTruthy=A;a.undefined=b.undefined;})(PS["Data.Foreign.Extra"]=PS["Data.Foreign.Extra"]||{});
(function(a){a.defer=function(){function a(b){return this instanceof a?(this.thunk=b,this):new a(b)}a.prototype.force=function(){var a=this.thunk();this.thunk=null;this.force=function(){return a};return a};return a}();a.force=function(a){return a.force()};})(PS["Data.Lazy"]=PS["Data.Lazy"]||{});(function(a){var b=PS["Data.Lazy"];a.defer=b.defer;a.force=b.force;})(PS["Data.Lazy"]=PS["Data.Lazy"]||{});
(function(a){var b=PS["Data.List.Types"],c=function(a){return function(d){var e=function(a){return function(a){return a}}();if(d instanceof b.Cons&&d.value1 instanceof b.Nil)d=d.value0;else if(d instanceof b.Cons)d=c()(d.value1);else throw Error("Failed pattern match at Data.List.Partial line 22, column 1 - line 22, column 22: "+[d.constructor.name]);return e(d)}},e=function(a){return function(c){var d=function(a){return function(a){return a}}();if(c instanceof b.Cons&&c.value1 instanceof b.Nil)c=
b.Nil.value;else if(c instanceof b.Cons)c=new b.Cons(c.value0,e()(c.value1));else throw Error("Failed pattern match at Data.List.Partial line 29, column 1 - line 29, column 24: "+[c.constructor.name]);return d(c)}};a.init=e;a.last=c;})(PS["Data.List.Partial"]=PS["Data.List.Partial"]||{});
(function(a){var b=PS["Data.Foldable"],c=PS["Data.Maybe"],e=PS["Data.Tuple"],d=PS["Data.Unfoldable"],g=PS["Data.Eq"],k=PS["Data.Ord"],l=PS["Data.Semigroup"],h=PS["Data.Functor"],f=PS["Control.Applicative"],m=PS["Data.List.Types"],n=PS["Data.Ordering"],r=function(){function a(){}a.value=new a;return a}(),p=function(){function a(a,b,c,d){this.value0=a;this.value1=b;this.value2=c;this.value3=d;}a.create=function(b){return function(c){return function(d){return function(f){return new a(b,c,d,f)}}}};return a}(),
t=function(){function a(a,b,c,d,f,e,h){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=f;this.value5=e;this.value6=h;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return function(h){return function(k){return new a(b,c,d,f,e,h,k)}}}}}}};return a}(),B=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),q=function(){function a(a,
b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),w=function(){function a(a,b,c,d,f,e){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=f;this.value5=e;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return function(h){return new a(b,c,d,f,e,h)}}}}}};return a}(),x=function(){function a(a,b,c,d,f,e){this.value0=a;this.value1=b;this.value2=c;
this.value3=d;this.value4=f;this.value5=e;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return function(h){return new a(b,c,d,f,e,h)}}}}}};return a}(),y=function(){function a(a,b,c,d,f,e){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=f;this.value5=e;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return function(h){return new a(b,c,d,f,e,h)}}}}}};return a}(),C=function(){function a(a,
b,c,d){this.value0=a;this.value1=b;this.value2=c;this.value3=d;}a.create=function(b){return function(c){return function(d){return function(f){return new a(b,c,d,f)}}}};return a}(),u=function(a){return function(b){return new p(r.value,a,b,r.value)}},A=function(a){return function(b){return d.unfoldr(a)(function(a){a:for(;;){if(a instanceof m.Nil)return c.Nothing.value;if(a instanceof m.Cons){if(a.value0 instanceof r){a=a.value1;continue a}if(a.value0 instanceof p&&a.value0.value0 instanceof r&&a.value0.value3 instanceof
r)return c.Just.create(new e.Tuple(new e.Tuple(a.value0.value1,a.value0.value2),a.value1));if(a.value0 instanceof p&&a.value0.value0 instanceof r)return c.Just.create(new e.Tuple(new e.Tuple(a.value0.value1,a.value0.value2),new m.Cons(a.value0.value3,a.value1)));if(a.value0 instanceof p){a=new m.Cons(a.value0.value0,new m.Cons(u(a.value0.value1)(a.value0.value2),new m.Cons(a.value0.value3,a.value1)));continue a}if(a.value0 instanceof t){a=new m.Cons(a.value0.value0,new m.Cons(u(a.value0.value1)(a.value0.value2),
new m.Cons(a.value0.value3,new m.Cons(u(a.value0.value4)(a.value0.value5),new m.Cons(a.value0.value6,a.value1)))));continue a}throw Error("Failed pattern match at Data.Map line 404, column 18 - line 413, column 71: "+[a.value0.constructor.name]);}throw Error("Failed pattern match at Data.Map line 402, column 1 - line 413, column 71: "+[a.constructor.name]);}})(new m.Cons(b,m.Nil.value))}},z=A(d.unfoldableArray),E=A(m.unfoldableList),F=function(a){return function(b){return function(d){if(d instanceof
r)return c.Nothing.value;var f=k.compare(a);return function(a){return function(a){return a}}()(function(){if(d instanceof p){var e=f(b)(d.value1);return e instanceof n.EQ?new c.Just(d.value2):e instanceof n.LT?F(a)(b)(d.value0):F(a)(b)(d.value3)}if(d instanceof t){e=f(b)(d.value1);if(e instanceof n.EQ)return new c.Just(d.value2);var h=f(b)(d.value4);return h instanceof n.EQ?new c.Just(d.value5):e instanceof n.LT?F(a)(b)(d.value0):h instanceof n.GT?F(a)(b)(d.value6):F(a)(b)(d.value3)}throw Error("Failed pattern match at Data.Map line 149, column 10 - line 163, column 39: "+
[d.constructor.name]);}())}}},G=function(a){if(a instanceof r)return m.Nil.value;if(a instanceof p)return l.append(m.semigroupList)(G(a.value0))(l.append(m.semigroupList)(f.pure(m.applicativeList)(a.value1))(G(a.value3)));if(a instanceof t)return l.append(m.semigroupList)(G(a.value0))(l.append(m.semigroupList)(f.pure(m.applicativeList)(a.value1))(l.append(m.semigroupList)(G(a.value3))(l.append(m.semigroupList)(f.pure(m.applicativeList)(a.value4))(G(a.value6)))));throw Error("Failed pattern match at Data.Map line 417, column 1 - line 417, column 16: "+
[a.constructor.name]);},I=new h.Functor(function(a){return function(b){if(b instanceof r)return r.value;if(b instanceof p)return new p(h.map(I)(a)(b.value0),b.value1,a(b.value2),h.map(I)(a)(b.value3));if(b instanceof t)return new t(h.map(I)(a)(b.value0),b.value1,a(b.value2),h.map(I)(a)(b.value3),b.value4,a(b.value5),h.map(I)(a)(b.value6));throw Error("Failed pattern match at Data.Map line 74, column 3 - line 74, column 20: "+[a.constructor.name,b.constructor.name]);}}),v=function(a){return function(a){return function(b){var c=
a,d=b;a:for(;;){if(c instanceof m.Nil)return d;if(c instanceof m.Cons){if(c.value0 instanceof B){b=c.value1;d=new p(d,c.value0.value0,c.value0.value1,c.value0.value2);c=b;continue a}if(c.value0 instanceof q){b=c.value1;d=new p(c.value0.value0,c.value0.value1,c.value0.value2,d);c=b;continue a}if(c.value0 instanceof w){b=c.value1;d=new t(d,c.value0.value0,c.value0.value1,c.value0.value2,c.value0.value3,c.value0.value4,c.value0.value5);c=b;continue a}if(c.value0 instanceof x){b=c.value1;d=new t(c.value0.value0,
c.value0.value1,c.value0.value2,d,c.value0.value3,c.value0.value4,c.value0.value5);c=b;continue a}if(c.value0 instanceof y){b=c.value1;d=new t(c.value0.value0,c.value0.value1,c.value0.value2,c.value0.value3,c.value0.value4,c.value0.value5,d);c=b;continue a}throw Error("Failed pattern match at Data.Map line 240, column 3 - line 245, column 88: "+[c.value0.constructor.name]);}throw Error("Failed pattern match at Data.Map line 238, column 1 - line 238, column 27: "+[c.constructor.name,d.constructor.name]);
}}}},H=function(a){var b=function(b){return function(c){var d=b,f=c;a:for(;;){if(d instanceof m.Nil)return new p(f.value0,f.value1,f.value2,f.value3);if(d instanceof m.Cons){if(d.value0 instanceof B)return v()(d.value1)(new t(f.value0,f.value1,f.value2,f.value3,d.value0.value0,d.value0.value1,d.value0.value2));if(d.value0 instanceof q)return v()(d.value1)(new t(d.value0.value0,d.value0.value1,d.value0.value2,f.value0,f.value1,f.value2,f.value3));if(d.value0 instanceof w){c=d.value1;f=new C(new p(f.value0,
f.value1,f.value2,f.value3),d.value0.value0,d.value0.value1,new p(d.value0.value2,d.value0.value3,d.value0.value4,d.value0.value5));d=c;continue a}if(d.value0 instanceof x){c=d.value1;f=new C(new p(d.value0.value0,d.value0.value1,d.value0.value2,f.value0),f.value1,f.value2,new p(f.value3,d.value0.value3,d.value0.value4,d.value0.value5));d=c;continue a}if(d.value0 instanceof y){c=d.value1;f=new C(new p(d.value0.value0,d.value0.value1,d.value0.value2,d.value0.value3),d.value0.value4,d.value0.value5,
new p(f.value0,f.value1,f.value2,f.value3));d=c;continue a}throw Error("Failed pattern match at Data.Map line 276, column 5 - line 281, column 104: "+[d.value0.constructor.name,f.constructor.name]);}throw Error("Failed pattern match at Data.Map line 274, column 3 - line 274, column 54: "+[d.constructor.name,f.constructor.name]);}}},c=k.compare(a);return function(d){return function(f){return function(e){return function(h){var k=d,l=f,g=e;a:for(;;){if(h instanceof r)return b(k)(new C(r.value,l,g,r.value));
if(h instanceof p){var M=c(l)(h.value1);if(M instanceof n.EQ)return v()(k)(new p(h.value0,l,g,h.value3));if(M instanceof n.LT){k=new m.Cons(new B(h.value1,h.value2,h.value3),k);h=h.value0;continue a}k=new m.Cons(new q(h.value0,h.value1,h.value2),k);h=h.value3;continue a}if(h instanceof t){M=c(l)(h.value1);if(M instanceof n.EQ)return v()(k)(new t(h.value0,l,g,h.value3,h.value4,h.value5,h.value6));var D=c(l)(h.value4);if(D instanceof n.EQ)return v()(k)(new t(h.value0,h.value1,h.value2,h.value3,l,
g,h.value6));if(M instanceof n.LT){k=new m.Cons(new w(h.value1,h.value2,h.value3,h.value4,h.value5,h.value6),k);h=h.value0;continue a}if(M instanceof n.GT&&D instanceof n.LT){k=new m.Cons(new x(h.value0,h.value1,h.value2,h.value4,h.value5,h.value6),k);h=h.value3;continue a}k=new m.Cons(new y(h.value0,h.value1,h.value2,h.value3,h.value4,h.value5),k);h=h.value6;continue a}throw Error("Failed pattern match at Data.Map line 257, column 3 - line 257, column 52: "+[k.constructor.name,l.constructor.name,
g.constructor.name,h.constructor.name]);}}}}}(m.Nil.value)},L=function(a){var b=function(c){return function(d){if(c instanceof m.Nil)return d;if(c instanceof m.Cons)return function(a){return function(a){return a}}()(function(){if(c.value0 instanceof B&&c.value0.value2 instanceof r&&d instanceof r)return v()(c.value1)(new p(r.value,c.value0.value0,c.value0.value1,r.value));if(c.value0 instanceof q&&c.value0.value0 instanceof r&&d instanceof r)return v()(c.value1)(new p(r.value,c.value0.value1,c.value0.value2,
r.value));if(c.value0 instanceof B&&c.value0.value2 instanceof p)return b(c.value1)(new t(d,c.value0.value0,c.value0.value1,c.value0.value2.value0,c.value0.value2.value1,c.value0.value2.value2,c.value0.value2.value3));if(c.value0 instanceof q&&c.value0.value0 instanceof p)return b(c.value1)(new t(c.value0.value0.value0,c.value0.value0.value1,c.value0.value0.value2,c.value0.value0.value3,c.value0.value1,c.value0.value2,d));if(c.value0 instanceof B&&c.value0.value2 instanceof t)return v()(c.value1)(new p(new p(d,
c.value0.value0,c.value0.value1,c.value0.value2.value0),c.value0.value2.value1,c.value0.value2.value2,new p(c.value0.value2.value3,c.value0.value2.value4,c.value0.value2.value5,c.value0.value2.value6)));if(c.value0 instanceof q&&c.value0.value0 instanceof t)return v()(c.value1)(new p(new p(c.value0.value0.value0,c.value0.value0.value1,c.value0.value0.value2,c.value0.value0.value3),c.value0.value0.value4,c.value0.value0.value5,new p(c.value0.value0.value6,c.value0.value1,c.value0.value2,d)));if(c.value0 instanceof
w&&c.value0.value2 instanceof r&&c.value0.value5 instanceof r&&d instanceof r)return v()(c.value1)(new t(r.value,c.value0.value0,c.value0.value1,r.value,c.value0.value3,c.value0.value4,r.value));if(c.value0 instanceof x&&c.value0.value0 instanceof r&&c.value0.value5 instanceof r&&d instanceof r)return v()(c.value1)(new t(r.value,c.value0.value1,c.value0.value2,r.value,c.value0.value3,c.value0.value4,r.value));if(c.value0 instanceof y&&c.value0.value0 instanceof r&&c.value0.value3 instanceof r&&
d instanceof r)return v()(c.value1)(new t(r.value,c.value0.value1,c.value0.value2,r.value,c.value0.value4,c.value0.value5,r.value));if(c.value0 instanceof w&&c.value0.value2 instanceof p)return v()(c.value1)(new p(new t(d,c.value0.value0,c.value0.value1,c.value0.value2.value0,c.value0.value2.value1,c.value0.value2.value2,c.value0.value2.value3),c.value0.value3,c.value0.value4,c.value0.value5));if(c.value0 instanceof x&&c.value0.value0 instanceof p)return v()(c.value1)(new p(new t(c.value0.value0.value0,
c.value0.value0.value1,c.value0.value0.value2,c.value0.value0.value3,c.value0.value1,c.value0.value2,d),c.value0.value3,c.value0.value4,c.value0.value5));if(c.value0 instanceof x&&c.value0.value5 instanceof p)return v()(c.value1)(new p(c.value0.value0,c.value0.value1,c.value0.value2,new t(d,c.value0.value3,c.value0.value4,c.value0.value5.value0,c.value0.value5.value1,c.value0.value5.value2,c.value0.value5.value3)));if(c.value0 instanceof y&&c.value0.value3 instanceof p)return v()(c.value1)(new p(c.value0.value0,
c.value0.value1,c.value0.value2,new t(c.value0.value3.value0,c.value0.value3.value1,c.value0.value3.value2,c.value0.value3.value3,c.value0.value4,c.value0.value5,d)));if(c.value0 instanceof w&&c.value0.value2 instanceof t)return v()(c.value1)(new t(new p(d,c.value0.value0,c.value0.value1,c.value0.value2.value0),c.value0.value2.value1,c.value0.value2.value2,new p(c.value0.value2.value3,c.value0.value2.value4,c.value0.value2.value5,c.value0.value2.value6),c.value0.value3,c.value0.value4,c.value0.value5));
if(c.value0 instanceof x&&c.value0.value0 instanceof t)return v()(c.value1)(new t(new p(c.value0.value0.value0,c.value0.value0.value1,c.value0.value0.value2,c.value0.value0.value3),c.value0.value0.value4,c.value0.value0.value5,new p(c.value0.value0.value6,c.value0.value1,c.value0.value2,d),c.value0.value3,c.value0.value4,c.value0.value5));if(c.value0 instanceof x&&c.value0.value5 instanceof t)return v()(c.value1)(new t(c.value0.value0,c.value0.value1,c.value0.value2,new p(d,c.value0.value3,c.value0.value4,
c.value0.value5.value0),c.value0.value5.value1,c.value0.value5.value2,new p(c.value0.value5.value3,c.value0.value5.value4,c.value0.value5.value5,c.value0.value5.value6)));if(c.value0 instanceof y&&c.value0.value3 instanceof t)return v()(c.value1)(new t(c.value0.value0,c.value0.value1,c.value0.value2,new p(c.value0.value3.value0,c.value0.value3.value1,c.value0.value3.value2,c.value0.value3.value3),c.value0.value3.value4,c.value0.value3.value5,new p(c.value0.value3.value6,c.value0.value4,c.value0.value5,
d)));throw Error("Failed pattern match at Data.Map line 326, column 9 - line 343, column 136: "+[c.value0.constructor.name,d.constructor.name]);}());throw Error("Failed pattern match at Data.Map line 323, column 5 - line 343, column 136: "+[c.constructor.name]);}},d=function(a){return function(c){return function(a){return function(a){return a}}()(function(){if(c instanceof p&&c.value0 instanceof r&&c.value3 instanceof r)return b(a)(r.value);if(c instanceof p)return d(new m.Cons(new q(c.value0,c.value1,
c.value2),a))(c.value3);if(c instanceof t&&c.value0 instanceof r&&c.value3 instanceof r&&c.value6 instanceof r)return b(new m.Cons(new q(r.value,c.value1,c.value2),a))(r.value);if(c instanceof t)return d(new m.Cons(new y(c.value0,c.value1,c.value2,c.value3,c.value4,c.value5),a))(c.value6);throw Error("Failed pattern match at Data.Map line 355, column 5 - line 359, column 107: "+[c.constructor.name]);}())}},f=function(a){return function(a){return function(a){return a}}()(function(){if(a instanceof
p&&a.value3 instanceof r)return {key:a.value1,value:a.value2};if(a instanceof p)return f(a.value3);if(a instanceof t&&a.value6 instanceof r)return {key:a.value4,value:a.value5};if(a instanceof t)return f(a.value6);throw Error("Failed pattern match at Data.Map line 346, column 33 - line 350, column 45: "+[a.constructor.name]);}())},h=k.compare(a);return function(k){return function(l){return function(g){var D=k,z=l;a:for(;;){if(g instanceof r)return c.Nothing.value;if(g instanceof p){var u=h(z)(g.value1);
if(g.value3 instanceof r&&u instanceof n.EQ)return new c.Just(new e.Tuple(g.value2,b(D)(r.value)));if(u instanceof n.EQ)return z=f(g.value0),new c.Just(new e.Tuple(g.value2,d(new m.Cons(new B(z.key,z.value,g.value3),D))(g.value0)));if(u instanceof n.LT){D=new m.Cons(new B(g.value1,g.value2,g.value3),D);g=g.value0;continue a}D=new m.Cons(new q(g.value0,g.value1,g.value2),D);g=g.value3;continue a}if(g instanceof t){u=g.value0 instanceof r&&g.value3 instanceof r&&g.value6 instanceof r?!0:!1;var E=h(z)(g.value1),
J=h(z)(g.value4);if(u&&E instanceof n.EQ)return new c.Just(new e.Tuple(g.value2,v()(D)(new p(r.value,g.value4,g.value5,r.value))));if(u&&J instanceof n.EQ)return new c.Just(new e.Tuple(g.value5,v()(D)(new p(r.value,g.value1,g.value2,r.value))));if(E instanceof n.EQ)return z=f(g.value0),new c.Just(new e.Tuple(g.value2,d(new m.Cons(new w(z.key,z.value,g.value3,g.value4,g.value5,g.value6),D))(g.value0)));if(J instanceof n.EQ)return z=f(g.value3),new c.Just(new e.Tuple(g.value5,d(new m.Cons(new x(g.value0,
g.value1,g.value2,z.key,z.value,g.value6),D))(g.value3)));if(E instanceof n.LT){D=new m.Cons(new w(g.value1,g.value2,g.value3,g.value4,g.value5,g.value6),D);g=g.value0;continue a}if(E instanceof n.GT&&J instanceof n.LT){D=new m.Cons(new x(g.value0,g.value1,g.value2,g.value4,g.value5,g.value6),D);g=g.value3;continue a}D=new m.Cons(new y(g.value0,g.value1,g.value2,g.value3,g.value4,g.value5),D);g=g.value6;continue a}throw Error("Failed pattern match at Data.Map line 296, column 36 - line 319, column 82: "+
[g.constructor.name]);}}}}(m.Nil.value)},J=r.value,K=function(a){return function(b){return function(d){return c.maybe(d)(e.snd)(L(a)(b)(d))}}},S=function(a){return function(b){return function(d){return function(f){var e=b(F(a)(d)(f));if(e instanceof c.Nothing)return K(a)(d)(f);if(e instanceof c.Just)return H(a)(d)(e.value0)(f);throw Error("Failed pattern match at Data.Map line 364, column 15 - line 366, column 25: "+[e.constructor.name]);}}}};a.alter=S;a.empty=J;a.fromFoldable=function(a){return function(c){return b.foldl(c)(function(b){return function(c){return H(a)(c.value0)(c.value1)(b)}})(J)}};
a.fromFoldableWith=function(a){return function(d){return function(f){var e=function(a){return function(b){if(b instanceof c.Just)return c.Just.create(f(a)(b.value0));if(b instanceof c.Nothing)return new c.Just(a);throw Error("Failed pattern match at Data.Map line 381, column 3 - line 381, column 38: "+[a.constructor.name,b.constructor.name]);}};return b.foldl(d)(function(b){return function(c){return S(a)(e(c.value1))(c.value0)(b)}})(J)}}};a.insert=H;a.keys=G;a.lookup=F;a.pop=L;a.singleton=u;a.toAscUnfoldable=
A;a.toList=E;a.unionWith=function(a){return function(d){return function(f){return function(e){return b.foldl(m.foldableList)(function(b){return function(f){return S(a)(function(a){return c.Just.create(c.maybe(f.value1)(d(f.value1))(a))})(f.value0)(b)}})(e)(E(f))}}}};a.eqMap=function(a){return function(b){return new g.Eq(function(c){return function(d){return g.eq(g.eqArray(e.eqTuple(a)(b)))(z(c))(z(d))}})}};a.functorMap=I;})(PS["Data.Map"]=PS["Data.Map"]||{});
(function(a){var b=PS["Data.Maybe"],c=PS["Data.List"],e=PS["Data.NonEmpty"],d=PS["Data.List.Types"],g=PS["Data.Semigroup"],k=PS["Control.Applicative"],l=PS["Data.Functor"],h=function(a){return new d.Cons(a.value0,a.value1)};a.append=function(a){return function(b){return function(c){return function(d){return new e.NonEmpty(c.value0,g.append(a)(c.value1)(g.append(a)(k.pure(b)(d.value0))(d.value1)))}}}};a.concat=function(a){return new e.NonEmpty(a.value0.value0,g.append(d.semigroupList)(a.value0.value1)(c.concat(l.map(d.functorList)(h)(a.value1))))};
a.fromList=function(a){if(a instanceof d.Cons)return new b.Just(new e.NonEmpty(a.value0,a.value1));if(a instanceof d.Nil)return b.Nothing.value;throw Error("Failed pattern match at Data.NonEmpty.Extra line 42, column 1 - line 42, column 33: "+[a.constructor.name]);};a["fromList'"]=function(a){return function(b){var c=function(a){return function(a){return a}}();if(b instanceof d.Cons)b=new e.NonEmpty(b.value0,b.value1);else throw Error("Failed pattern match at Data.NonEmpty.Extra line 50, column 1 - line 50, column 25: "+
[b.constructor.name]);return c(b)}};a.toList=h;})(PS["Data.NonEmpty.Extra"]=PS["Data.NonEmpty.Extra"]||{});
(function(a){var b=function(){function a(a,b,c,d,e,k){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=e;this.value5=k;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return function(h){return new a(b,c,d,f,e,h)}}}}}};return a}(),c=function(){function a(a,b,c,d,e){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=e;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return new a(b,
c,d,f,e)}}}}};return a}(),e=function(){function a(a,b,c,d){this.value0=a;this.value1=b;this.value2=c;this.value3=d;}a.create=function(b){return function(c){return function(d){return function(f){return new a(b,c,d,f)}}}};return a}(),d=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),g=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,
c)}};return a}();a.Args2=g;a.Args3=d;a.Args4=e;a.Args5=c;a.Args6=b;})(PS["Data.Optimize.Uncurried"]=PS["Data.Optimize.Uncurried"]||{});
(function(a){var b=PS["Data.Foldable"],c=PS["Data.Map"],e=PS["Data.Eq"],d=PS["Data.Ord"],g=PS["Data.Unit"],k=PS["Data.List.Types"],l=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),h=function(a){return function(b){return function(d){return new l(c.insert(a)(b)(g.unit)(d.value0))}}},f=new b.Foldable(function(a){return function(d){return function(f){return b.foldMap(k.foldableList)(a)(d)(c.keys(f.value0))}}},function(a){return function(d){return function(f){return b.foldl(k.foldableList)(a)(d)(c.keys(f.value0))}}},
function(a){return function(d){return function(f){return b.foldr(k.foldableList)(a)(d)(c.keys(f.value0))}}}),m=function(a){return new e.Eq(function(b){return function(d){return e.eq(c.eqMap(a)(e.eqUnit))(b.value0)(d.value0)}})},n=new l(c.empty);a.empty=n;a.fromFoldable=function(a){return function(c){return b.foldl(a)(function(a){return function(b){return h(c)(b)(a)}})(n)}};a.insert=h;a.eqSet=m;a.ordSet=function(a){return new d.Ord(function(){return m(a["__superclass_Data.Eq.Eq_0"]())},function(b){return function(f){return d.compare(k.ordList(a))(c.keys(b.value0))(c.keys(f.value0))}})};
a.foldableSet=f;})(PS["Data.Set"]=PS["Data.Set"]||{});
(function(a){var b=PS["Data.StrMap"],c=PS["Data.Foldable"],e=PS["Data.Functor"],d=PS["Data.List.Types"],g=PS["Data.Monoid"],k=function(a){this.pretty=a;};a.Pretty=k;a.pretty=function(a){return a.pretty};a.prettyStrMap=function(a){return new k(function(h){return c.intercalate(d.foldableList)(g.monoidString)(", ")(e.mapFlipped(d.functorList)(b.toList(h))(function(b){return b.value0+(" \x3d\x3e "+(0, a.pretty)(b.value1))}))})};})(PS["Data.Pretty"]=PS["Data.Pretty"]||{});
(function(a){a.concatImpl=function(a,c){return a+c};})(PS["Data.String.Ext"]=PS["Data.String.Ext"]||{});
(function(a){var b=PS["Data.String.Ext"],c=PS["Data.Function.Uncurried"],e=PS["Data.Maybe"],d=PS["Data.String"],g=PS["Data.Eq"],k=PS["Control.Category"],l=PS["Control.Bind"],h=PS["Control.Applicative"],g=PS["Data.Function"].on(g.eq(g.eqString))(d.toUpper),b=c.runFn2(b.concatImpl);a.concat=b;a.endsWith=function(a){return function(b){return e.maybe(!1)(k.id(k.categoryFn))(l.bind(e.bindMaybe)(d.lastIndexOf(a)(b))(function(c){return h.pure(e.applicativeMaybe)(c===(d.length(b)-d.length(a)|0))}))}};a.upperCaseEq=
g;})(PS["Data.String.Ext"]=PS["Data.String.Ext"]||{});
(function(a){a["regex'"]=function(a){return function(b){return function(c){return function(d){try{return b(new RegExp(c,d))}catch(g){return a(g.message)}}}}};a.test=function(a){return function(b){var c=a.lastIndex;b=a.test(b);a.lastIndex=c;return b}};a._match=function(a){return function(b){return function(c){return function(d){d=d.match(c);if(null==d)return b;for(var e=[],k=0;k<d.length;k++)e.push(null==d[k]?b:a(d[k]));return a(e)}}}};a.replace=function(a){return function(b){return function(c){return c.replace(a,
b)}}};a["replace'"]=function(a){return function(b){return function(c){return c.replace(a,function(a){return b(a)(Array.prototype.splice.call(arguments,1,arguments.length-3))})}}};})(PS["Data.String.Regex"]=PS["Data.String.Regex"]||{});
(function(a){var b=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),c=new b({global:!1,ignoreCase:!1,multiline:!1,sticky:!1,unicode:!1});a.RegexFlags=b;a.noFlags=c;})(PS["Data.String.Regex.Flags"]=PS["Data.String.Regex.Flags"]||{});
(function(a){var b=PS["Data.String.Regex"],c=PS["Data.Either"],e=PS["Data.Maybe"],d=PS["Data.String"],g=PS["Data.String.Regex.Flags"],k=function(a){var b;if(a.value0.global)b="g";else {if(a.value0.global)throw Error("Failed pattern match at Data.String.Regex line 59, column 4 - line 59, column 32: "+[a.value0.global.constructor.name]);b="";}var c;if(a.value0.ignoreCase)c="i";else {if(a.value0.ignoreCase)throw Error("Failed pattern match at Data.String.Regex line 60, column 4 - line 60, column 36: "+
[a.value0.ignoreCase.constructor.name]);c="";}var d;if(a.value0.multiline)d="m";else {if(a.value0.multiline)throw Error("Failed pattern match at Data.String.Regex line 61, column 4 - line 61, column 35: "+[a.value0.multiline.constructor.name]);d="";}var e;if(a.value0.sticky)e="y";else {if(a.value0.sticky)throw Error("Failed pattern match at Data.String.Regex line 62, column 4 - line 62, column 32: "+[a.value0.sticky.constructor.name]);e="";}if(a.value0.unicode)a="u";else {if(a.value0.unicode)throw Error("Failed pattern match at Data.String.Regex line 63, column 4 - line 63, column 33: "+
[a.value0.unicode.constructor.name]);a="";}return b+(c+(d+(e+a)))},e=b._match(e.Just.create)(e.Nothing.value);a.match=e;a.parseFlags=function(a){return new g.RegexFlags({global:d.contains("g")(a),ignoreCase:d.contains("i")(a),multiline:d.contains("m")(a),sticky:d.contains("y")(a),unicode:d.contains("u")(a)})};a.regex=function(a){return function(d){return b["regex'"](c.Left.create)(c.Right.create)(a)(k(d))}};a.renderFlags=k;a.replace=b.replace;a["replace'"]=b["replace'"];a.test=b.test;})(PS["Data.String.Regex"]=
PS["Data.String.Regex"]||{});(function(a){a.getRegex=function(){return ansiRegex()};})(PS["Data.String.Regex.AnsiRegex"]=PS["Data.String.Regex.AnsiRegex"]||{});(function(a){var b=PS["Data.String.Regex.AnsiRegex"].getRegex(PS["Data.Unit"].unit);a.regex=b;})(PS["Data.String.Regex.AnsiRegex"]=PS["Data.String.Regex.AnsiRegex"]||{});
(function(a){var b=PS["Data.String"],c=PS["Data.Semigroup"],e=b.joinWith("\n"),d=b.split("\n"),g=function(a){return c.append(c.semigroupString)(b.singleton(a))},k=function(){return function(a){return function(b){return function(c){var d=a,f=b;for(;;){if(0===f)return d;d=g(c)(d);f=f-1|0;}}}}("")}();a.cons=g;a.lines=d;a.replicate=k;a.unlines=e;})(PS["Data.String.Yarn"]=PS["Data.String.Yarn"]||{});
(function(a){function b(a,b){this.message=a;this.payload=b;Error.call(this);}var c=fs,e=path$1;b.prototype.name="NeodocError";b.prototype=Object.create(Error);a.jsError=function(a){return function(c){return new b(a,c)}};a.readPkgVersionImpl=function(a){return function(b){return function(){if(require.main&&require.main&&require.main.paths)for(var d=0;d<require.main.paths.length;d++){var g=require.main.paths[d].split(e.sep);if("node_modules"===g.pop()&&1<g.length&&(g.push("package.json"),
g=g.join(e.sep),c.existsSync(g)))return a(JSON.parse(c.readFileSync(g)).version)}return b}}};})(PS.Neodoc=PS.Neodoc||{});(function(a){a.process=process;a.exit=function(a){return function(){process.exit(a);}};})(PS["Node.Process"]=PS["Node.Process"]||{});(function(a){a.unsafeCoerce=function(a){return a};})(PS["Unsafe.Coerce"]=PS["Unsafe.Coerce"]||{});(function(a){a.unsafeCoerce=PS["Unsafe.Coerce"].unsafeCoerce;})(PS["Unsafe.Coerce"]=PS["Unsafe.Coerce"]||{});
(function(a){var b=PS["Node.Process"],c=PS["Unsafe.Coerce"].unsafeCoerce,e=c(function(a){return b.process.env}),c=c(function(a){return b.process.argv});a.argv=c;a.getEnv=e;a.exit=b.exit;})(PS["Node.Process"]=PS["Node.Process"]||{});
(function(a){var b=PS["Data.Array"],c=PS["Data.String"],e=PS["Data.Maybe"],d=PS["Control.Category"],g=PS["Data.Ord"],k=PS["Data.Functor"];a.dedent=function(a){a=c.split("\n")(a);var h=function(a){return " "===a||"\n"===a||"\t"===a?!0:!1},f=e.maybe(0)(d.id(d.categoryFn))(b.head(b.sort(g.ordInt)(k.map(k.functorArray)(function(a){return b.length(b.takeWhile(h)(c.toCharArray(a)))})(b.filter(function(a){return 0!==c.length(c.trim(a))})(a)))));return c.joinWith("\n")(k.map(k.functorArray)(c.drop(f))(a))};})(PS["Text.Wrap"]=
PS["Text.Wrap"]||{});
(function(a){var b=PS["Data.Array"],c=PS["Data.String"],e=PS["Data.List"],d=PS["Data.Foreign"],g=PS["Data.Foreign.Class"],k=PS["Data.Foreign.Index"],l=PS["Data.Functor"],h=PS["Control.Bind"],f=PS["Control.Apply"],m=PS["Data.List.Types"],n=PS["Control.Monad.Except.Trans"],r=PS["Data.Identity"],p=PS["Data.Foldable"],t=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),B=function(){function a(a){this.value0=
a;}a.create=function(b){return new a(b)};return a}(),q=function(a){return new g.IsForeign(function(b){return h.bind(n.bindExceptT(r.monadIdentity))(l.map(n.functorExceptT(r.functorIdentity))(c.toUpper)(g.readProp(g.stringIsForeign)(k.indexString)("type")(b)))(function(c){return "ELEM"===c?l.map(n.functorExceptT(r.functorIdentity))(B.create)(g.readProp(a)(k.indexString)("elem")(b)):"GROUP"===c?f.apply(n.applyExceptT(r.monadIdentity))(f.apply(n.applyExceptT(r.monadIdentity))(l.map(n.functorExceptT(r.functorIdentity))(t.create)(g.readProp(g.booleanIsForeign)(k.indexString)("optional")(b)))(g.readProp(g.booleanIsForeign)(k.indexString)("repeatable")(b)))(l.map(n.functorExceptT(r.functorIdentity))(e.fromFoldable(p.foldableArray))(l.map(n.functorExceptT(r.functorIdentity))(function(a){return l.map(l.functorArray)(e.fromFoldable(p.foldableArray))(a)})(g.readProp(g.arrayIsForeign(g.arrayIsForeign(q(a))))(k.indexString)("branches")(b)))):
d.fail(k.errorAt(k.indexString)("type")(d.JSONError.create("unknown type: "+c)))})})},w=function(a){return new g.AsForeign(function(c){if(c instanceof B)return d.toForeign({type:"Elem",elem:g.write(a)(c.value0)});if(c instanceof t)return d.toForeign({type:"Group",optional:g.write(g.booleanAsForeign)(c.value0),repeatable:g.write(g.booleanAsForeign)(c.value1),branches:b.fromFoldable(m.foldableList)(l.map(m.functorList)(function(c){var d=b.fromFoldable(m.foldableList);c=l.map(m.functorList)(g.write(w(a)))(c);
return d(c)})(c.value2))});throw Error("Failed pattern match at Neodoc.Data.EmptyableLayout line 64, column 3 - line 67, column 6: "+[c.constructor.name]);})};a.EmptyableGroup=t;a.EmptyableElem=B;a.isForeignEmptyableLayout=q;a.asForeignEmptyableLayout=w;})(PS["Neodoc.Data.EmptyableLayout"]=PS["Neodoc.Data.EmptyableLayout"]||{});
(function(a){var b=PS["Data.Foldable"],c=PS["Data.NonEmpty"],e=PS["Data.Pretty"],d=PS["Data.Functor"],g=PS["Data.Show"],k=PS["Data.List.Types"],l=PS["Data.Monoid"],h=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),f=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),m=function(a){return new g.Show(function(b){if(b instanceof f)return "Elem "+g.show(a)(b.value0);
if(b instanceof h)return "Group "+(g.show(g.showBoolean)(b.value0)+(" "+(g.show(g.showBoolean)(b.value1)+(" "+g.show(c.showNonEmpty(c.showNonEmpty(m(a))(k.showList(m(a))))(k.showList(c.showNonEmpty(m(a))(k.showList(m(a))))))(b.value2)))));throw Error("Failed pattern match at Neodoc.Data.Layout line 62, column 3 - line 62, column 42: "+[b.constructor.name]);})},n=function(a){return new e.Pretty(function(g){if(g instanceof f)return e.pretty(a)(g.value0);if(g instanceof h){var p=b.intercalate(c.foldableNonEmpty(k.foldableList))(l.monoidString)("|")(d.mapFlipped(c.functorNonEmpty(k.functorList))(g.value2)(function(f){return b.intercalate(c.foldableNonEmpty(k.foldableList))(l.monoidString)(" ")(d.map(c.functorNonEmpty(k.functorList))(e.pretty(n(a)))(f))})),
m;if(g.value0)m="[";else {if(g.value0)throw Error("Failed pattern match at Neodoc.Data.Layout line 56, column 10 - line 56, column 32: "+[g.value0.constructor.name]);m="(";}var t;if(g.value0)t="]";else {if(g.value0)throw Error("Failed pattern match at Neodoc.Data.Layout line 58, column 11 - line 58, column 33: "+[g.value0.constructor.name]);t=")";}if(g.value1)g="...";else {if(g.value1)throw Error("Failed pattern match at Neodoc.Data.Layout line 59, column 11 - line 59, column 34: "+[g.value1.constructor.name]);
g="";}return m+(p+(t+g))}throw Error("Failed pattern match at Neodoc.Data.Layout line 53, column 3 - line 53, column 30: "+[g.constructor.name]);})},r=new d.Functor(function(a){return function(b){if(b instanceof h)return h.create(b.value0)(b.value1)(d.map(c.functorNonEmpty(k.functorList))(function(b){return d.map(c.functorNonEmpty(k.functorList))(function(b){return d.map(r)(a)(b)})(b)})(b.value2));if(b instanceof f)return new f(a(b.value0));throw Error("Failed pattern match at Neodoc.Data.Layout line 49, column 3 - line 49, column 62: "+
[a.constructor.name,b.constructor.name]);}});a.Group=h;a.Elem=f;a.functorLayout=r;a.prettyLayout=n;a.showLayout=m;})(PS["Neodoc.Data.Layout"]=PS["Neodoc.Data.Layout"]||{});
(function(a){var b=PS["Data.Foldable"],c=PS["Data.String"],e=PS["Data.Newtype"],d=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),g=c.split(e.wrap(c.newtypePattern)("")),c=new d(1,1),k=function(a){return function(b){return "\n"===b||"\r"===b?new d(a.value0+1|0,1):"\t"===b?new d(a.value0,(a.value1+8|0)-(a.value1-1|0)%8|0):new d(a.value0,a.value1+1|0)}};a.Position=d;a._updatePosChar=k;a.initialPos=c;a.split=g;a.updatePosString=
function(a){return function(c){return b.foldl(b.foldableArray)(k)(a)(g(c))}};})(PS["Neodoc.Parsing.Parser.Pos"]=PS["Neodoc.Parsing.Parser.Pos"]||{});
(function(a){var b=PS["Control.Lazy"],c=PS["Control.Plus"],e=PS["Data.Either"],d=PS["Control.Apply"],g=PS["Control.Monad"],k=PS["Control.Applicative"],l=PS["Data.Functor"],h=PS["Control.Bind"],f=PS["Data.Function"],m=PS["Control.Alt"],n=PS["Control.Alternative"],r=PS["Data.Unit"],p=PS["Control.MonadZero"],t=function(){function a(a,b,c,d){this.value0=a;this.value1=b;this.value2=c;this.value3=d;}a.create=function(b){return function(c){return function(d){return function(f){return new a(b,c,d,f)}}}};return a}(),
B=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),q=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),w=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),x=function(a){return function(b){return new q(a||b.value0,b.value1,b.value2)}},y=function(a){return new w(function(b){return new q(!1,
b,new e.Right(a))})},C=function(a){return function(b){return new t(b.value0,a(b.value1),b.value2,b.value3)}},u=function(a){return function(b){return new t(b.value0,b.value1,b.value2,a(b.value3))}},A=function(a){return function(b){return new t(b.value0,b.value1,a(b.value2),b.value3)}},b=new b.Lazy(function(a){return new w(function(b){return (0, a(r.unit).value0)(b)})}),z=new w(function(a){return new q(!1,a,new e.Right(a.value1))}),E=new w(function(a){return new q(!1,a,new e.Right(a))}),F=new w(function(a){return new q(!1,
a,new e.Right(a.value3))}),G=new w(function(a){return new q(!1,a,new e.Right(a.value2))}),I=new w(function(a){return new q(!1,a,new e.Right(a.value0))}),v=new l.Functor(function(a){return function(b){return new w(function(c){c=(0, b.value0)(c);return new q(c.value0,c.value1,l.map(e.functorEither)(a)(c.value2))})}}),H=function(a){return new w(function(b){return new q(!1,b,e.Left.create(new B(!1,new e.Left(a))))})},L=function(a){return function(b){return new w(function(c){var d=(0, a.value0)(c);return d.value2 instanceof
e.Left&&!d.value2.value0.value0&&!d.value0?(0, b(d.value1.value1)(d.value2.value0).value0)(new t(c.value0,c.value1,d.value1.value2,c.value3)):d})}},J=new g.Monad(function(){return R},function(){return K}),K=new h.Bind(function(){return S},function(a){return function(b){return new w(function(c){c=(0, a.value0)(c);if(c.value2 instanceof e.Left)return new q(c.value0,c.value1,new e.Left(c.value2.value0));if(c.value2 instanceof e.Right)return x(c.value0)((0, b(c.value2.value0).value0)(c.value1));throw Error("Failed pattern match at Neodoc.Parsing.Parser line 111, column 30 - line 113, column 67: "+
[c.constructor.name]);})}}),S=new d.Apply(function(){return v},g.ap(J)),R=new k.Applicative(function(){return S},y),P=new m.Alt(function(){return v},function(a){return function(b){return L(a)(function(a){return function(a){return b}})}}),N=new c.Plus(function(){return P},H("No alternative")),O=new n.Alternative(function(){return R},function(){return N}),c=new p.MonadZero(function(){return O},function(){return J});a.ParseError=B;a.Parser=w;a.ParseArgs=t;a.Step=q;a["catch"]=L;a.error=function(a){return new B(!1,
new e.Left(a))};a.extractError=function(a){return function(b){if(b.value1 instanceof e.Left)return a(b.value1.value0);if(b.value1 instanceof e.Right)return b.value1.value0;throw Error("Failed pattern match at Neodoc.Parsing.Parser line 36, column 1 - line 36, column 46: "+[a.constructor.name,b.constructor.name]);}};a.fail=H;a["fail'"]=function(a){return new w(function(b){return new q(!1,b,e.Left.create(new B(!1,new e.Right(a))))})};a.fatal=function(a){return new w(function(b){return new q(!1,b,e.Left.create(new B(!0,
new e.Left(a))))})};a["fatal'"]=function(a){return new w(function(b){return new q(!1,b,e.Left.create(new B(!0,new e.Right(a))))})};a.getC=function(a){return a.value0};a.getConfig=I;a.getG=function(a){return a.value2};a.getGlobalState=G;a.getI=function(a){return a.value3};a.getInput=F;a.getParseState=E;a.getS=function(a){return a.value1};a.getState=z;a.mapG=A;a.mapI=u;a.mapS=C;a.modifyGlobalState=function(a){return new w(function(b){return new q(!1,A(a)(b),new e.Right(r.unit))})};a.modifyState=function(a){return new w(function(b){return new q(!1,
C(a)(b),new e.Right(r.unit))})};a["return"]=y;a.runParser=function(a){return (0, a.value4.value0)(new t(a.value0,a.value1,a.value2,a.value3)).value2};a.setConsumedOr=x;a.setG=function(a){return A(f["const"](a))};a.setI=function(a){return u(f["const"](a))};a.setInput=function(a){return new w(function(b){return new q(!1,u(f["const"](a))(b),new e.Right(r.unit))})};a["throw"]=function(a){return new w(function(b){return new q(!1,b,new e.Left(a))})};a.unParser=function(a){return a.value0};a.applyParser=S;
a.applicativeParser=R;a.functorParser=v;a.bindParser=K;a.monadParser=J;a.altParser=P;a.plusParser=N;a.alternativeParser=O;a.lazyParser=b;a.monadZeroParser=c;})(PS["Neodoc.Parsing.Parser"]=PS["Neodoc.Parsing.Parser"]||{});(function(a){a.getFirst=function(a){return a.slice(0,1)};a.getRest=function(a){return a.slice(1)};})(PS["Neodoc.Parsing.Parser.String"]=PS["Neodoc.Parsing.Parser.String"]||{});
(function(a){var b=PS["Data.Foldable"],c=PS["Data.Maybe"],e=PS["Data.String.Ext"],d=PS["Data.List"],g=PS["Control.Alt"],k=PS["Control.Plus"],l=PS["Data.Either"],h=PS["Unsafe.Coerce"],f=PS["Neodoc.Parsing.Parser"],m=PS["Data.Functor"],n=PS["Data.Unit"],r=PS["Control.Bind"],p=PS["Data.List.Types"],t=PS["Control.Apply"],B=function(a){return function(b){return g.alt(f.altParser)(a)(f.fail("Expected "+b))}},q=function(a){return new f.Parser(function(b){var c=f.unParser(a)(b);return c.value2 instanceof
l.Left?new f.Step(!1,f.setG(f.getG(c.value1))(b),c.value2):c})},w=function(a){return function(b){return g.alt(f.altParser)(b)(f["return"](a))}},x=function(a){var b=function(d){return r.bind(f.bindParser)(w(c.Nothing.value)(m.map(f.functorParser)(c.Just.create)(a)))(function(a){if(a instanceof c.Nothing)return f["return"](d);if(a instanceof c.Just)return b(new p.Cons(a.value0,d));throw Error("Failed pattern match at Neodoc.Parsing.Parser.Combinators line 104, column 11 - line 106, column 34: "+[a.constructor.name]);
})};return m.map(f.functorParser)(d.reverse)(b(p.Nil.value))},y=PS["Data.Function"].flip(B);a.asErrorMessage=y;a.between=function(a){return function(b){return function(c){return t.applyFirst(f.applyParser)(t.applySecond(f.applyParser)(a)(c))(b)}}};a.choice=function(a){return b.foldl(a)(g.alt(f.altParser))(k.empty(f.plusParser))};a.lookAhead=function(a){return new f.Parser(function(b){var c=f.unParser(a)(b);return new f.Step(!1,b,c.value2)})};a.many=x;a.manyChar=function(a){var b=function(d){return r.bind(f.bindParser)(w(c.Nothing.value)(m.map(f.functorParser)(c.Just.create)(a)))(function(a){if(a instanceof
c.Nothing)return f["return"](d);if(a instanceof c.Just)return b(e.concat(d)(h.unsafeCoerce(a.value0)));throw Error("Failed pattern match at Neodoc.Parsing.Parser.Combinators line 113, column 11 - line 115, column 61: "+[a.constructor.name]);})};return b("")};a.manyTill=function(a){return function(b){var c=function(d){return g.alt(f.altParser)(t.applySecond(f.applyParser)(b)(f["return"](d)))(r.bind(f.bindParser)(a)(function(a){return c(new p.Cons(a,d))}))};return c(p.Nil.value)}};a.notFollowedBy=function(a){return q(g.alt(f.altParser)(t.applySecond(f.applyParser)(q(a))(f.fail("Negated parser succeeded")))(f["return"](n.unit)))};
a.option=w;a.optionMaybe=function(a){return w(c.Nothing.value)(m.map(f.functorParser)(c.Just.create)(a))};a.optional=function(a){return g.alt(f.altParser)(m["void"](f.functorParser)(a))(f["return"](n.unit))};a.sepBy1=function(a){return function(b){return r.bind(f.bindParser)(a)(function(c){return r.bind(f.bindParser)(x(t.applySecond(f.applyParser)(b)(a)))(function(a){return f["return"](new p.Cons(c,a))})})}};a.some=function(a){var b=function(d){return r.bind(f.bindParser)(w(c.Nothing.value)(m.map(f.functorParser)(c.Just.create)(a)))(function(a){if(a instanceof
c.Nothing)return f["return"](d);if(a instanceof c.Just)return b(new p.Cons(a.value0,d));throw Error("Failed pattern match at Neodoc.Parsing.Parser.Combinators line 123, column 11 - line 125, column 34: "+[a.constructor.name]);})};return m.map(f.functorParser)(d.reverse)(r.bind(f.bindParser)(a)(function(a){return b(new p.Cons(a,p.Nil.value))}))};a.someChar=function(a){var b=function(d){return r.bind(f.bindParser)(w(c.Nothing.value)(m.map(f.functorParser)(c.Just.create)(a)))(function(a){if(a instanceof
c.Nothing)return f["return"](d);if(a instanceof c.Just)return b(e.concat(d)(h.unsafeCoerce(a.value0)));throw Error("Failed pattern match at Neodoc.Parsing.Parser.Combinators line 134, column 11 - line 136, column 60: "+[a.constructor.name]);})};return r.bind(f.bindParser)(a)(function(a){return b(h.unsafeCoerce(a))})};a["try"]=q;a.withErrorMessage=B;})(PS["Neodoc.Parsing.Parser.Combinators"]=PS["Neodoc.Parsing.Parser.Combinators"]||{});
(function(a){var b=PS["Neodoc.Parsing.Parser.String"],c=PS["Control.Alt"],e=PS["Data.String"],d=PS["Data.Char"],g=PS["Data.List"],k=PS["Data.Array"],l=PS["Data.Newtype"],h=PS["Data.Maybe"],f=PS["Data.Either"],m=PS["Neodoc.Parsing.Parser"],n=PS["Neodoc.Parsing.Parser.Combinators"],r=PS["Neodoc.Parsing.Parser.Pos"],p=PS["Data.Show"],t=PS["Control.Bind"],B=PS["Control.Applicative"],q=PS["Data.Eq"],w=PS["Data.Functor"],x=function(a){return new m.Parser(function(b){var c=e.indexOf(l.wrap(e.newtypePattern)(a))(b.value3);
if(c instanceof h.Just&&0===c.value0){var c=r.updatePosString(b.value1)(a),d=e.drop(e.length(a))(b.value3);return new m.Step(!0,new m.ParseArgs(b.value0,c,b.value2,d),new f.Right(a))}return new m.Step(!1,b,new f.Left(m.error("Expected "+p.show(p.showString)(a))))})},y=function(a){return 64<a&&91>a},C=function(a){return 96<a&&123>a},u=function(a){return 47<a&&58>a},A=m.getState,z=t.bind(m.bindParser)(m.getInput)(function(a){return B.unless(m.applicativeParser)(e["null"](a))(m.fail("Expected EOF"))}),
E=new m.Parser(function(a){if(""===a.value3)return new m.Step(!1,a,new f.Left(m.error("Unexpected EOF")));var c=b.getRest(a.value3),d=b.getFirst(a.value3),h=r.updatePosString(a.value1)(e.singleton(d));return new m.Step(!0,new m.ParseArgs(a.value0,h,a.value2,c),new f.Right(d))}),F=function(a){return n["try"](t.bind(m.bindParser)(E)(function(b){var c=a(b);if(c)return m["return"](b);if(!c)return m.fail("Character '"+(e.singleton(b)+"' did not satisfy predicate"));throw Error("Failed pattern match at Neodoc.Parsing.Parser.String line 29, column 3 - line 32, column 1: "+
[c.constructor.name]);}))},G=function(a){return n.withErrorMessage(F(function(b){return b===a}))("Expected "+p.show(p.showChar)(a))},c=c.alt(m.altParser)(w["void"](m.functorParser)(x("\r\n")))(w["void"](m.functorParser)(G("\n"))),w=function(a){return F(function(b){return a(d.toCharCode(b))})},I=w(function(a){return 47<a&&58>a}),v=F(function(a){return " "===a||"\t"===a}),g=g.many(m.alternativeParser)(m.lazyParser)(v),H=w(function(a){return y(a)||C(a)||u(a)});a.alphaNum=H;a.anyChar=E;a["char"]=G;a.digit=
I;a.eof=z;a.eol=c;a.getPosition=A;a.isDigit=u;a.isLowerAlpha=C;a.isUpperAlpha=y;a.noneOf=function(a){return n.withErrorMessage(F(function(b){return h.isNothing(k.elemIndex(q.eqChar)(b)(a))}))("Expected none of "+p.show(p.showArray(p.showChar))(a))};a.oneOf=function(a){return n.withErrorMessage(F(function(b){return h.isJust(k.elemIndex(q.eqChar)(b)(a))}))("Expected one of "+p.show(p.showArray(p.showChar))(a))};a.satisfy=F;a.satisfyCode=w;a.space=v;a.spaces=g;a.string=x;})(PS["Neodoc.Parsing.Parser.String"]=
PS["Neodoc.Parsing.Parser.String"]||{});
(function(a){var b=PS.Global,c=PS["Data.Generic"],e=PS["Data.Optimize.Uncurried"],d=PS["Data.Int"],g=PS["Data.Bifunctor"],k=PS["Data.Either"],l=PS["Data.Maybe"],h=PS["Data.List"],f=PS["Data.Foldable"],m=PS["Data.Traversable"],n=PS["Control.Apply"],r=PS["Control.Alt"],p=PS["Data.String"],t=PS["Data.Pretty"],B=PS["Data.Foreign"],q=PS["Data.Foreign.Class"],w=PS["Neodoc.Parsing.Parser.Pos"],x=PS["Neodoc.Parsing.Parser"],y=PS["Neodoc.Parsing.Parser.String"],C=PS["Neodoc.Parsing.Parser.Combinators"],u=
PS["Data.Eq"],A=PS["Data.Ord"],z=PS["Data.Ordering"],E=PS["Data.Unit"],F=PS["Data.Show"],G=PS["Data.Functor"],I=PS["Control.Bind"],v=PS["Data.Function"],H=PS["Control.Applicative"],L=PS["Data.List.Types"],J=PS["Data.Monoid"],K=PS["Data.Unfoldable"],S=PS["Control.Category"],R=PS["Control.Monad.Except.Trans"],P=PS["Data.Identity"],N=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),O=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};
return a}(),D=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),M=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),U=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),X=y.satisfy(function(a){return "\n"===a||"\r"===a||" "===a||"\t"===a}),T=function(){var a=r.alt(x.altParser)(I.bind(x.bindParser)(X)(function(){return a}))(H.pure(x.applicativeParser)(E.unit));return a}(),ca=n.applySecond(x.applyParser)(X)(T),
da=function(a){if(a instanceof N)return a.value0;if(a instanceof O)return F.show(F.showBoolean)(a.value0);if(a instanceof D)return F.show(F.showArray(F.showString))(G.map(G.functorArray)(da)(a.value0));if(a instanceof M)return F.show(F.showInt)(a.value0);if(a instanceof U)return F.show(F.showNumber)(a.value0);throw Error("Failed pattern match at Neodoc.Value line 196, column 1 - line 196, column 37: "+[a.constructor.name]);},t=new t.Pretty(da),Q=function(a){return function(c){var m=G.map(x.functorParser)(N.create)(G.map(x.functorParser)(f.foldMap(L.foldableList)(J.monoidString)(p.singleton))(C.choice(f.foldableArray)([C.between(y["char"]('"'))(y["char"]('"'))(C.many(y.noneOf(['"']))),
C.between(y["char"]("'"))(y["char"]("'"))(C.many(y.noneOf(["'"])))]))),q=I.bind(x.bindParser)(C.option(1)(n.applySecond(x.applyParser)(y["char"]("-"))(H.pure(x.applicativeParser)(-1))))(function(a){return I.bind(x.bindParser)(G.map(x.functorParser)(f.foldMap(L.foldableList)(J.monoidString)(p.singleton))(C.some(y.digit)))(function(c){return C.choice(f.foldableArray)([G.map(x.functorParser)(function(c){return U.create(function(b){return d.toNumber(a)*b}(b.readFloat(c)))})(I.bind(x.bindParser)(I.bind(x.bindParser)(y["char"]("."))(function(){return G.map(x.functorParser)(f.foldMap(L.foldableList)(J.monoidString)(p.singleton))(C.some(y.digit))}))(function(a){return H.pure(x.applicativeParser)(c+
("."+a))})),function(){var b=d.fromString(c);if(b instanceof l.Just)return H.pure(x.applicativeParser)(M.create(a*b.value0|0));if(b instanceof l.Nothing)return x.fail("Value not a valid Int");throw Error("Failed pattern match at Neodoc.Value line 258, column 9 - line 263, column 7: "+[b.constructor.name]);}()])})}),t=function(){var a=I.bind(x.bindParser)(C.choice(f.foldableArray)(G.map(G.functorArray)(function(a){return C["try"](y.string(a))})(["true","True","TRUE"])))(function(){return H.pure(x.applicativeParser)(new O(!0))}),
b=I.bind(x.bindParser)(C.choice(f.foldableArray)(G.map(G.functorArray)(function(a){return C["try"](y.string(a))})(["false","False","FALSE"])))(function(){return H.pure(x.applicativeParser)(new O(!1))});return r.alt(x.altParser)(a)(b)}(),m=C.choice(f.foldableArray)(G.map(G.functorArray)(C["try"])([t,q,m])),q=r.alt(x.altParser)(C["try"](m))(G.map(x.functorParser)(N.create)(G.map(x.functorParser)(f.foldMap(L.foldableList)(J.monoidString)(p.singleton))(C.many(C["try"](y.noneOf([","," ","\n"])))))),q=
I.bind(x.bindParser)(C.sepBy1(q)(C.choice(f.foldableArray)([C["try"](n.applySecond(x.applyParser)(n.applySecond(x.applyParser)(T)(y["char"](",")))(T)),ca])))(function(a){var b=H.pure(x.applicativeParser);a=a instanceof L.Cons&&a.value1 instanceof L.Nil?a.value0:new D(h.toUnfoldable(K.unfoldableArray)(a));return b(a)});if(c)c=q;else {if(c)throw Error("Failed pattern match at Neodoc.Value line 226, column 11 - line 226, column 51: "+[c.constructor.name]);c=n.applyFirst(x.applyParser)(m)(y.eof);}return g.lmap(k.bifunctorEither)(x.extractError(S.id(S.categoryFn)))(x.runParser(new e.Args5(E.unit,
w.initialPos,E.unit,a,c)))}},Y=new q.IsForeign(function(a){return r.alt(R.altExceptT(L.semigroupNonEmptyList)(P.monadIdentity))(r.alt(R.altExceptT(L.semigroupNonEmptyList)(P.monadIdentity))(r.alt(R.altExceptT(L.semigroupNonEmptyList)(P.monadIdentity))(r.alt(R.altExceptT(L.semigroupNonEmptyList)(P.monadIdentity))(r.alt(R.altExceptT(L.semigroupNonEmptyList)(P.monadIdentity))(G.map(R.functorExceptT(P.functorIdentity))(O.create)(B.readBoolean(a)))(G.map(R.functorExceptT(P.functorIdentity))(M.create)(B.readInt(a))))(G.map(R.functorExceptT(P.functorIdentity))(U.create)(B.readNumber(a))))(G.map(R.functorExceptT(P.functorIdentity))(N.create)(B.readString(a))))(G.map(R.functorExceptT(P.functorIdentity))(D.create)(I.bind(R.bindExceptT(P.monadIdentity))(B.readArray(a))(function(a){return m["for"](R.applicativeExceptT(P.monadIdentity))(m.traversableArray)(a)(q.read(Y))}))))(B.fail(new B.JSONError("Invalid value")))}),
W=new c.Generic(function(a){return a instanceof c.SProd&&"Neodoc.Value.StringValue"===a.value0&&1===a.value1.length?n.apply(l.applyMaybe)(new l.Just(N.create))(c.fromSpine(c.genericString)(a.value1[0](E.unit))):a instanceof c.SProd&&"Neodoc.Value.BoolValue"===a.value0&&1===a.value1.length?n.apply(l.applyMaybe)(new l.Just(O.create))(c.fromSpine(c.genericBool)(a.value1[0](E.unit))):a instanceof c.SProd&&"Neodoc.Value.ArrayValue"===a.value0&&1===a.value1.length?n.apply(l.applyMaybe)(new l.Just(D.create))(c.fromSpine(c.genericArray(W))(a.value1[0](E.unit))):
a instanceof c.SProd&&"Neodoc.Value.IntValue"===a.value0&&1===a.value1.length?n.apply(l.applyMaybe)(new l.Just(M.create))(c.fromSpine(c.genericInt)(a.value1[0](E.unit))):a instanceof c.SProd&&"Neodoc.Value.FloatValue"===a.value0&&1===a.value1.length?n.apply(l.applyMaybe)(new l.Just(U.create))(c.fromSpine(c.genericNumber)(a.value1[0](E.unit))):l.Nothing.value},function(a){return new c.SigProd("Neodoc.Value.Value",[{sigConstructor:"Neodoc.Value.StringValue",sigValues:[function(a){return c.toSignature(c.genericString)(c.anyProxy)}]},
{sigConstructor:"Neodoc.Value.BoolValue",sigValues:[function(a){return c.toSignature(c.genericBool)(c.anyProxy)}]},{sigConstructor:"Neodoc.Value.ArrayValue",sigValues:[function(a){return c.toSignature(c.genericArray(W))(c.anyProxy)}]},{sigConstructor:"Neodoc.Value.IntValue",sigValues:[function(a){return c.toSignature(c.genericInt)(c.anyProxy)}]},{sigConstructor:"Neodoc.Value.FloatValue",sigValues:[function(a){return c.toSignature(c.genericNumber)(c.anyProxy)}]}])},function(a){if(a instanceof N)return new c.SProd("Neodoc.Value.StringValue",
[function(b){return c.toSpine(c.genericString)(a.value0)}]);if(a instanceof O)return new c.SProd("Neodoc.Value.BoolValue",[function(b){return c.toSpine(c.genericBool)(a.value0)}]);if(a instanceof D)return new c.SProd("Neodoc.Value.ArrayValue",[function(b){return c.toSpine(c.genericArray(W))(a.value0)}]);if(a instanceof M)return new c.SProd("Neodoc.Value.IntValue",[function(b){return c.toSpine(c.genericInt)(a.value0)}]);if(a instanceof U)return new c.SProd("Neodoc.Value.FloatValue",[function(b){return c.toSpine(c.genericNumber)(a.value0)}]);
throw Error("Failed pattern match: "+[a.constructor.name]);}),Z=new F.Show(c.gShow(W)),ea=new u.Eq(function(a){return function(b){return a instanceof N&&b instanceof N||a instanceof O&&b instanceof O?a.value0===b.value0:a instanceof D&&b instanceof D?u.eq(u.eqArray(ea))(a.value0)(b.value0):a instanceof M&&b instanceof M||a instanceof U&&b instanceof U?a.value0===b.value0:!1}}),V=new A.Ord(function(){return ea},function(a){return function(b){if(a instanceof N&&b instanceof N)return A.compare(A.ordString)(a.value0)(b.value0);
if(a instanceof N)return z.LT.value;if(b instanceof N)return z.GT.value;if(a instanceof O&&b instanceof O)return A.compare(A.ordBoolean)(a.value0)(b.value0);if(a instanceof O)return z.LT.value;if(b instanceof O)return z.GT.value;if(a instanceof D&&b instanceof D)return A.compare(A.ordArray(V))(a.value0)(b.value0);if(a instanceof D)return z.LT.value;if(b instanceof D)return z.GT.value;if(a instanceof M&&b instanceof M)return A.compare(A.ordInt)(a.value0)(b.value0);if(a instanceof M)return z.LT.value;
if(b instanceof M)return z.GT.value;if(a instanceof U&&b instanceof U)return A.compare(A.ordNumber)(a.value0)(b.value0);throw Error("Failed pattern match: "+[a.constructor.name,b.constructor.name]);}}),aa=new q.AsForeign(function(a){if(a instanceof O||a instanceof M||a instanceof U||a instanceof N)return B.toForeign(a.value0);if(a instanceof D)return B.toForeign(G.map(G.functorArray)(q.write(aa))(a.value0));throw Error("Failed pattern match at Neodoc.Value line 79, column 3 - line 79, column 41: "+
[a.constructor.name]);});a.StringValue=N;a.BoolValue=O;a.ArrayValue=D;a.IntValue=M;a.FloatValue=U;a.intoArray=function(a){return a instanceof D?a.value0:[a]};a.isBoolValue=function(a){return a instanceof O?!0:!1};a.parse=Q;a.prettyPrintValue=da;a.read=function(a){return function(b){return k.either(v["const"](new N(a)))(S.id(S.categoryFn))(Q(a)(b))}};a.eqValue=ea;a.ordValue=V;a.genericValue=W;a.showValue=Z;a.isForeignValue=Y;a.asForeignValue=aa;a.prettyValue=t;})(PS["Neodoc.Value"]=PS["Neodoc.Value"]||
{});
(function(a){var b=PS["Data.String"],c=PS["Data.Maybe"],e=PS["Data.Either"],d=PS["Data.Generic"],g=PS["Data.Pretty"],k=PS["Data.Foreign"],l=PS["Data.Foreign.Class"],h=PS["Data.Eq"],f=PS["Data.Ord"],m=PS["Data.Ordering"],n=PS["Control.Apply"],r=PS["Data.Unit"],p=PS["Control.Bind"],t=PS["Control.Applicative"],B=PS["Control.Monad.Except.Trans"],q=PS["Data.Identity"],w=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),x=function(){function a(a){this.value0=a;}a.create=
function(b){return new a(b)};return a}(),g=new g.Pretty(function(a){if(a instanceof w)return "-"+b.singleton(a.value0);if(a instanceof x)return "--"+a.value0;throw Error("Failed pattern match at Neodoc.OptionAlias line 64, column 3 - line 64, column 50: "+[a.constructor.name]);}),y=new d.Generic(function(a){return a instanceof d.SProd&&"Neodoc.OptionAlias.Short"===a.value0&&1===a.value1.length?n.apply(c.applyMaybe)(new c.Just(w.create))(d.fromSpine(d.genericChar)(a.value1[0](r.unit))):a instanceof d.SProd&&
"Neodoc.OptionAlias.Long"===a.value0&&1===a.value1.length?n.apply(c.applyMaybe)(new c.Just(x.create))(d.fromSpine(d.genericString)(a.value1[0](r.unit))):c.Nothing.value},function(a){return new d.SigProd("Neodoc.OptionAlias.OptionAlias",[{sigConstructor:"Neodoc.OptionAlias.Short",sigValues:[function(a){return d.toSignature(d.genericChar)(d.anyProxy)}]},{sigConstructor:"Neodoc.OptionAlias.Long",sigValues:[function(a){return d.toSignature(d.genericString)(d.anyProxy)}]}])},function(a){if(a instanceof
w)return new d.SProd("Neodoc.OptionAlias.Short",[function(b){return d.toSpine(d.genericChar)(a.value0)}]);if(a instanceof x)return new d.SProd("Neodoc.OptionAlias.Long",[function(b){return d.toSpine(d.genericString)(a.value0)}]);throw Error("Failed pattern match at Neodoc.OptionAlias line 35, column 1 - line 35, column 58: "+[a.constructor.name]);}),C=function(a){a=b.uncons(a);return a instanceof c.Just&&"-"===a.value0.head?(a=b.uncons(a.value0.tail),a instanceof c.Just&&"-"===a.value0.head&&""===
a.value0.tail?new e.Left("long option must have a name"):a instanceof c.Just&&"-"===a.value0.head?t.pure(e.applicativeEither)(new x(a.value0.tail)):a instanceof c.Just&&""===a.value0.tail?t.pure(e.applicativeEither)(new w(a.value0.head)):new e.Left("short option must have a singe char")):a instanceof c.Nothing?new e.Left("option may not be empty"):new e.Left("option must start with a dash")},u=new l.IsForeign(function(a){return p.bind(B.bindExceptT(q.monadIdentity))(l.read(l.stringIsForeign)(a))(function(a){a=
C(a);if(a instanceof e.Left)return k.fail(new k.JSONError(a.value0));if(a instanceof e.Right)return t.pure(B.applicativeExceptT(q.monadIdentity))(a.value0);throw Error("Failed pattern match at Neodoc.OptionAlias line 43, column 5 - line 45, column 26: "+[a.constructor.name]);})}),A=new h.Eq(function(a){return function(b){return a instanceof w&&b instanceof w||a instanceof x&&b instanceof x?a.value0===b.value0:!1}}),h=new f.Ord(function(){return A},function(a){return function(b){if(a instanceof w&&
b instanceof w)return f.compare(f.ordChar)(a.value0)(b.value0);if(a instanceof w)return m.LT.value;if(b instanceof w)return m.GT.value;if(a instanceof x&&b instanceof x)return f.compare(f.ordString)(a.value0)(b.value0);throw Error("Failed pattern match at Neodoc.OptionAlias line 34, column 1 - line 34, column 50: "+[a.constructor.name,b.constructor.name]);}}),z=new l.AsForeign(function(a){if(a instanceof w)return k.toForeign("-"+b.singleton(a.value0));if(a instanceof x)return k.toForeign("--"+a.value0);
throw Error("Failed pattern match at Neodoc.OptionAlias line 60, column 3 - line 60, column 63: "+[a.constructor.name]);});a.Short=w;a.Long=x;a.fromString=C;a.isLong=function(a){return a instanceof x?!0:!1};a.eqOptionAlias=A;a.ordOptionAlias=h;a.genericOptionAlias=y;a.isForeignOptionAlias=u;a.asForeignOptionAlias=z;a.prettyOptionAlias=g;})(PS["Neodoc.OptionAlias"]=PS["Neodoc.OptionAlias"]||{});
(function(a){var b=PS["Data.Generic"],c=PS["Data.Pretty"],e=PS["Data.Maybe"],d=PS["Data.Foreign"],g=PS["Data.Foreign.Class"],k=PS["Data.Foreign.Index"],l=PS["Control.Apply"],h=PS["Data.Unit"],f=PS["Data.Functor"],m=PS["Control.Monad.Except.Trans"],n=PS["Data.Identity"],r=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),c=new c.Pretty(function(a){var b;if(a.value1)b="[";else {if(a.value1)throw Error("Failed pattern match at Neodoc.Data.OptionArgument line 42, column 8 - line 42, column 29: "+
[a.value1.constructor.name]);b="";}var c=a.value0;if(a.value1)a="]";else {if(a.value1)throw Error("Failed pattern match at Neodoc.Data.OptionArgument line 42, column 40 - line 42, column 61: "+[a.value1.constructor.name]);a="";}return b+(c+a)}),p=new g.IsForeign(function(a){return l.apply(m.applyExceptT(n.monadIdentity))(f.map(m.functorExceptT(n.functorIdentity))(r.create)(g.readProp(g.stringIsForeign)(k.indexString)("name")(a)))(g.readProp(g.booleanIsForeign)(k.indexString)("optional")(a))}),t=new b.Generic(function(a){return a instanceof
b.SProd&&"Neodoc.Data.OptionArgument.OptionArgument"===a.value0&&2===a.value1.length?l.apply(e.applyMaybe)(l.apply(e.applyMaybe)(new e.Just(r.create))(b.fromSpine(b.genericString)(a.value1[0](h.unit))))(b.fromSpine(b.genericBool)(a.value1[1](h.unit))):e.Nothing.value},function(a){return new b.SigProd("Neodoc.Data.OptionArgument.OptionArgument",[{sigConstructor:"Neodoc.Data.OptionArgument.OptionArgument",sigValues:[function(a){return b.toSignature(b.genericString)(b.anyProxy)},function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]}])},
function(a){return new b.SProd("Neodoc.Data.OptionArgument.OptionArgument",[function(c){return b.toSpine(b.genericString)(a.value0)},function(c){return b.toSpine(b.genericBool)(a.value1)}])}),B=new g.AsForeign(function(a){return d.toForeign({name:a.value0,optional:a.value1})});a.OptionArgument=r;a.isOptionArgumentOptional=function(a){return a.value1};a.genericOptionArgument=t;a.isForeigntOptionArgument=p;a.asForeigntOptionArgument=B;a.prettyOptionArgument=c;})(PS["Neodoc.Data.OptionArgument"]=PS["Neodoc.Data.OptionArgument"]||
{});
(function(a){var b=PS["Data.Maybe"],c=PS["Data.Array"],e=PS["Data.List.NonEmpty"],d=PS["Data.Foreign"],g=PS["Data.Foreign.Class"],k=PS["Data.Foreign.Index"],l=PS["Data.Foreign.Extra"],h=PS["Data.String"],f=PS["Control.Monad.Error.Class"],m=PS["Neodoc.Value"],n=PS["Neodoc.OptionAlias"],r=PS["Neodoc.Data.OptionArgument"],p=PS["Control.Apply"],t=PS["Control.Bind"],B=PS["Data.Functor"],q=PS["Control.Applicative"],w=PS["Data.NonEmpty"],x=PS["Data.List.Types"],y=PS["Control.Monad.Except.Trans"],C=PS["Data.Identity"],u=
function(){function a(a,b,c,d,f){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=f;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return new a(b,c,d,f,e)}}}}};return a}(),A=function(){function a(){}a.value=new a;return a}(),z=new g.IsForeign(function(a){var b=function(a){return f.catchError(y.monadErrorExceptT(C.monadIdentity))(t.bindFlipped(y.bindExceptT(C.monadIdentity))(l.readNonemptyList(n.isForeignOptionAlias))(k.ix(k.indexString)(a)("aliases")))(function(a){return d.fail(k.errorAt(k.indexString)("aliases")(e.head(a)))})};
return t.bind(y.bindExceptT(C.monadIdentity))(B.map(y.functorExceptT(C.functorIdentity))(h.toUpper)(g.readProp(g.stringIsForeign)(k.indexString)("type")(a)))(function(c){return "COMMAND"===c?q.pure(y.applicativeExceptT(C.monadIdentity))(A.value):"OPTION"===c?p.apply(y.applyExceptT(C.monadIdentity))(p.apply(y.applyExceptT(C.monadIdentity))(p.apply(y.applyExceptT(C.monadIdentity))(p.apply(y.applyExceptT(C.monadIdentity))(B.map(y.functorExceptT(C.functorIdentity))(u.create)(b(a)))(g.readProp(g.booleanIsForeign)(k.indexString)("repeatable")(a)))(l.readPropMaybe(r.isForeigntOptionArgument)(k.indexString)("argument")(a)))(l.readPropMaybe(m.isForeignValue)(k.indexString)("default")(a)))(l.readPropMaybe(g.stringIsForeign)(k.indexString)("env")(a)):
d.fail(k.errorAt(k.indexString)("type")(d.JSONError.create("unknown type: "+c)))})}),E=new g.AsForeign(function(a){if(a instanceof A)return d.toForeign({type:"COMMAND"});if(a instanceof u)return d.toForeign({type:"OPTION",aliases:c.fromFoldable(w.foldableNonEmpty(x.foldableList))(B.map(w.functorNonEmpty(x.functorList))(g.write(n.asForeignOptionAlias))(a.value0)),repeatable:g.write(g.booleanAsForeign)(a.value1),argument:b.maybe(l.undefined)(g.write(r.asForeigntOptionArgument))(a.value2),"default":b.maybe(l.undefined)(g.write(m.asForeignValue))(a.value3),
env:b.maybe(l.undefined)(g.write(g.stringAsForeign))(a.value4)});throw Error("Failed pattern match at Neodoc.Data.Description line 63, column 3 - line 63, column 62: "+[a.constructor.name]);});a.OptionDescription=u;a.CommandDescription=A;a.isForeignDescription=z;a.asForeignDescription=E;})(PS["Neodoc.Data.Description"]=PS["Neodoc.Data.Description"]||{});
(function(a){var b=PS["Data.List"],c=PS["Data.Array"],e=PS["Data.Maybe"],d=PS["Data.Foldable"],g=PS["Data.Traversable"],k=PS["Data.NonEmpty"],l=PS["Data.Foreign"],h=PS["Data.Foreign.Class"],f=PS["Data.Foreign.Index"],m=PS["Data.Foreign.Extra"],n=PS["Neodoc.Data.Description"],r=PS["Control.Bind"],p=PS["Control.Applicative"],t=PS["Data.List.Types"],B=PS["Data.Functor"],q=PS["Control.Apply"],w=PS["Control.Monad.Except.Trans"],x=PS["Data.Identity"],y=function(a){return a};a.Spec=y;a.isForeignOptionAlias=
function(a){return new h.IsForeign(function(l){var u=function(c){return function(f){return m.errorAtIndex(c)(r.bind(w.bindExceptT(x.monadIdentity))(h.read(h.arrayIsForeign(a))(f))(function(a){var c=p.pure(w.applicativeExceptT(x.monadIdentity));a=b.fromFoldable(d.foldableArray)(a);if(a instanceof t.Cons)a=e.Just.create(new k.NonEmpty(a.value0,a.value1));else if(a instanceof t.Nil)a=e.Nothing.value;else throw Error("Failed pattern match at Neodoc.Spec line 62, column 12 - line 64, column 24: "+[a.constructor.name]);
return c(a)}))}},z=function(a){return function(f){return m.errorAtIndex(a)(r.bind(w.bindExceptT(x.monadIdentity))(h.read(h.arrayIsForeign(h.foreignIsForeign))(f))(function(a){return B.map(w.functorExceptT(x.functorIdentity))(function(a){return b.catMaybes(b.fromFoldable(d.foldableArray)(a))})(g.sequence(g.traversableArray)(w.applicativeExceptT(x.monadIdentity))(c.zipWith(u)(c.range(0)(c.length(a)))(a)))}))}};return B.map(w.functorExceptT(x.functorIdentity))(y)(q.apply(w.applyExceptT(x.monadIdentity))(q.apply(w.applyExceptT(x.monadIdentity))(q.apply(w.applyExceptT(x.monadIdentity))(q.apply(w.applyExceptT(x.monadIdentity))(B.map(w.functorExceptT(x.functorIdentity))(function(a){return function(b){return function(c){return function(d){return function(f){return {program:a,
layouts:b,descriptions:c,helpText:d,shortHelp:f}}}}}})(h.readProp(h.stringIsForeign)(f.indexString)("program")(l)))(function(a){return r.bind(w.bindExceptT(x.monadIdentity))(h.readProp(h.arrayIsForeign(h.foreignIsForeign))(f.indexString)("layouts")(a))(function(a){return r.bind(w.bindExceptT(x.monadIdentity))(B.map(w.functorExceptT(x.functorIdentity))(b.fromFoldable(d.foldableArray))(g.sequence(g.traversableArray)(w.applicativeExceptT(x.monadIdentity))(c.zipWith(z)(c.range(0)(c.length(a)))(a))))(function(a){if(a instanceof
t.Cons)return p.pure(w.applicativeExceptT(x.monadIdentity))(new k.NonEmpty(a.value0,a.value1));if(a instanceof t.Nil)return p.pure(w.applicativeExceptT(x.monadIdentity))(new k.NonEmpty(t.Nil.value,t.Nil.value));throw Error("Failed pattern match at Neodoc.Spec line 51, column 7 - line 53, column 34: "+[a.constructor.name]);})})}(l)))(function(a){return r.bind(w.bindExceptT(x.monadIdentity))(h.readProp(h.arrayIsForeign(n.isForeignDescription))(f.indexString)("descriptions")(a))(function(a){return p.pure(w.applicativeExceptT(x.monadIdentity))(b.fromFoldable(d.foldableArray)(a))})}(l)))(h.readProp(h.stringIsForeign)(f.indexString)("helpText")(l)))(h.readProp(h.stringIsForeign)(f.indexString)("shortHelp")(l)))})};
a.asForeignOptionAlias=function(a){return new h.AsForeign(function(b){var d=c.fromFoldable(k.foldableNonEmpty(t.foldableList))(B.mapFlipped(k.functorNonEmpty(t.functorList))(b.layouts)(function(b){return c.fromFoldable(t.foldableList)(B.mapFlipped(t.functorList)(b)(function(b){return c.fromFoldable(k.foldableNonEmpty(t.foldableList))(B.map(k.functorNonEmpty(t.functorList))(h.write(a))(b))}))})),f=c.fromFoldable(t.foldableList)(B.map(t.functorList)(h.write(n.asForeignDescription))(b.descriptions));
return l.toForeign(function(){var a={},c;for(c in b)({}).hasOwnProperty.call(b,c)&&(a[c]=b[c]);a.layouts=d;a.descriptions=f;return a}())})};})(PS["Neodoc.Spec"]=PS["Neodoc.Spec"]||{});
(function(a){var b=PS["Data.Generic"],c=PS["Data.String"],e=PS["Data.Pretty"],d=PS["Data.Array"],g=PS["Data.Maybe"],k=PS["Data.Foldable"],l=PS["Data.List.NonEmpty"],h=PS["Data.NonEmpty"],f=PS["Data.Foreign"],m=PS["Data.Foreign.Class"],n=PS["Data.Foreign.Index"],r=PS["Data.Foreign.Extra"],p=PS["Control.Monad.Error.Class"],t=PS["Neodoc.Data.OptionArgument"],B=PS["Control.Apply"],q=PS["Data.Unit"],w=PS["Data.Show"],x=PS["Control.Bind"],y=PS["Data.Functor"],C=PS["Control.Applicative"],u=PS["Data.Monoid"],
A=PS["Control.Monad.Except.Trans"],z=PS["Data.Identity"],E=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),F=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),G=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),I=function(){function a(a,
b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),v=function(){function a(){}a.value=new a;return a}(),H=function(){function a(){}a.value=new a;return a}(),L=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),J=new e.Pretty(function(){var a=function(a){if(a)return "...";if(!a)return "";throw Error("Failed pattern match at Neodoc.Data.UsageLayout line 128, column 13 - line 128, column 34: "+
[a.constructor.name]);};return function(b){if(b instanceof E||b instanceof F)return b.value0+a(b.value1);if(b instanceof v)return "--";if(b instanceof H)return "-";if(b instanceof L)return "["+(b.value0+"]");if(b instanceof G)return "--"+(b.value0+(g.maybe("")(function(a){return "\x3d"+e.pretty(t.prettyOptionArgument)(a)})(b.value1)+a(b.value2)));if(b instanceof I)return "-"+(k.intercalate(h.foldableNonEmpty(k.foldableArray))(u.monoidString)("")(y.map(h.functorNonEmpty(y.functorArray))(c.singleton)(b.value0))+
(g.maybe("")(function(a){return "\x3d"+e.pretty(t.prettyOptionArgument)(a)})(b.value1)+a(b.value2)));throw Error("Failed pattern match at Neodoc.Data.UsageLayout line 111, column 3 - line 128, column 34: "+[b.constructor.name]);}}()),K=new m.IsForeign(function(a){var b=function(a){return p.catchError(A.monadErrorExceptT(z.monadIdentity))(x.bindFlipped(A.bindExceptT(z.monadIdentity))(r.readNonemptyArray(m.charIsForeign))(n.ix(n.indexString)(a)("chars")))(function(a){return f.fail(n.errorAt(n.indexString)("chars")(l.head(a)))})};
return x.bind(A.bindExceptT(z.monadIdentity))(y.map(A.functorExceptT(z.functorIdentity))(c.toUpper)(m.readProp(m.stringIsForeign)(n.indexString)("type")(a)))(function(c){return "EOA"===c?C.pure(A.applicativeExceptT(z.monadIdentity))(v.value):"STDIN"===c?C.pure(A.applicativeExceptT(z.monadIdentity))(H.value):"COMMAND"===c?B.apply(A.applyExceptT(z.monadIdentity))(y.map(A.functorExceptT(z.functorIdentity))(E.create)(m.readProp(m.stringIsForeign)(n.indexString)("name")(a)))(m.readProp(m.booleanIsForeign)(n.indexString)("repeatable")(a)):
"POSITIONAL"===c?B.apply(A.applyExceptT(z.monadIdentity))(y.map(A.functorExceptT(z.functorIdentity))(F.create)(m.readProp(m.stringIsForeign)(n.indexString)("name")(a)))(m.readProp(m.booleanIsForeign)(n.indexString)("repeatable")(a)):"REFERENCE"===c?y.map(A.functorExceptT(z.functorIdentity))(L.create)(m.readProp(m.stringIsForeign)(n.indexString)("name")(a)):"OPTION"===c?B.apply(A.applyExceptT(z.monadIdentity))(B.apply(A.applyExceptT(z.monadIdentity))(y.map(A.functorExceptT(z.functorIdentity))(G.create)(m.readProp(m.stringIsForeign)(n.indexString)("name")(a)))(r.readPropMaybe(t.isForeigntOptionArgument)(n.indexString)("argument")(a)))(m.readProp(m.booleanIsForeign)(n.indexString)("repeatable")(a)):
"OPTIONSTACK"===c?B.apply(A.applyExceptT(z.monadIdentity))(B.apply(A.applyExceptT(z.monadIdentity))(y.map(A.functorExceptT(z.functorIdentity))(I.create)(b(a)))(r.readPropMaybe(t.isForeigntOptionArgument)(n.indexString)("argument")(a)))(m.readProp(m.booleanIsForeign)(n.indexString)("repeatable")(a)):f.fail(n.errorAt(n.indexString)("type")(f.JSONError.create("unknown type: "+c)))})}),S=new b.Generic(function(a){return a instanceof b.SProd&&"Neodoc.Data.UsageLayout.Command"===a.value0&&2===a.value1.length?
B.apply(g.applyMaybe)(B.apply(g.applyMaybe)(new g.Just(E.create))(b.fromSpine(b.genericString)(a.value1[0](q.unit))))(b.fromSpine(b.genericBool)(a.value1[1](q.unit))):a instanceof b.SProd&&"Neodoc.Data.UsageLayout.Positional"===a.value0&&2===a.value1.length?B.apply(g.applyMaybe)(B.apply(g.applyMaybe)(new g.Just(F.create))(b.fromSpine(b.genericString)(a.value1[0](q.unit))))(b.fromSpine(b.genericBool)(a.value1[1](q.unit))):a instanceof b.SProd&&"Neodoc.Data.UsageLayout.Option"===a.value0&&3===a.value1.length?
B.apply(g.applyMaybe)(B.apply(g.applyMaybe)(B.apply(g.applyMaybe)(new g.Just(G.create))(b.fromSpine(b.genericString)(a.value1[0](q.unit))))(b.fromSpine(b.genericMaybe(t.genericOptionArgument))(a.value1[1](q.unit))))(b.fromSpine(b.genericBool)(a.value1[2](q.unit))):a instanceof b.SProd&&"Neodoc.Data.UsageLayout.OptionStack"===a.value0&&3===a.value1.length?B.apply(g.applyMaybe)(B.apply(g.applyMaybe)(B.apply(g.applyMaybe)(new g.Just(I.create))(b.fromSpine(b.genericNonEmpty(b.genericArray(b.genericChar))(b.genericChar))(a.value1[0](q.unit))))(b.fromSpine(b.genericMaybe(t.genericOptionArgument))(a.value1[1](q.unit))))(b.fromSpine(b.genericBool)(a.value1[2](q.unit))):
a instanceof b.SProd&&"Neodoc.Data.UsageLayout.EOA"===a.value0&&0===a.value1.length?new g.Just(v.value):a instanceof b.SProd&&"Neodoc.Data.UsageLayout.Stdin"===a.value0&&0===a.value1.length?new g.Just(H.value):a instanceof b.SProd&&"Neodoc.Data.UsageLayout.Reference"===a.value0&&1===a.value1.length?B.apply(g.applyMaybe)(new g.Just(L.create))(b.fromSpine(b.genericString)(a.value1[0](q.unit))):g.Nothing.value},function(a){return new b.SigProd("Neodoc.Data.UsageLayout.UsageLayoutArg",[{sigConstructor:"Neodoc.Data.UsageLayout.Command",
sigValues:[function(a){return b.toSignature(b.genericString)(b.anyProxy)},function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]},{sigConstructor:"Neodoc.Data.UsageLayout.Positional",sigValues:[function(a){return b.toSignature(b.genericString)(b.anyProxy)},function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]},{sigConstructor:"Neodoc.Data.UsageLayout.Option",sigValues:[function(a){return b.toSignature(b.genericString)(b.anyProxy)},function(a){return b.toSignature(b.genericMaybe(t.genericOptionArgument))(b.anyProxy)},
function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]},{sigConstructor:"Neodoc.Data.UsageLayout.OptionStack",sigValues:[function(a){return b.toSignature(b.genericNonEmpty(b.genericArray(b.genericChar))(b.genericChar))(b.anyProxy)},function(a){return b.toSignature(b.genericMaybe(t.genericOptionArgument))(b.anyProxy)},function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]},{sigConstructor:"Neodoc.Data.UsageLayout.EOA",sigValues:[]},{sigConstructor:"Neodoc.Data.UsageLayout.Stdin",sigValues:[]},
{sigConstructor:"Neodoc.Data.UsageLayout.Reference",sigValues:[function(a){return b.toSignature(b.genericString)(b.anyProxy)}]}])},function(a){if(a instanceof E)return new b.SProd("Neodoc.Data.UsageLayout.Command",[function(c){return b.toSpine(b.genericString)(a.value0)},function(c){return b.toSpine(b.genericBool)(a.value1)}]);if(a instanceof F)return new b.SProd("Neodoc.Data.UsageLayout.Positional",[function(c){return b.toSpine(b.genericString)(a.value0)},function(c){return b.toSpine(b.genericBool)(a.value1)}]);
if(a instanceof G)return new b.SProd("Neodoc.Data.UsageLayout.Option",[function(c){return b.toSpine(b.genericString)(a.value0)},function(c){return b.toSpine(b.genericMaybe(t.genericOptionArgument))(a.value1)},function(c){return b.toSpine(b.genericBool)(a.value2)}]);if(a instanceof I)return new b.SProd("Neodoc.Data.UsageLayout.OptionStack",[function(c){return b.toSpine(b.genericNonEmpty(b.genericArray(b.genericChar))(b.genericChar))(a.value0)},function(c){return b.toSpine(b.genericMaybe(t.genericOptionArgument))(a.value1)},
function(c){return b.toSpine(b.genericBool)(a.value2)}]);if(a instanceof v)return new b.SProd("Neodoc.Data.UsageLayout.EOA",[]);if(a instanceof H)return new b.SProd("Neodoc.Data.UsageLayout.Stdin",[]);if(a instanceof L)return new b.SProd("Neodoc.Data.UsageLayout.Reference",[function(c){return b.toSpine(b.genericString)(a.value0)}]);throw Error("Failed pattern match at Neodoc.Data.UsageLayout line 39, column 1 - line 39, column 64: "+[a.constructor.name]);}),w=new w.Show(b.gShow(S)),R=new m.AsForeign(function(a){if(a instanceof
E)return f.toForeign({type:"Command",name:m.write(m.stringAsForeign)(a.value0),repeatable:m.write(m.booleanAsForeign)(a.value1)});if(a instanceof F)return f.toForeign({type:"Positional",name:m.write(m.stringAsForeign)(a.value0),repeatable:m.write(m.booleanAsForeign)(a.value1)});if(a instanceof G)return f.toForeign({type:"Option",name:m.write(m.stringAsForeign)(a.value0),argument:g.maybe(r.undefined)(m.write(t.asForeigntOptionArgument))(a.value1),repeatable:m.write(m.booleanAsForeign)(a.value2)});
if(a instanceof I)return f.toForeign({type:"OptionStack",chars:m.write(m.arrayAsForeign(m.charAsForeign))(d.fromFoldable(h.foldableNonEmpty(k.foldableArray))(a.value0)),argument:g.maybe(r.undefined)(m.write(t.asForeigntOptionArgument))(a.value1),repeatable:m.write(m.booleanAsForeign)(a.value2)});if(a instanceof L)return f.toForeign({type:"Reference",name:m.write(m.stringAsForeign)(a.value0)});if(a instanceof H)return f.toForeign({type:"Stdin"});if(a instanceof v)return f.toForeign({type:"EOA"});throw Error("Failed pattern match at Neodoc.Data.UsageLayout line 46, column 3 - line 50, column 6: "+
[a.constructor.name]);});a.Command=E;a.Positional=F;a.Option=G;a.OptionStack=I;a.EOA=v;a.Stdin=H;a.Reference=L;a.genericUsageLayoutArg=S;a.showUsageLayoutArg=w;a.asForeignUsageLayoutArg=R;a.isForeignUsageLayoutArg=K;a.prettyUsageLayoutArg=J;})(PS["Neodoc.Data.UsageLayout"]=PS["Neodoc.Data.UsageLayout"]||{});
(function(a){var b=PS["Data.String"],c=PS["Neodoc.OptionAlias"],e=PS["Data.Ord"],d=PS["Data.Ordering"],g=PS["Data.Eq"],k=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),l=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),h=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),f=function(){function a(){}a.value=new a;return a}(),m=function(){function a(){}a.value=new a;return a}(),n=new g.Eq(function(a){return function(d){return a instanceof
k&&d instanceof k?b.toUpper(a.value0)===b.toUpper(d.value0):a instanceof l&&d instanceof l?a.value0===d.value0:a instanceof h&&d instanceof h?g.eq(c.eqOptionAlias)(a.value0)(d.value0):a instanceof f&&d instanceof f||a instanceof m&&d instanceof m?!0:!1}}),r=new e.Ord(function(){return n},function(a){return function(b){if(a instanceof k&&b instanceof k)return e.compare(e.ordString)(a.value0)(b.value0);if(a instanceof k)return d.LT.value;if(b instanceof k)return d.GT.value;if(a instanceof l&&b instanceof
l)return e.compare(e.ordString)(a.value0)(b.value0);if(a instanceof l)return d.LT.value;if(b instanceof l)return d.GT.value;if(a instanceof h&&b instanceof h)return e.compare(c.ordOptionAlias)(a.value0)(b.value0);if(a instanceof h)return d.LT.value;if(b instanceof h)return d.GT.value;if(a instanceof f&&b instanceof f)return d.EQ.value;if(a instanceof f)return d.LT.value;if(b instanceof f)return d.GT.value;if(a instanceof m&&b instanceof m)return d.EQ.value;throw Error("Failed pattern match at Neodoc.ArgKey line 16, column 1 - line 16, column 40: "+
[a.constructor.name,b.constructor.name]);}});a.PositionalKey=k;a.CommandKey=l;a.OptionKey=h;a.EOAKey=f;a.StdinKey=m;a.ordArgKey=r;a.eqArgKey=n;})(PS["Neodoc.ArgKey"]=PS["Neodoc.ArgKey"]||{});(function(a){var b=PS["Neodoc.ArgKey"],c=function(a){this.toArgKey=a;},e=new c(function(a){return new b.OptionKey(a)});a.ToArgKey=c;a.toArgKey=function(a){return a.toArgKey};a.toArgKeyOptionAlias=e;})(PS["Neodoc.ArgKey.Class"]=PS["Neodoc.ArgKey.Class"]||{});
(function(a){var b=PS["Data.Generic"],c=PS["Data.Pretty"],e=PS["Data.Maybe"],d=PS["Data.Foldable"],g=PS["Data.String"],k=PS["Data.NonEmpty"],l=PS["Data.Foreign"],h=PS["Data.Foreign.Class"],f=PS["Data.Foreign.Index"],m=PS["Data.Foreign.Extra"],n=PS["Neodoc.Data.Layout"],r=PS["Neodoc.OptionAlias"],p=PS["Neodoc.ArgKey"],t=PS["Neodoc.ArgKey.Class"],B=PS["Neodoc.Data.OptionArgument"],q=PS["Data.HeytingAlgebra"],w=PS["Control.Apply"],x=PS["Data.Unit"],y=PS["Control.Bind"],C=PS["Data.Functor"],u=PS["Control.Applicative"],
A=PS["Data.List.Types"],z=PS["Control.Monad.Except.Trans"],E=PS["Data.Identity"],F=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),G=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),I=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),
v=function(){function a(){}a.value=new a;return a}(),H=function(){function a(){}a.value=new a;return a}(),t=new t.ToArgKey(function(a){if(a instanceof F)return new p.CommandKey(a.value0);if(a instanceof G)return new p.PositionalKey(a.value0);if(a instanceof I)return new p.OptionKey(a.value0);if(a instanceof v)return p.EOAKey.value;if(a instanceof H)return p.StdinKey.value;throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 49, column 3 - line 49, column 46: "+[a.constructor.name]);
}),L=new c.Pretty(function(){var a=function(a){if(a)return "...";if(!a)return "";throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 63, column 13 - line 64, column 5: "+[a.constructor.name]);},b=function(a){return function(b){var c=function(){if(b.value1)return "[\x3d";if(!b.value1){var c=r.isLong(a);if(c)return "\x3d";if(!c)return "";throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 65, column 31 - line 65, column 71: "+[c.constructor.name]);}throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 65, column 10 - line 65, column 72: "+
[b.value1.constructor.name]);}(),d=b.value0,f;if(b.value1)f="]";else {if(b.value1)throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 67, column 13 - line 67, column 34: "+[b.value1.constructor.name]);f="";}return c+(d+f)}};return function(d){if(d instanceof F||d instanceof G)return d.value0+a(d.value1);if(d instanceof v)return "--";if(d instanceof H)return "-";if(d instanceof I)return c.pretty(r.prettyOptionAlias)(d.value0)+(e.maybe("")(b(d.value0))(d.value1)+a(d.value2));throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 56, column 3 - line 67, column 35: "+
[d.constructor.name]);}}()),J=function(a){return a instanceof I?!0:!1},K=function(a){if(a instanceof n.Group)return d.all(k.foldableNonEmpty(A.foldableList))(q.heytingAlgebraBoolean)(d.all(k.foldableNonEmpty(A.foldableList))(q.heytingAlgebraBoolean)(K))(a.value2);if(a instanceof n.Elem)return J(a.value0);throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 168, column 1 - line 168, column 56: "+[a.constructor.name]);},S=new h.IsForeign(function(a){return y.bind(z.bindExceptT(E.monadIdentity))(C.map(z.functorExceptT(E.functorIdentity))(g.toUpper)(h.readProp(h.stringIsForeign)(f.indexString)("type")(a)))(function(b){return "EOA"===
b?u.pure(z.applicativeExceptT(E.monadIdentity))(v.value):"STDIN"===b?u.pure(z.applicativeExceptT(E.monadIdentity))(H.value):"COMMAND"===b?w.apply(z.applyExceptT(E.monadIdentity))(C.map(z.functorExceptT(E.functorIdentity))(F.create)(h.readProp(h.stringIsForeign)(f.indexString)("name")(a)))(h.readProp(h.booleanIsForeign)(f.indexString)("repeatable")(a)):"POSITIONAL"===b?w.apply(z.applyExceptT(E.monadIdentity))(C.map(z.functorExceptT(E.functorIdentity))(G.create)(h.readProp(h.stringIsForeign)(f.indexString)("name")(a)))(h.readProp(h.booleanIsForeign)(f.indexString)("repeatable")(a)):
"OPTION"===b?w.apply(z.applyExceptT(E.monadIdentity))(w.apply(z.applyExceptT(E.monadIdentity))(C.map(z.functorExceptT(E.functorIdentity))(I.create)(h.readProp(r.isForeignOptionAlias)(f.indexString)("name")(a)))(m.readPropMaybe(B.isForeigntOptionArgument)(f.indexString)("argument")(a)))(h.readProp(h.booleanIsForeign)(f.indexString)("repeatable")(a)):l.fail(f.errorAt(f.indexString)("type")(l.JSONError.create("unknown type: "+b)))})}),R=new b.Generic(function(a){return a instanceof b.SProd&&"Neodoc.Data.SolvedLayout.Command"===
a.value0&&2===a.value1.length?w.apply(e.applyMaybe)(w.apply(e.applyMaybe)(new e.Just(F.create))(b.fromSpine(b.genericString)(a.value1[0](x.unit))))(b.fromSpine(b.genericBool)(a.value1[1](x.unit))):a instanceof b.SProd&&"Neodoc.Data.SolvedLayout.Positional"===a.value0&&2===a.value1.length?w.apply(e.applyMaybe)(w.apply(e.applyMaybe)(new e.Just(G.create))(b.fromSpine(b.genericString)(a.value1[0](x.unit))))(b.fromSpine(b.genericBool)(a.value1[1](x.unit))):a instanceof b.SProd&&"Neodoc.Data.SolvedLayout.Option"===
a.value0&&3===a.value1.length?w.apply(e.applyMaybe)(w.apply(e.applyMaybe)(w.apply(e.applyMaybe)(new e.Just(I.create))(b.fromSpine(r.genericOptionAlias)(a.value1[0](x.unit))))(b.fromSpine(b.genericMaybe(B.genericOptionArgument))(a.value1[1](x.unit))))(b.fromSpine(b.genericBool)(a.value1[2](x.unit))):a instanceof b.SProd&&"Neodoc.Data.SolvedLayout.EOA"===a.value0&&0===a.value1.length?new e.Just(v.value):a instanceof b.SProd&&"Neodoc.Data.SolvedLayout.Stdin"===a.value0&&0===a.value1.length?new e.Just(H.value):
e.Nothing.value},function(a){return new b.SigProd("Neodoc.Data.SolvedLayout.SolvedLayoutArg",[{sigConstructor:"Neodoc.Data.SolvedLayout.Command",sigValues:[function(a){return b.toSignature(b.genericString)(b.anyProxy)},function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]},{sigConstructor:"Neodoc.Data.SolvedLayout.Positional",sigValues:[function(a){return b.toSignature(b.genericString)(b.anyProxy)},function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]},{sigConstructor:"Neodoc.Data.SolvedLayout.Option",
sigValues:[function(a){return b.toSignature(r.genericOptionAlias)(b.anyProxy)},function(a){return b.toSignature(b.genericMaybe(B.genericOptionArgument))(b.anyProxy)},function(a){return b.toSignature(b.genericBool)(b.anyProxy)}]},{sigConstructor:"Neodoc.Data.SolvedLayout.EOA",sigValues:[]},{sigConstructor:"Neodoc.Data.SolvedLayout.Stdin",sigValues:[]}])},function(a){if(a instanceof F)return new b.SProd("Neodoc.Data.SolvedLayout.Command",[function(c){return b.toSpine(b.genericString)(a.value0)},function(c){return b.toSpine(b.genericBool)(a.value1)}]);
if(a instanceof G)return new b.SProd("Neodoc.Data.SolvedLayout.Positional",[function(c){return b.toSpine(b.genericString)(a.value0)},function(c){return b.toSpine(b.genericBool)(a.value1)}]);if(a instanceof I)return new b.SProd("Neodoc.Data.SolvedLayout.Option",[function(c){return b.toSpine(r.genericOptionAlias)(a.value0)},function(c){return b.toSpine(b.genericMaybe(B.genericOptionArgument))(a.value1)},function(c){return b.toSpine(b.genericBool)(a.value2)}]);if(a instanceof v)return new b.SProd("Neodoc.Data.SolvedLayout.EOA",
[]);if(a instanceof H)return new b.SProd("Neodoc.Data.SolvedLayout.Stdin",[]);throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 43, column 1 - line 43, column 66: "+[a.constructor.name]);}),P=new h.AsForeign(function(a){if(a instanceof F)return l.toForeign({type:"Command",name:h.write(h.stringAsForeign)(a.value0),repeatable:h.write(h.booleanAsForeign)(a.value1)});if(a instanceof G)return l.toForeign({type:"Positional",name:h.write(h.stringAsForeign)(a.value0),repeatable:h.write(h.booleanAsForeign)(a.value1)});
if(a instanceof I)return l.toForeign({type:"Option",name:h.write(r.asForeignOptionAlias)(a.value0),argument:e.maybe(m.undefined)(h.write(B.asForeigntOptionArgument))(a.value1),repeatable:h.write(h.booleanAsForeign)(a.value2)});if(a instanceof H)return l.toForeign({type:"Stdin"});if(a instanceof v)return l.toForeign({type:"EOA"});throw Error("Failed pattern match at Neodoc.Data.SolvedLayout line 70, column 3 - line 74, column 6: "+[a.constructor.name]);});a.Command=F;a.Positional=G;a.Option=I;a.EOA=
v;a.Stdin=H;a.isCommand=function(a){return a instanceof F?!0:!1};a.isElemRepeatable=function(a){return a instanceof F||a instanceof G?a.value1:a instanceof I?a.value2:!1};a.isFlag=function(a){return a instanceof I&&a.value1 instanceof e.Nothing?!0:!1};a.isFreeElem=J;a.isFreeLayout=K;a.isOption=function(a){return a instanceof I?!0:!1};a.isPositional=function(a){return a instanceof G?!0:!1};a.setRepeatableOr=function(a){return function(b){return b instanceof n.Group?new n.Group(b.value0,a||b.value1,
b.value2):b instanceof n.Elem&&b.value0 instanceof F?new n.Elem(new F(b.value0.value0,a||b.value0.value1)):b instanceof n.Elem&&b.value0 instanceof G?new n.Elem(new G(b.value0.value0,a||b.value0.value1)):b instanceof n.Elem&&b.value0 instanceof I?new n.Elem(new I(b.value0.value0,b.value0.value1,a||b.value0.value2)):b}};a.genericSolvedLayoutArg=R;a.toArgKeySolvedLayoutArg=t;a.prettySolvedLayoutArg=L;a.asForeignSolvedLayoutArg=P;a.isForeignSolvedLayoutArg=S;})(PS["Neodoc.Data.SolvedLayout"]=PS["Neodoc.Data.SolvedLayout"]||
{});
(function(a){var b=PS["Data.Pretty"],c=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),e=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),d=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),g=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),k=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),l=function(){function a(){}a.value=
new a;return a}(),b=new b.Pretty(function(a){if(a instanceof c)return "Failed to disect neodoc text:\n"+a.value0;if(a instanceof e)return "Failed to lex specification:\n"+a.value0;if(a instanceof d)return "Failed to parse specification:\n"+a.value0;if(a instanceof g)return "Incoherent specification:\n"+a.value0;if(a instanceof l)return "Package version could not be detected";if(a instanceof k)return a.value0;throw Error("Failed pattern match at Neodoc.Error line 28, column 3 - line 28, column 68: "+[a.constructor.name]);
});a.ScanError=c;a.SpecLexError=e;a.SpecParseError=d;a.SpecSolveError=g;a.ArgParserError=k;a.VersionMissingError=l;a.isDeveloperError=function(a){return a instanceof k?!1:!0};a.prettyNeodocError=b;})(PS["Neodoc.Error"]=PS["Neodoc.Error"]||{});
(function(a){var b=PS["Data.Either"],c=PS["Data.Bifunctor"];a.ToNeodocError=function(a){this.toNeodocError=a;};a.capture=function(a){return c.lmap(b.bifunctorEither)(a.toNeodocError)};a.toNeodocError=function(a){return a.toNeodocError};})(PS["Neodoc.Error.Class"]=PS["Neodoc.Error.Class"]||{});
(function(a){var b=PS["Data.Either"],c=PS["Neodoc.Error"],e=new PS["Neodoc.Error.Class"].ToNeodocError(function(a){return new c.SpecSolveError(a)});a.SolveError=function(a){return a};a.fail=function(a){return b.Left.create(a)};a.toNeodocErrorSolveError=e;})(PS["Neodoc.Solve.Error"]=PS["Neodoc.Solve.Error"]||{});
(function(a){var b=PS["Data.Foreign.Extra"],c=PS["Unsafe.Coerce"],e=PS["Data.Functor"],d=PS["Control.Monad.Except.Trans"],g=PS["Data.Identity"],k=PS["Data.StrMap"].lookup,l=new PS["Data.Foreign.Class"].IsForeign(function(a){return e.map(d.functorExceptT(g.functorIdentity))(c.unsafeCoerce)(b.readObject(a))});a.lookup=k;a.unwrapEnv=function(a){return a};a.isForeignEnvWrapper=l;})(PS["Neodoc.Env"]=PS["Neodoc.Env"]||{});
(function(a){var b=PS["Data.List"],c=PS["Data.Foldable"],e=PS["Data.Semigroup"],d=PS["Data.List.Types"],g=PS["Control.Applicative"],k=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),l=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}();a.Free=k;a.Fixed=l;a.chunk=function(a){return function(f){return b.reverse(c.foldl(d.foldableList)(function(c){return function(f){if(c instanceof d.Nil){var h=g.pure(d.applicativeList),m;
if(m=a(f))m=k.create;else {if(m)throw Error("Failed pattern match at Neodoc.Data.Chunk line 36, column 24 - line 36, column 56: "+[m.constructor.name]);m=l.create;}return h(m(b.singleton(f)))}if(c instanceof d.Cons&&c.value0 instanceof k&&a(f))return new d.Cons(new k(e.append(d.semigroupList)(c.value0.value0)(b.singleton(f))),c.value1);if(c instanceof d.Cons&&c.value0 instanceof k)return new d.Cons(l.create(b.singleton(f)),c);if(c instanceof d.Cons&&c.value0 instanceof l&&a(f))return new d.Cons(k.create(b.singleton(f)),
c);if(c instanceof d.Cons&&c.value0 instanceof l)return new d.Cons(new l(e.append(d.semigroupList)(c.value0.value0)(b.singleton(f))),c.value1);throw Error("Failed pattern match at Neodoc.Data.Chunk line 36, column 3 - line 36, column 71: "+[c.constructor.name,f.constructor.name]);}})(d.Nil.value)(f))}};})(PS["Neodoc.Data.Chunk"]=PS["Neodoc.Data.Chunk"]||{});
(function(a){var b=PS["Data.Map"],c=PS["Data.Tuple"],e=PS["Data.Ord"],d=PS["Data.List.Types"],g=PS["Data.Functor"],k=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}();a.Indexed=k;a.toMap=function(a){return b.fromFoldable(e.ordInt)(d.foldableList)(g.mapFlipped(d.functorList)(a)(function(a){return new c.Tuple(a.value0,a.value1)}))};})(PS["Neodoc.Data.Indexed"]=PS["Neodoc.Data.Indexed"]||{});
(function(a){var b=PS["Data.NonEmpty"],c=PS["Data.NonEmpty.Extra"],e=PS["Data.Traversable"],d=PS["Data.List"],g=PS["Data.Maybe"],k=PS["Control.Monad.State"],l=PS["Neodoc.Data.Indexed"],h=PS["Neodoc.Data.Layout"],f=PS["Neodoc.Data.EmptyableLayout"],m=PS["Data.Function"],n=PS["Data.Functor"],r=PS["Data.List.Types"],p=PS["Control.Monad.State.Trans"],t=PS["Data.Identity"],B=PS["Control.Bind"],q=PS["Control.Monad.State.Class"],w=PS["Control.Applicative"],x=function(a){if(a instanceof f.EmptyableElem)return new g.Just(new h.Elem(a.value0));
if(a instanceof f.EmptyableGroup){var c=d.catMaybes(n.map(r.functorList)(y)(a.value2));if(c instanceof r.Cons)return new g.Just(new h.Group(a.value0,a.value1,new b.NonEmpty(c.value0,c.value1)));if(c instanceof r.Nil)return g.Nothing.value;throw Error("Failed pattern match at Neodoc.Data.LayoutConversion line 23, column 7 - line 25, column 26: "+[c.constructor.name]);}throw Error("Failed pattern match at Neodoc.Data.LayoutConversion line 20, column 1 - line 20, column 49: "+[a.constructor.name]);},
y=function(a){a=d.catMaybes(n.map(r.functorList)(x)(a));if(a instanceof r.Cons)return new g.Just(new b.NonEmpty(a.value0,a.value1));if(a instanceof r.Nil)return g.Nothing.value;throw Error("Failed pattern match at Neodoc.Data.LayoutConversion line 33, column 6 - line 35, column 26: "+[a.constructor.name]);},C=function(a){if(a instanceof h.Elem)return new f.EmptyableElem(a.value0);if(a instanceof h.Group)return f.EmptyableGroup.create(a.value0)(a.value1)(c.toList(n.map(b.functorNonEmpty(r.functorList))(u)(a.value2)));
throw Error("Failed pattern match at Neodoc.Data.LayoutConversion line 41, column 1 - line 41, column 45: "+[a.constructor.name]);},u=function(a){return c.toList(n.map(b.functorNonEmpty(r.functorList))(C)(a))};a.flattenBranch=function(a){var d=function(a){if(a instanceof h.Elem)return new b.NonEmpty(a.value0,r.Nil.value);if(a instanceof h.Group)return c.concat(c.concat(n.map(b.functorNonEmpty(r.functorList))(function(a){return n.map(b.functorNonEmpty(r.functorList))(d)(a)})(a.value2)));throw Error("Failed pattern match at Neodoc.Data.LayoutConversion line 64, column 1 - line 68, column 77: "+
[a.constructor.name]);};return c.concat(n.map(b.functorNonEmpty(r.functorList))(d)(a))};a.indexBranch=function(a){var c=function(a){if(a instanceof h.Group)return n.map(p.functorStateT(t.functorIdentity))(h.Group.create(a.value0)(a.value1))(e["for"](p.applicativeStateT(t.monadIdentity))(b.traversableNonEmpty(r.traversableList))(a.value2)(e.traverse(b.traversableNonEmpty(r.traversableList))(p.applicativeStateT(t.monadIdentity))(c)));if(a instanceof h.Elem)return B.bind(p.bindStateT(t.monadIdentity))(q.get(p.monadStateStateT(t.monadIdentity)))(function(b){return B.bind(p.bindStateT(t.monadIdentity))(q.put(p.monadStateStateT(t.monadIdentity))(b+
1|0))(function(){return w.pure(p.applicativeStateT(t.monadIdentity))(new h.Elem(new l.Indexed(b,a.value0)))})});throw Error("Failed pattern match at Neodoc.Data.LayoutConversion line 83, column 1 - line 90, column 29: "+[a.constructor.name]);};return m.flip(k.evalState)(0)(e["for"](p.applicativeStateT(t.monadIdentity))(b.traversableNonEmpty(r.traversableList))(a)(c))};a.toEmptyableBranch=u;a.toEmptyableLayout=C;a.toStrictBranch=y;a.toStrictLayout=x;})(PS["Neodoc.Data.LayoutConversion"]=PS["Neodoc.Data.LayoutConversion"]||
{});
(function(a){var b=PS["Data.Maybe"],c=PS["Data.NonEmpty"],e=PS["Data.List.Types"],d=PS["Control.Bind"],g=PS["Control.Applicative"],k=PS["Data.Semigroup"];a.zipTraverseM=function(a){return function(h){return function(f){return function(f){var h=function(l){if(l.value1 instanceof e.Nil)return d.bind(a["__superclass_Control.Bind.Bind_1"]())(f(l.value0)(b.Nothing.value))(function(f){if(f.value1 instanceof b.Nothing)return g.pure(a["__superclass_Control.Applicative.Applicative_0"]())(new c.NonEmpty(f.value0.value0,f.value0.value1));
if(f.value1 instanceof b.Just)return d.bind(a["__superclass_Control.Bind.Bind_1"]())(h(new c.NonEmpty(f.value1.value0,e.Nil.value)))(function(b){return g.pure(a["__superclass_Control.Applicative.Applicative_0"]())(new c.NonEmpty(f.value0.value0,k.append(e.semigroupList)(f.value0.value1)(new e.Cons(b.value0,b.value1))))});throw Error("Failed pattern match at Neodoc.Solve.Traverse line 27, column 7 - line 31, column 37: "+[f.value1.constructor.name]);});if(l.value1 instanceof e.Cons)return d.bind(a["__superclass_Control.Bind.Bind_1"]())(f(l.value0)(new b.Just(l.value1.value0)))(function(f){if(f.value1 instanceof
b.Nothing)return l.value1.value1 instanceof e.Cons?d.bind(a["__superclass_Control.Bind.Bind_1"]())(h(new c.NonEmpty(l.value1.value1.value0,l.value1.value1.value1)))(function(b){return g.pure(a["__superclass_Control.Applicative.Applicative_0"]())(new c.NonEmpty(f.value0.value0,k.append(e.semigroupList)(f.value0.value1)(new e.Cons(b.value0,b.value1))))}):g.pure(a["__superclass_Control.Applicative.Applicative_0"]())(new c.NonEmpty(f.value0.value0,f.value0.value1));if(f.value1 instanceof b.Just)return d.bind(a["__superclass_Control.Bind.Bind_1"]())(h(new c.NonEmpty(f.value1.value0,
l.value1.value1)))(function(b){return g.pure(a["__superclass_Control.Applicative.Applicative_0"]())(new c.NonEmpty(f.value0.value0,k.append(e.semigroupList)(f.value0.value1)(new e.Cons(b.value0,b.value1))))});throw Error("Failed pattern match at Neodoc.Solve.Traverse line 36, column 7 - line 45, column 37: "+[f.value1.constructor.name]);});throw Error("Failed pattern match at Neodoc.Solve.Traverse line 23, column 1 - line 45, column 37: "+[l.constructor.name]);};return h}}}};})(PS["Neodoc.Solve.Traverse"]=
PS["Neodoc.Solve.Traverse"]||{});
(function(a){var b=PS["Data.Optimize.Uncurried"],c=PS["Data.List"],e=PS["Control.Alt"],d=PS["Control.Bind"],g=PS["Data.Generic"],k=PS["Data.Array"],l=PS["Data.Function"],h=PS["Data.Tuple"],f=PS["Data.Maybe"],m=PS["Data.Either"],n=PS["Data.Traversable"],r=PS["Data.Foldable"],p=PS["Data.String"],t=PS["Data.String.Unsafe"],B=PS["Data.String.Ext"],q=PS["Data.NonEmpty"],w=PS["Data.NonEmpty.Extra"],x=PS["Neodoc.Spec"],y=PS["Neodoc.OptionAlias"],C=PS["Neodoc.Data.Description"],u=PS["Neodoc.Data.Layout"],
A=PS["Neodoc.Data.OptionArgument"],z=PS["Neodoc.Data.UsageLayout"],E=PS["Neodoc.Data.SolvedLayout"],F=PS["Neodoc.Solve.Traverse"],G=PS["Neodoc.Solve.Error"],I=PS["Data.Eq"],v=PS["Control.Apply"],H=PS["Data.Unit"],L=PS["Data.Show"],J=PS["Data.Semigroup"],K=PS["Data.List.Types"],S=PS["Data.HeytingAlgebra"],R=PS["Data.Functor"],P=PS["Control.MonadZero"],N=PS["Control.Category"],O=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),D=function(){function a(a){this.value0=
a;}a.create=function(b){return new a(b)};return a}(),M=function(){return function(a){a=f.fromMaybe(a)(p.stripSuffix("\x3e")(a));return f.fromMaybe(a)(p.stripPrefix("\x3c")(a))}}(),U=l.on(I.eq(I.eqString))(function(a){return p.toUpper(M(a))}),I=new g.Generic(function(a){return a instanceof g.SProd&&"Neodoc.Solve.ExpandOptions.SolvedArg"===a.value0&&1===a.value1.length?v.apply(f.applyMaybe)(new f.Just(O.create))(g.fromSpine(E.genericSolvedLayoutArg)(a.value1[0](H.unit))):a instanceof g.SProd&&"Neodoc.Solve.ExpandOptions.ReferenceArg"===
a.value0&&1===a.value1.length?v.apply(f.applyMaybe)(new f.Just(D.create))(g.fromSpine(g.genericString)(a.value1[0](H.unit))):f.Nothing.value},function(a){return new g.SigProd("Neodoc.Solve.ExpandOptions.ExpandedOptionsLayoutArg",[{sigConstructor:"Neodoc.Solve.ExpandOptions.SolvedArg",sigValues:[function(a){return g.toSignature(E.genericSolvedLayoutArg)(g.anyProxy)}]},{sigConstructor:"Neodoc.Solve.ExpandOptions.ReferenceArg",sigValues:[function(a){return g.toSignature(g.genericString)(g.anyProxy)}]}])},
function(a){if(a instanceof O)return new g.SProd("Neodoc.Solve.ExpandOptions.SolvedArg",[function(b){return g.toSpine(E.genericSolvedLayoutArg)(a.value0)}]);if(a instanceof D)return new g.SProd("Neodoc.Solve.ExpandOptions.ReferenceArg",[function(b){return g.toSpine(g.genericString)(a.value0)}]);throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 64, column 1 - line 64, column 78: "+[a.constructor.name]);}),X=new L.Show(g.gShow(I));a.SolvedArg=O;a.ReferenceArg=D;a.expandOptions=function(a){var g=
function(a){return F.zipTraverseM(m.monadEither)(u.showLayout(z.showUsageLayoutArg))(u.showLayout(X))(v)(a)},v=function(v){return function(x){var F=function(g){var v=function(b){return function(d){var e=c.filter(function(a){return a instanceof C.OptionDescription?l.flip(r.any(q.foldableNonEmpty(K.foldableList))(S.heytingAlgebraBoolean))(a.value0)(function(a){return a instanceof y.Short?d===a.value0:!1}):!1})(a.descriptions);if(e instanceof K.Nil)return new m.Right(f.Nothing.value);if(e instanceof
K.Cons&&e.value0 instanceof C.OptionDescription&&e.value0.value2 instanceof f.Just&&e.value1 instanceof K.Nil){if(b)return new m.Right(new f.Just(new h.Tuple(e.value0.value1,new f.Just(e.value0.value2.value0))));if(!b)return G.fail("Stacked option -"+(p.singleton(d)+" may not specify arguments"));throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 330, column 17 - line 335, column 15: "+[b.constructor.name]);}return e instanceof K.Cons&&e.value0 instanceof C.OptionDescription&&e.value0.value2 instanceof
f.Nothing&&e.value1 instanceof K.Nil?new m.Right(new f.Just(new h.Tuple(e.value0.value1,f.Nothing.value))):G.fail("Multiple option descriptions for option -"+p.singleton(d))}},x=function(a){var b=function(a){return function(b){return U(a)(b)?new m.Right(!0):G.fail("Arguments mismatch for option -"+(p.singleton(g.value3.value0)+(": "+(L.show(L.showString)(a)+(" and "+L.show(L.showString)(b))))))}};return d.bind(m.bindEither)(v(!0)(a.value0))(function(e){return d.bind(m.bindEither)(R.map(m.functorEither)(c.fromFoldable(r.foldableArray))(n["for"](m.applicativeEither)(n.traversableArray)(a.value1)(function(a){return d.bind(m.bindEither)(v(!1)(a))(function(){return m.Right.create(function(b){return new E.Option(new y.Short(a),
f.Nothing.value,g.value5||b)})})})))(function(k){if(e instanceof f.Just&&e.value0.value1 instanceof f.Just)return f["maybe'"](function(b){if(b=!e.value0.value1.value0.value1)return G.fail("Option-Argument specified in options-section missing -"+p.singleton(a.value0));if(!b){var d=new E.Option(new y.Short(a.value0),e.value0.value1,g.value5),f=R.map(K.functorList)(function(a){return a(!1)})(k);return g.value2(function(){if(f instanceof K.Cons)return new q.NonEmpty(f.value0,J.append(K.semigroupList)(f.value1)(c.singleton(d)));
if(f instanceof K.Nil)return new q.NonEmpty(d,K.Nil.value);throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 282, column 29 - line 284, column 45: "+[f.constructor.name]);}())}throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 276, column 17 - line 284, column 45: "+[b.constructor.name]);})(function(h){return d.bind(m.bindEither)(b(h.value1.value0)(e.value0.value1.value0.value0))(function(){var b=new E.Option(new y.Short(a.value0),f.Just.create(new A.OptionArgument(h.value1.value0,
h.value1.value1)),h.value0),d=R.map(K.functorList)(function(a){return a(h.value0)})(k);return g.value1(function(){if(d instanceof K.Cons)return new q.NonEmpty(d.value0,J.append(K.semigroupList)(d.value1)(c.singleton(b)));if(d instanceof K.Nil)return new q.NonEmpty(b,K.Nil.value);throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 293, column 25 - line 295, column 39: "+[d.constructor.name]);}())})})(d.bind(f.bindMaybe)(P.guard(f.monadZeroMaybe)(!g.value5))(function(){return d.bind(f.bindMaybe)(g.value0)(function(a){return a instanceof
u.Elem&&a.value0 instanceof z.Positional||a instanceof u.Elem&&a.value0 instanceof z.Command?new f.Just(new h.Tuple(a.value0.value1,new h.Tuple(a.value0.value0,!1))):a instanceof u.Group&&a.value2.value0.value1 instanceof K.Nil&&a.value2.value1 instanceof K.Nil&&(a.value2.value0.value0 instanceof u.Elem&&a.value2.value0.value0.value0 instanceof z.Positional||a.value2.value0.value0 instanceof u.Elem&&a.value2.value0.value0.value0 instanceof z.Command)?new f.Just(new h.Tuple(a.value1||a.value2.value0.value0.value0.value1,
new h.Tuple(a.value2.value0.value0.value0.value0,a.value0))):f.Nothing.value})}));var l=new E.Option(new y.Short(a.value0),f.Nothing.value,g.value5),n=R.map(K.functorList)(function(a){return a(!1)})(k);return g.value2(function(){if(n instanceof K.Cons)return new q.NonEmpty(n.value0,J.append(K.semigroupList)(n.value1)(c.singleton(l)));if(n instanceof K.Nil)return new q.NonEmpty(l,K.Nil.value);throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 311, column 24 - line 313, column 39: "+
[n.constructor.name]);}())})})},D=function(){var b=p.fromCharArray(k.cons(g.value3.value0)(g.value3.value1));return d.bind(m.bindEither)(R.map(m.functorEither)(function(a){return c.head(c.catMaybes(a))})(n["for"](m.applicativeEither)(K.traversableList)(a.descriptions)(function(a){return a instanceof C.OptionDescription&&a.value2 instanceof f.Just?R.map(m.functorEither)(function(a){return c.head(c.catMaybes(w.toList(a)))})(n["for"](m.applicativeEither)(q.traversableNonEmpty(K.traversableList))(a.value0)(function(e){return e instanceof
y.Short?new m.Right(function(){var k=p.toUpper(b),q=M(a.value2.value0.value0),z=p.toUpper(p.singleton(e.value0)+q);return d.bind(f.bindMaybe)(function(){var c=B.endsWith(z)(k);if(c){c=p.length(k)-p.length(z)|0;if(c=t.charAt(c)(b)===e.value0){var c=p.toCharArray(p.take((p.length(b)-p.length(q)|0)-1|0)(b)),d=new E.Option(new y.Short(e.value0),new f.Just(new A.OptionArgument(a.value2.value0.value0,a.value2.value0.value1)),g.value5);return new f.Just(new h.Tuple(c,d))}if(!c)return f.Nothing.value;throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 238, column 25 - line 243, column 37: "+
[c.constructor.name]);}if(!c)return f.Nothing.value;throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 235, column 32 - line 244, column 31: "+[c.constructor.name]);}())(function(a){return d.bind(f.bindMaybe)(m.either(l["const"](f.Nothing.value))(function(a){return f.Just.create(N.id(N.categoryFn)(a))})(R.map(m.functorEither)(c.fromFoldable(r.foldableArray))(n["for"](m.applicativeEither)(n.traversableArray)(a.value0)(function(a){return d.bind(m.bindEither)(v(!1)(a))(function(){return m.Right.create(new E.Option(new y.Short(a),
f.Nothing.value,g.value5))})}))))(function(b){return f.Just.create(new h.Tuple(b,a.value1))})})}()):new m.Right(f.Nothing.value)})):new m.Right(f.Nothing.value)})))(function(a){if(a instanceof f.Nothing)return G.fail("No description subsumed option");if(a instanceof f.Just)return g.value2(function(){if(a.value0.value0 instanceof K.Cons)return new q.NonEmpty(a.value0.value0.value0,J.append(K.semigroupList)(a.value0.value0.value1)(c.singleton(a.value0.value1)));if(a.value0.value0 instanceof K.Nil)return new q.NonEmpty(a.value0.value1,
K.Nil.value);throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 261, column 40 - line 263, column 33: "+[a.value0.value0.constructor.name]);}());throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 259, column 9 - line 263, column 33: "+[a.constructor.name]);})}();return d.bind(m.bindEither)(new m.Right(function(){var a=new h.Tuple(k.last(g.value3.value1),k.init(g.value3.value1));return a.value0 instanceof f.Just&&a.value1 instanceof f.Just?new q.NonEmpty(a.value0.value0,
k.cons(g.value3.value0)(a.value1.value0)):new q.NonEmpty(g.value3.value0,[])}()))(function(a){if(g.value4 instanceof f.Just)return d.bind(m.bindEither)(v(!0)(a.value0))(function(){return d.bind(m.bindEither)(R.map(m.functorEither)(c.fromFoldable(r.foldableArray))(n["for"](m.applicativeEither)(n.traversableArray)(a.value1)(function(a){return d.bind(m.bindEither)(v(!1)(a))(function(){return m.Right.create(new E.Option(new y.Short(a),f.Nothing.value,g.value5))})})))(function(b){var d=new E.Option(new y.Short(a.value0),
f.Just.create(new A.OptionArgument(g.value4.value0.value0,g.value4.value0.value1)),g.value5);return g.value2(function(){if(b instanceof K.Cons)return new q.NonEmpty(b.value0,J.append(K.semigroupList)(b.value1)(c.singleton(d)));if(b instanceof K.Nil)return new q.NonEmpty(d,K.Nil.value);throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 197, column 18 - line 199, column 33: "+[b.constructor.name]);}())})});if(g.value4 instanceof f.Nothing)return e.alt(m.altEither)(D)(x(new b.Args2(a.value0,
a.value1)));throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 185, column 7 - line 205, column 56: "+[g.value4.constructor.name]);})},H=function(b){var e=function(){var d=c.filter(function(a){return a instanceof C.OptionDescription?l.flip(r.any(q.foldableNonEmpty(K.foldableList))(S.heytingAlgebraBoolean))(a.value0)(function(a){return a instanceof y.Long?b.value3===a.value0:!1}):!1})(a.descriptions);return d instanceof K.Nil?new m.Right(f.Nothing.value):d instanceof K.Cons&&d.value0 instanceof
C.OptionDescription&&d.value1 instanceof K.Nil?new m.Right(new f.Just(new h.Tuple(d.value0.value1,d.value0.value2))):G.fail("Multiple option descriptions for option --"+b.value3)}(),g=function(a){return function(c){return U(a)(c)?new m.Right(!0):G.fail("Arguments mismatch for option --"+(b.value3+(": "+(L.show(L.showString)(a)+(" and "+L.show(L.showString)(c))))))}};return d.bind(m.bindEither)(e)(function(a){if(b.value4 instanceof f.Just)return b.value2(new E.Option(new y.Long(b.value3),f.Just.create(new A.OptionArgument(b.value4.value0.value0,
b.value4.value0.value1)),b.value5));if(b.value4 instanceof f.Nothing)return a instanceof f.Just&&a.value0.value1 instanceof f.Just?f.maybe(function(){var c=!a.value0.value1.value0.value1;if(c)return G.fail("Option-Argument specified in options-section missing --"+b.value3);if(!c)return b.value2(new E.Option(new y.Long(b.value3),a.value0.value1,b.value5));throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 132, column 18 - line 135, column 77: "+[c.constructor.name]);}())(function(c){return d.bind(m.bindEither)(g(c.value1.value0)(a.value0.value1.value0.value0))(function(){return b.value1(new E.Option(new y.Long(b.value3),
f.Just.create(new A.OptionArgument(c.value1.value0,c.value1.value1)),c.value0))})})(d.bind(f.bindMaybe)(P.guard(f.monadZeroMaybe)(!b.value5))(function(){return d.bind(f.bindMaybe)(b.value0)(function(a){return a instanceof u.Elem&&a.value0 instanceof z.Positional||a instanceof u.Elem&&a.value0 instanceof z.Command?new f.Just(new h.Tuple(a.value0.value1,new h.Tuple(a.value0.value0,!1))):a instanceof u.Group&&a.value2.value0.value1 instanceof K.Nil&&a.value2.value1 instanceof K.Nil&&(a.value2.value0.value0 instanceof
u.Elem&&a.value2.value0.value0.value0 instanceof z.Positional||a.value2.value0.value0 instanceof u.Elem&&a.value2.value0.value0.value0 instanceof z.Command)?new f.Just(new h.Tuple(a.value1||a.value2.value0.value0.value0.value1,new h.Tuple(a.value2.value0.value0.value0.value0,a.value0))):f.Nothing.value})})):b.value2(new E.Option(new y.Long(b.value3),f.Nothing.value,b.value5));throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 121, column 7 - line 154, column 71: "+[b.value4.constructor.name]);
})};d.bind(f.bindMaybe)(x)(function(a){if(a instanceof u.Group)return f.Nothing.value;if(a instanceof u.Elem)return new f.Just(a.value0);throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 93, column 37 - line 95, column 44: "+[a.constructor.name]);});if(v instanceof u.Group)return d.bind(m.bindEither)(R.map(m.functorEither)(u.Group.create(v.value0)(v.value1))(n.traverse(q.traversableNonEmpty(K.traversableList))(m.applicativeEither)(g)(v.value2)))(function(a){return new m.Right(new h.Tuple(q.singleton(K.plusList)(a),
x))});if(v instanceof u.Elem){var Q=function(a){a=R.map(q.functorNonEmpty(K.functorList))(O.create)(a);return new m.Right(new h.Tuple(R.map(q.functorNonEmpty(K.functorList))(u.Elem.create)(a),f.Nothing.value))},da=function(a){return Q(q.singleton(K.plusList)(a))},I=function(a){return new m.Right(new h.Tuple(R.map(q.functorNonEmpty(K.functorList))(u.Elem.create)(a),x))},X=function(a){return I(R.map(q.functorNonEmpty(K.functorList))(O.create)(a))},T=function(a){return X(q.singleton(K.plusList)(a))},
Y=function(a){return I(q.singleton(K.plusList)(a))};if(v.value0 instanceof z.Command)return T(new E.Command(v.value0.value0,v.value0.value1));if(v.value0 instanceof z.Positional)return T(new E.Positional(v.value0.value0,v.value0.value1));if(v.value0 instanceof z.EOA)return T(E.EOA.value);if(v.value0 instanceof z.Stdin)return T(E.Stdin.value);if(v.value0 instanceof z.Reference)return Y(new D(v.value0.value0));if(v.value0 instanceof z.Option)return H(new b.Args6(x,da,T,v.value0.value0,v.value0.value1,
v.value0.value2));if(v.value0 instanceof z.OptionStack)return F(new b.Args6(x,Q,X,v.value0.value0,v.value0.value1,v.value0.value2));throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 108, column 14 - line 116, column 79: "+[v.value0.constructor.name]);}throw Error("Failed pattern match at Neodoc.Solve.ExpandOptions line 96, column 9 - line 116, column 79: "+[v.constructor.name]);}};return d.bind(m.bindEither)(n["for"](m.applicativeEither)(q.traversableNonEmpty(K.traversableList))(a.layouts)(n.traverse(K.traversableList)(m.applicativeEither)(g)))(function(b){return new m.Right(x.Spec(function(){var c=
{},d;for(d in a)({}).hasOwnProperty.call(a,d)&&(c[d]=a[d]);c.layouts=b;return c}()))})};a.genericPreSolvedLayoutArg=I;a.showPreSolvedLayoutArg=X;})(PS["Neodoc.Solve.ExpandOptions"]=PS["Neodoc.Solve.ExpandOptions"]||{});
(function(a){var b=PS["Data.Eq"],c=PS["Data.Ord"],e=PS["Data.Ordering"],d=function(){function a(){}a.value=new a;return a}(),g=function(){function a(){}a.value=new a;return a}(),k=function(){function a(){}a.value=new a;return a}(),l=function(){function a(){}a.value=new a;return a}(),h=new b.Eq(function(a){return function(b){return a instanceof d&&b instanceof d||a instanceof g&&b instanceof g||a instanceof k&&b instanceof k||a instanceof l&&b instanceof l?!0:!1}}),b=new c.Ord(function(){return h},
function(a){return function(b){if(a instanceof d&&b instanceof d)return e.EQ.value;if(a instanceof d)return e.LT.value;if(b instanceof d)return e.GT.value;if(a instanceof g&&b instanceof g)return e.EQ.value;if(a instanceof g)return e.LT.value;if(b instanceof g)return e.GT.value;if(a instanceof k&&b instanceof k)return e.EQ.value;if(a instanceof k)return e.LT.value;if(b instanceof k)return e.GT.value;if(a instanceof l&&b instanceof l)return e.EQ.value;throw Error("Failed pattern match at Neodoc.Value.Origin line 18, column 1 - line 18, column 40: "+
[a.constructor.name,b.constructor.name]);}});a.Argv=d;a.Environment=g;a.Default=k;a.Empty=l;a.weight=function(a){if(a instanceof d)return 3E4;if(a instanceof g)return 2E4;if(a instanceof k)return 1E4;if(a instanceof l)return 0;throw Error("Failed pattern match at Neodoc.Value.Origin line 31, column 1 - line 32, column 1: "+[a.constructor.name]);};a.eqOrigin=h;a.ordOrigin=b;})(PS["Neodoc.Value.Origin"]=PS["Neodoc.Value.Origin"]||{});
(function(a){var b=PS["Neodoc.Value"],c=PS["Neodoc.Value.Origin"],e=PS["Data.Eq"],d=new e.Eq(function(a){return function(d){return e.eq(c.eqOrigin)(a.origin)(d.origin)&&e.eq(b.eqValue)(a.value)(d.value)}});a.RichValue=function(a){return a};a.from=function(a){return function(b){return {value:b,origin:a}}};a.getOrigin=function(a){return a.origin};a.unRichValue=function(a){return a};a.eqRichValue=d;})(PS["Neodoc.Value.RichValue"]=PS["Neodoc.Value.RichValue"]||{});
(function(a){var b=PS["Data.Tuple"],c=PS["Data.Set"],e=PS["Data.Maybe"],d=PS["Data.List"],g=PS["Data.NonEmpty"],k=PS["Data.NonEmpty.Extra"],l=PS["Data.Foldable"],h=PS["Neodoc.Data.Layout"],f=PS["Neodoc.Data.Description"],m=PS["Neodoc.ArgKey"],n=PS["Neodoc.ArgKey.Class"],r=PS["Data.List.Types"],p=PS["Data.HeytingAlgebra"],t=PS["Data.Eq"],B=PS["Neodoc.OptionAlias"],q=PS["Data.Functor"],w=function(a){return function(b){return b instanceof m.OptionKey?d.head(d.filter(function(a){return a instanceof f.OptionDescription?
l.any(g.foldableNonEmpty(r.foldableList))(p.heytingAlgebraBoolean)(function(a){return t.eq(B.eqOptionAlias)(a)(b.value0)})(a.value0):!1})(a)):e.Nothing.value}};a.annotateLayout=function(a){return function(c){return function(d){return q.mapFlipped(h.functorLayout)(d)(function(d){return new b.Tuple(d,w(c)(n.toArgKey(a)(d)))})}}};a.findArgKeys=function(a){return function(b){var h=w(a)(b);b=h instanceof e.Just&&h.value0 instanceof f.OptionDescription?new r.Cons(b,k.toList(q.map(g.functorNonEmpty(r.functorList))(m.OptionKey.create)(h.value0.value0))):
d.singleton(b);return c.fromFoldable(r.foldableList)(m.ordArgKey)(b)}};a.findDescription=w;})(PS["Neodoc.Evaluate.Annotate"]=PS["Neodoc.Evaluate.Annotate"]||{});
(function(a){var b=PS["Data.Either"],c=PS["Data.NonEmpty"],e=PS["Neodoc.Spec"],d=PS["Neodoc.Data.SolvedLayout"],g=PS["Neodoc.Data.Layout"],k=PS["Data.List.Types"],l=PS["Data.HeytingAlgebra"],h=PS["Data.Functor"],f=PS["Control.Applicative"];a.canonicalise=function(a){var n=function(a){if(a instanceof g.Elem)return new g.Elem(a.value0);if(a instanceof g.Group&&!a.value0&&a.value2.value0.value0 instanceof g.Elem&&a.value2.value0.value1 instanceof k.Nil&&a.value2.value1 instanceof k.Nil&&(d.isPositional(a.value2.value0.value0.value0)||
d.isCommand(a.value2.value0.value0.value0)||d.isOption(a.value2.value0.value0.value0)&&l.not(l.heytingAlgebraFunction(l.heytingAlgebraBoolean))(d.isFlag)(a.value2.value0.value0.value0)&&!a.value1))return d.setRepeatableOr(a.value1)(new g.Elem(a.value2.value0.value0.value0));if(a instanceof g.Group&&a.value2.value0.value0 instanceof g.Group&&a.value2.value0.value1 instanceof k.Nil&&a.value2.value1 instanceof k.Nil)return n(new g.Group(a.value0||a.value2.value0.value0.value0,a.value1||a.value2.value0.value0.value1,
a.value2.value0.value0.value2));if(a instanceof g.Group){var b=h.mapFlipped(c.functorNonEmpty(k.functorList))(a.value2)(function(b){return b.value1 instanceof k.Nil?(b=n(b.value0),b instanceof g.Group&&b.value2.value1 instanceof k.Nil&&a.value0===b.value0&&a.value1===b.value1?b.value2.value0:new c.NonEmpty(b,k.Nil.value)):h.map(c.functorNonEmpty(k.functorList))(n)(b)});return new g.Group(a.value0,a.value1,b)}throw Error("Failed pattern match at Neodoc.Solve.Canonicalise line 81, column 3 - line 81, column 39: "+
[a.constructor.name]);},m=function(a){return h.map(c.functorNonEmpty(k.functorList))(n)(a)},p=h.map(c.functorNonEmpty(k.functorList))(function(a){return h.map(k.functorList)(m)(a)})(a.layouts);return f.pure(b.applicativeEither)(e.Spec(function(){var b={},c;for(c in a)({}).hasOwnProperty.call(a,c)&&(b[c]=a[c]);b.layouts=p;return b}()))};})(PS["Neodoc.Solve.Canonicalise"]=PS["Neodoc.Solve.Canonicalise"]||{});
(function(a){var b=PS["Data.Either"],c=PS["Data.Maybe"],e=PS["Data.NonEmpty"],d=PS["Data.NonEmpty.Extra"],g=PS["Data.Map"],k=PS["Data.List"],l=PS["Data.Foldable"],h=PS["Control.MonadPlus.Partial"],f=PS["Neodoc.Spec"],m=PS["Neodoc.Data.SolvedLayout"],n=PS["Neodoc.Data.EmptyableLayout"],r=PS["Neodoc.Data.Description"],p=PS["Neodoc.Data.Chunk"],t=PS["Neodoc.Data.Layout"],B=PS["Neodoc.Data.LayoutConversion"],q=PS["Neodoc.Data.Indexed"],w=PS["Neodoc.ArgKey.Class"],x=PS["Neodoc.Solve.ExpandOptions"],y=
PS["Data.Functor"],C=PS["Data.List.Types"],u=PS["Data.HeytingAlgebra"],A=PS["Data.Eq"],z=PS["Neodoc.ArgKey"],E=PS["Control.Bind"],F=PS["Data.Ord"],G=PS["Control.Applicative"],I=function(a){return y.mapFlipped(C.functorList)(a)(function(a){if(a.value1 instanceof x.SolvedArg)return new b.Left(a.value1.value0);if(a.value1 instanceof x.ReferenceArg)return b.Right.create(new q.Indexed(a.value0,a.value1.value0));throw Error("Failed pattern match at Neodoc.Solve.ExpandReferences line 188, column 23 - line 190, column 54: "+
[a.constructor.name]);})},v=function(a){return function(b){if(b instanceof p.Fixed)return C.Nil.value;if(b instanceof p.Free){b=I(b.value0);var d=h.mrights(C.monadPlusList)(b),f=y.map(C.functorList)(w.toArgKey(m.toArgKeySolvedLayoutArg))(h.mlefts(C.monadPlusList)(b)),g=function(a){return l.any(C.foldableList)(u.heytingAlgebraBoolean)(function(b){return A.eq(z.eqArgKey)(b)(a)})(f)};return y.mapFlipped(C.functorList)(d)(function(b){var d=k.catMaybes(y.mapFlipped(C.functorList)(a)(function(a){if(a instanceof
r.OptionDescription){var b=!l.any(e.foldableNonEmpty(C.foldableList))(u.heytingAlgebraBoolean)(function(a){return g(w.toArgKey(w.toArgKeyOptionAlias)(a))})(a.value0);if(b)return new c.Just(new m.Option(a.value0.value0,a.value2,a.value1));if(!b)return c.Nothing.value;throw Error("Failed pattern match at Neodoc.Solve.ExpandReferences line 178, column 15 - line 180, column 29: "+[b.constructor.name]);}return c.Nothing.value}));return new q.Indexed(b.value0,d)})}throw Error("Failed pattern match at Neodoc.Solve.ExpandReferences line 159, column 1 - line 159, column 30: "+
[a.constructor.name,b.constructor.name]);}},H=function(a){return p.chunk(function(a){if(a.value1 instanceof x.ReferenceArg)return !0;if(a.value1 instanceof x.SolvedArg)return m.isFreeLayout(new t.Elem(a.value1.value0));throw Error("Failed pattern match at Neodoc.Solve.ExpandReferences line 197, column 38 - line 199, column 60: "+[a.constructor.name]);})(k.fromFoldable(e.foldableNonEmpty(C.foldableList))(a))};a.chunkBranch=H;a.expandChunk=v;a.expandReferences=function(a){var h=function(b){b=B.indexBranch(b);
var d=B.flattenBranch(b),d=H(d),f=q.toMap(k.concat(k.fromFoldable(C.foldableList)(y.map(C.functorList)(v(a.descriptions))(d)))),e=function(a){if(a instanceof n.EmptyableGroup)return k.singleton(new n.EmptyableGroup(a.value0,a.value1,y.map(C.functorList)(function(a){return k.concat(function(a){return y.map(C.functorList)(e)(a)}(a))})(a.value2)));if(a instanceof n.EmptyableElem&&a.value0.value1 instanceof x.SolvedArg)return k.singleton(new n.EmptyableElem(a.value0.value1.value0));if(a instanceof n.EmptyableElem&&
a.value0.value1 instanceof x.ReferenceArg)return c.fromMaybe(C.Nil.value)(E.bind(c.bindMaybe)(g.lookup(F.ordInt)(a.value0.value0)(f))(function(a){return G.pure(c.applicativeMaybe)(y.mapFlipped(C.functorList)(a)(function(a){return new n.EmptyableGroup(!0,!1,new C.Cons(new C.Cons(new n.EmptyableElem(a),C.Nil.value),C.Nil.value))}))}));throw Error("Failed pattern match at Neodoc.Solve.ExpandReferences line 141, column 18 - line 151, column 72: "+[a.constructor.name]);};return B.toStrictBranch(k.concat(y.mapFlipped(C.functorList)(B.toEmptyableBranch(b))(e)))},
l=function(a){return y.map(C.functorList)(k.catMaybes)(a)}(d.toList(y.map(e.functorNonEmpty(C.functorList))(function(a){return y.map(C.functorList)(h)(a)})(a.layouts))),m;if(l instanceof C.Nil)m=new e.NonEmpty(C.Nil.value,C.Nil.value);else if(l instanceof C.Cons)m=new e.NonEmpty(l.value0,l.value1);else throw Error("Failed pattern match at Neodoc.Solve.ExpandReferences line 108, column 19 - line 110, column 40: "+[l.constructor.name]);return G.pure(b.applicativeEither)(f.Spec(function(){var b={},c;
for(c in a)({}).hasOwnProperty.call(a,c)&&(b[c]=a[c]);b.layouts=m;return b}()))};a.partition=I;})(PS["Neodoc.Solve.ExpandReferences"]=PS["Neodoc.Solve.ExpandReferences"]||{});
(function(a){var b=PS["Data.List"],c=PS["Data.Array"],e=PS["Data.Tuple"],d=PS["Data.Maybe"],g=PS["Data.Foldable"],k=PS["Data.Either"],l=PS["Data.NonEmpty"],h=PS["Data.Traversable"],f=PS["Neodoc.Spec"],m=PS["Neodoc.Data.Layout"],n=PS["Neodoc.Data.OptionArgument"],r=PS["Neodoc.Data.UsageLayout"],p=PS["Neodoc.Data.Description"],t=PS["Neodoc.OptionAlias"],B=PS["Data.List.Types"],q=PS["Data.HeytingAlgebra"],w=PS["Data.Eq"],x=PS["Data.Functor"],y=PS["Control.Bind"],C=PS["Control.Applicative"];a.smartOptions=
function(a){return y.bind(k.bindEither)(h["for"](k.applicativeEither)(l.traversableNonEmpty(B.traversableList))(a.layouts)(h.traverse(B.traversableList)(k.applicativeEither)(function(a){return function(f){var h=function(c){return b.filter(function(a){return a instanceof p.OptionDescription?g.any(l.foldableNonEmpty(B.foldableList))(q.heytingAlgebraBoolean)(function(a){return w.eq(t.eqOptionAlias)(a)(c)})(a.value0):!1})(a)};return C.pure(k.applicativeEither)(x.map(l.functorNonEmpty(B.functorList))(function(a){return a instanceof
m.Group?m.Group.create(a.value0)(a.value1)(x.mapFlipped(l.functorNonEmpty(B.functorList))(a.value2)(function(a){return a.value1 instanceof B.Cons&&a.value1.value1 instanceof B.Nil?d.fromMaybe(a)(y.bind(d.bindMaybe)(a.value1.value0 instanceof m.Group&&a.value1.value0.value2.value0.value1 instanceof B.Nil&&a.value1.value0.value2.value1 instanceof B.Nil?a.value1.value0.value2.value0.value0 instanceof m.Elem&&a.value1.value0.value2.value0.value0.value0 instanceof r.Command||a.value1.value0.value2.value0.value0 instanceof
m.Elem&&a.value1.value0.value2.value0.value0.value0 instanceof r.Positional?d.Just.create(new e.Tuple(new n.OptionArgument(a.value1.value0.value2.value0.value0.value0.value0,a.value1.value0.value0),a.value1.value0.value2.value0.value0.value0.value1||a.value1.value0.value1)):d.Nothing.value:a.value1.value0 instanceof m.Elem&&a.value1.value0.value0 instanceof r.Command||a.value1.value0 instanceof m.Elem&&a.value1.value0.value0 instanceof r.Positional?d.Just.create(new e.Tuple(new n.OptionArgument(a.value1.value0.value0.value0,
!1),a.value1.value0.value0.value1)):d.Nothing.value)(function(f){return y.bind(d.bindMaybe)(function(){if(a.value0 instanceof m.Elem&&a.value0.value0 instanceof r.Option&&a.value0.value0.value1 instanceof d.Nothing){var g=!b["null"](h(new t.Long(a.value0.value0.value0)));if(g)return d.Nothing.value;if(!g)return d.Just.create(new r.Option(a.value0.value0.value0,new d.Just(f.value0),a.value0.value0.value2||f.value1));throw Error("Failed pattern match at Neodoc.Solve.SmartOptions line 74, column 17 - line 76, column 60: "+
[g.constructor.name]);}if(a.value0 instanceof m.Elem&&a.value0.value0 instanceof r.OptionStack&&a.value0.value0.value1 instanceof d.Nothing){g=new e.Tuple(c.last(a.value0.value0.value0.value1),c.init(a.value0.value0.value0.value1));g=g.value0 instanceof d.Just&&g.value1 instanceof d.Just?g.value0.value0:a.value0.value0.value0.value0;if(g=!b["null"](h(new t.Short(g))))return d.Nothing.value;if(!g)return d.Just.create(new r.OptionStack(new l.NonEmpty(a.value0.value0.value0.value0,a.value0.value0.value0.value1),
new d.Just(f.value0),a.value0.value0.value2||f.value1));throw Error("Failed pattern match at Neodoc.Solve.SmartOptions line 87, column 17 - line 89, column 73: "+[g.constructor.name]);}return d.Nothing.value}())(function(a){return C.pure(d.applicativeMaybe)(new l.NonEmpty(new m.Elem(a),B.Nil.value))})})):a})):a})(f))}}(a.descriptions))))(function(b){return C.pure(k.applicativeEither)(f.Spec(function(){var c={},d;for(d in a)({}).hasOwnProperty.call(a,d)&&(c[d]=a[d]);c.layouts=b;return c}()))})};})(PS["Neodoc.Solve.SmartOptions"]=
PS["Neodoc.Solve.SmartOptions"]||{});
(function(a){var b=PS["Data.List"],c=PS["Neodoc.Solve.Canonicalise"],e=PS["Neodoc.Solve.ExpandOptions"],d=PS["Neodoc.Solve.ExpandReferences"],g=PS["Neodoc.Solve.SmartOptions"],k=PS["Data.Either"],l=PS["Control.Bind"],h=PS["Control.Applicative"],f=PS["Data.Function"],m=PS["Data.List.Types"],n=function(a){return function(m){return function(n){var p=l.composeKleisli(k.bindEither),q;if(a.smartOptions)q=g.smartOptions;else {if(a.smartOptions)throw Error("Failed pattern match at Neodoc.Solve line 35, column 8 - line 35, column 57: "+[a.smartOptions.constructor.name]);
q=h.pure(k.applicativeEither);}return p(q)(l.composeKleisli(k.bindEither)(f.flip(b.foldM(k.monadEither)(f.applyFlipped))(m))(l.composeKleisli(k.bindEither)(e.expandOptions)(l.composeKleisli(k.bindEither)(d.expandReferences)(l.composeKleisli(k.bindEither)(c.canonicalise)(f.flip(b.foldM(k.monadEither)(f.applyFlipped))(n))))))}}};a.solve=function(a){return n(a)(m.Nil.value)(m.Nil.value)};a["solve'"]=n;})(PS["Neodoc.Solve"]=PS["Neodoc.Solve"]||{});
(function(a){var b=PS["Data.List"],c=PS["Data.NonEmpty"],e=PS["Data.NonEmpty.Extra"],d=PS["Neodoc.Spec"],g=PS["Neodoc.Data.LayoutConversion"],k=PS["Data.Functor"],l=PS["Data.List.Types"];a.fromEmptyableSpec=function(a){var d=k.mapFlipped(c.functorNonEmpty(l.functorList))(a.layouts)(function(a){return b.catMaybes(k.mapFlipped(l.functorList)(a)(function(a){return e.fromList(b.catMaybes(e.toList(k.map(c.functorNonEmpty(l.functorList))(g.toStrictLayout)(a))))}))}),h={},n;for(n in a)({}).hasOwnProperty.call(a,
n)&&(h[n]=a[n]);h.layouts=d;return h};a.toEmptyableSpec=function(a){var b=k.map(c.functorNonEmpty(l.functorList))(function(a){return k.map(l.functorList)(function(a){return k.map(c.functorNonEmpty(l.functorList))(g.toEmptyableLayout)(a)})(a)})(a.layouts);return d.Spec(function(){var c={},d;for(d in a)({}).hasOwnProperty.call(a,d)&&(c[d]=a[d]);c.layouts=b;return c}())};})(PS["Neodoc.SpecConversions"]=PS["Neodoc.SpecConversions"]||{});
(function(a){var b=PS["Data.Foreign.Class"],c=PS["Control.Monad.Eff"],e=PS["Neodoc.Spec"],d=PS["Neodoc.Data.EmptyableLayout"],g=PS["Neodoc.Data.UsageLayout"],k=PS["Neodoc.Data.SolvedLayout"],l=PS["Neodoc.OptionAlias"],h=PS["Unsafe.Coerce"],f=PS["Data.Foreign"],m=PS["Data.Foreign.Extra"],n=PS["Data.Foreign.Index"],r=PS["Control.Monad.Eff.Exception"],p=PS["Control.Monad.Except"],t=PS["Data.Either"],B=PS["Data.Maybe"],q=PS["Neodoc.Env"],w=PS["Neodoc.SpecConversions"],x=PS["Control.Bind"],y=PS["Control.Applicative"],
C=PS["Data.Functor"],u=PS["Data.Show"],A=PS["Control.Apply"],z=PS["Control.Monad.Except.Trans"],E=PS["Data.Identity"],F=PS["Data.List.Types"],G=function(a){return a},I={argv:B.Nothing.value,env:B.Nothing.value,optionsFirst:!1,dontExit:!1,smartOptions:!1,stopAt:[],requireFlags:!1,laxPlacement:!1,version:B.Nothing.value,versionFlags:[new l.Long("version")],helpFlags:[new l.Short("h"),new l.Long("help")],transforms:{presolve:new t.Right([]),postsolve:new t.Right([])},repeatableOptions:!1,allowUnknown:!1},
v=new b.IsForeign(function(a){var v=m.readPropMaybe(b.arrayIsForeign(b.stringIsForeign))(n.indexString)("argv"),J=m.readPropMaybe(b.stringIsForeign)(n.indexString)("version"),K=function(a){return function(b){return function(c){return C.map(z.functorExceptT(E.functorIdentity))(m.isTruthy)(m.defaultIfUndefined(m.isForeignTruthy)(n.indexString)(a)(m.truthy(b))(c))}}},H=K("allowUnknown")(I.allowUnknown),R=K("dontExit")(I.dontExit),P=K("laxPlacement")(I.laxPlacement),N=K("optionsFirst")(I.optionsFirst),
O=K("repeatableOptions")(I.repeatableOptions),D=K("requireFlags")(I.requireFlags),K=K("smartOptions")(I.smartOptions),M=m.defaultIfUndefined(b.arrayIsForeign(l.isForeignOptionAlias))(n.indexString)("helpFlags")(I.helpFlags),U=m.defaultIfUndefined(b.arrayIsForeign(b.stringIsForeign))(n.indexString)("stopAt")(I.stopAt),X=m.defaultIfUndefined(b.arrayIsForeign(l.isForeignOptionAlias))(n.indexString)("versionFlags")(I.versionFlags);return C.map(z.functorExceptT(E.functorIdentity))(G)(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(A.apply(z.applyExceptT(E.monadIdentity))(C.map(z.functorExceptT(E.functorIdentity))(function(a){return function(b){return function(c){return function(d){return function(f){return function(e){return function(g){return function(h){return function(k){return function(l){return function(m){return function(n){return function(p){return function(q){return {argv:a,
env:b,optionsFirst:c,dontExit:d,smartOptions:f,stopAt:e,requireFlags:g,laxPlacement:h,version:k,versionFlags:l,helpFlags:m,transforms:n,repeatableOptions:p,allowUnknown:q}}}}}}}}}}}}}}})(v(a)))(function(a){return C.map(z.functorExceptT(E.functorIdentity))(function(a){return C.map(B.functorMaybe)(q.unwrapEnv)(a)})(m.readPropMaybe(q.isForeignEnvWrapper)(n.indexString)("env")(a))}(a)))(N(a)))(R(a)))(K(a)))(U(a)))(D(a)))(P(a)))(J(a)))(X(a)))(M(a)))(function(a){var l=function(a){return x.bind(z.bindExceptT(E.monadIdentity))(m.defaultIfUndefined(b.arrayIsForeign(b.foreignIsForeign))(n.indexString)("presolve")([])(a))(function(a){return y.pure(z.applicativeExceptT(E.monadIdentity))(t.Left.create(C.mapFlipped(C.functorArray)(a)(function(a){return function(k){k=
h.unsafeCoerce(a)(b.write(e.asForeignOptionAlias(d.asForeignEmptyableLayout(g.asForeignUsageLayoutArg)))(w.toEmptyableSpec(k)));k=C.map(t.functorEither)(w.fromEmptyableSpec)(p.runExcept(b.read(e.isForeignOptionAlias(d.isForeignEmptyableLayout(g.isForeignUsageLayoutArg)))(k)));if(k instanceof t.Left)return r.throwException(r.error(u.show(F.showNonEmptyList(f.showForeignError))(k.value0)));if(k instanceof t.Right)return y.pure(c.applicativeEff)(k.value0);throw Error("Failed pattern match at Neodoc.Options line 140, column 17 - line 142, column 36: "+
[k.constructor.name]);}})))})},q=function(a){return x.bind(z.bindExceptT(E.monadIdentity))(m.defaultIfUndefined(b.arrayIsForeign(b.foreignIsForeign))(n.indexString)("postsolve")([])(a))(function(a){return y.pure(z.applicativeExceptT(E.monadIdentity))(t.Left.create(C.mapFlipped(C.functorArray)(a)(function(a){return function(g){g=h.unsafeCoerce(a)(b.write(e.asForeignOptionAlias(d.asForeignEmptyableLayout(k.asForeignSolvedLayoutArg)))(w.toEmptyableSpec(g)));g=C.map(t.functorEither)(w.fromEmptyableSpec)(p.runExcept(b.read(e.isForeignOptionAlias(d.isForeignEmptyableLayout(k.isForeignSolvedLayoutArg)))(g)));
if(g instanceof t.Left)return r.throwException(r.error(u.show(F.showNonEmptyList(f.showForeignError))(g.value0)));if(g instanceof t.Right)return y.pure(c.applicativeEff)(g.value0);throw Error("Failed pattern match at Neodoc.Options line 149, column 17 - line 151, column 36: "+[g.constructor.name]);}})))})};return x.bind(z.bindExceptT(E.monadIdentity))(m.defaultIfUndefined(b.foreignIsForeign)(n.indexString)("transforms")(f.toForeign({}))(a))(function(a){return A.apply(z.applyExceptT(E.monadIdentity))(C.map(z.functorExceptT(E.functorIdentity))(function(a){return function(b){return {presolve:a,
postsolve:b}}})(l(a)))(q(a))})}(a)))(O(a)))(H(a)))});a.NeodocOptions=G;a.defaultOptionsObj=I;a.isForeign=v;})(PS["Neodoc.Options"]=PS["Neodoc.Options"]||{});(function(a){var b=PS["Neodoc.Error"],c=new PS["Neodoc.Error.Class"].ToNeodocError(function(a){return new b.ScanError(a)});a.ScanError=function(a){return a};a.toNeodocErrorScanError=c;})(PS["Neodoc.Scanner.Error"]=PS["Neodoc.Scanner.Error"]||{});
(function(a){var b=PS["Data.Bifunctor"],c=PS["Data.List"],e=PS["Data.String.Regex"],d=PS["Data.String.Regex.Flags"],g=PS["Data.String"],k=PS["Data.String.Yarn"],l=PS["Data.Maybe"],h=PS["Data.Either"],f=PS["Data.String.Regex.AnsiRegex"],m=PS["Neodoc.Scanner.Error"],n=PS["Data.Function"],r=PS["Data.List.Types"],p=PS["Data.Foldable"],t=PS["Control.Bind"],B=PS["Control.Applicative"],q=PS["Data.Functor"],w=function(a){return h.fromRight()(e.regex("^([^\n]*"+(a+"[^\n]*:(?:.*$)\n?(?:(?:[ \t].*)?(?:\n|$))*)"))(e.parseFlags("gmi")))},
x=function(){var a=function(a){return n.flip(e["replace'"])(function(b){return function(c){return l.maybe("")(k.replicate(g.length(b)))(a)}})},b=a(new l.Just(" "))(f.regex),c=a(new l.Just(" "))(h.fromRight()(e.regex("(^[^:]+:)")(d.noFlags)));return function(a){return c(b(a))}}();a.scan=function(a){var d=function(b){return l.maybe(r.Nil.value)(function(a){return c.catMaybes(c.fromFoldable(p.foldableArray)(a))})(e.match(w(b))(a))};return b.lmap(h.bifunctorEither)(m.ScanError)(t.bind(h.bindEither)(function(){var a=
d("usage");return a instanceof r.Nil?new h.Left("No usage section found!"):a instanceof r.Cons&&a.value1 instanceof r.Nil?B.pure(h.applicativeEither)(a.value0):new h.Left("Multiple usage sections found!")}())(function(a){return B.pure(h.applicativeEither)({usage:x(a),options:q.map(r.functorList)(x)(d("options")),originalUsage:g.trim(a)})}))};})(PS["Neodoc.Scanner"]=PS["Neodoc.Scanner"]||{});
(function(a){var b=PS["Neodoc.Error"],c=new PS["Neodoc.Error.Class"].ToNeodocError(function(a){return new b.SpecParseError(a)});a.SpecParseError=function(a){return a};a.toNeodocErrorSpecParseError=c;})(PS["Neodoc.Spec.Error"]=PS["Neodoc.Spec.Error"]||{});
(function(a){var b=PS["Data.Pretty"],c=PS["Data.Array"],e=PS["Data.String"],d=PS["Data.Maybe"],g=PS["Data.Show"],k=PS["Data.Functor"],l=PS["Data.Eq"],h=PS["Control.Bind"],f=PS["Control.Applicative"],m=function(){function a(){}a.value=new a;return a}(),n=function(){function a(){}a.value=new a;return a}(),r=function(){function a(){}a.value=new a;return a}(),p=function(){function a(){}a.value=new a;return a}(),t=function(){function a(){}a.value=new a;return a}(),B=function(){function a(){}a.value=new a;
return a}(),q=function(){function a(){}a.value=new a;return a}(),w=function(){function a(){}a.value=new a;return a}(),x=function(){function a(){}a.value=new a;return a}(),y=function(){function a(){}a.value=new a;return a}(),C=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),u=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),A=function(){function a(a,b){this.value0=a;this.value1=b;}
a.create=function(b){return function(c){return new a(b,c)}};return a}(),z=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),E=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),F=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),G=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),I=function(){function a(a){this.value0=
a;}a.create=function(b){return new a(b)};return a}(),v=function(){function a(){}a.value=new a;return a}(),H=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),b=new b.Pretty(function(a){if(a instanceof m)return g.show(g.showChar)("(");if(a instanceof n)return g.show(g.showChar)(")");if(a instanceof r)return g.show(g.showChar)("[");if(a instanceof p)return g.show(g.showChar)("]");if(a instanceof t)return g.show(g.showChar)("-");
if(a instanceof B)return g.show(g.showChar)("|");if(a instanceof x)return g.show(g.showChar)("\n");if(a instanceof q)return g.show(g.showChar)(":");if(a instanceof w)return g.show(g.showChar)(",");if(a instanceof y)return "...";if(a instanceof v)return "--";if(a instanceof C)return "Reference "+g.show(g.showString)(a.value0);if(a instanceof I)return "Garbage "+g.show(g.showChar)(a.value0);if(a instanceof z)return "Tag "+(g.show(g.showString)(a.value0)+(" "+g.show(g.showString)(a.value1)));if(a instanceof
E)return "Name "+g.show(g.showString)(a.value0);if(a instanceof F)return "ShoutName "+g.show(g.showString)(a.value0);if(a instanceof G)return "AngleName "+g.show(g.showString)(a.value0);if(a instanceof u){var b=d.fromMaybe("")(k.mapFlipped(d.functorMaybe)(a.value1)(function(a){if(a.optional)return "[";if(!a.optional){var b=a.name;if(a.optional)a="]";else {if(a.optional)throw Error("Failed pattern match at Neodoc.Spec.Token line 77, column 26 - line 78, column 3: "+[a.optional.constructor.name]);a="";}return ""+
(b+a)}throw Error("Failed pattern match at Neodoc.Spec.Token line 75, column 21 - line 78, column 3: "+[a.optional.constructor.name]);}));return "--"+(a.value0+b)}if(a instanceof A){var f=e.fromCharArray(c.cons(a.value0.value0)(a.value0.value1)),b=d.fromMaybe("")(k.mapFlipped(d.functorMaybe)(a.value1)(function(a){if(a.optional)return "[";if(!a.optional){var b=a.name;if(a.optional)a="]";else {if(a.optional)throw Error("Failed pattern match at Neodoc.Spec.Token line 84, column 26 - line 86, column 1: "+
[a.optional.constructor.name]);a="";}return ""+(b+a)}throw Error("Failed pattern match at Neodoc.Spec.Token line 82, column 21 - line 86, column 1: "+[a.optional.constructor.name]);}));return "-"+(f+b)}throw Error("Failed pattern match at Neodoc.Spec.Token line 55, column 3 - line 56, column 3: "+[a.constructor.name]);}),L=new l.Eq(function(a){return function(b){return a instanceof m&&b instanceof m||a instanceof n&&b instanceof n||a instanceof r&&b instanceof r||a instanceof p&&b instanceof p||a instanceof
B&&b instanceof B||a instanceof q&&b instanceof q||a instanceof w&&b instanceof w||a instanceof t&&b instanceof t||a instanceof v&&b instanceof v||a instanceof y&&b instanceof y||a instanceof x&&b instanceof x?!0:a instanceof C&&b instanceof C?a.value0===b.value0:a instanceof u&&b instanceof u?a.value0===b.value0&&(d.isNothing(a.value1)&&d.isNothing(b.value1)||d.fromMaybe(!1)(h.bind(d.bindMaybe)(a.value1)(function(a){return h.bind(d.bindMaybe)(b.value1)(function(b){return f.pure(d.applicativeMaybe)(a.name===
b.name&&a.optional===b.optional)})}))):a instanceof A&&b instanceof A?a.value0.value0===b.value0.value0&&l.eq(l.eqArray(l.eqChar))(a.value0.value1)(b.value0.value1)&&(d.isNothing(a.value1)&&d.isNothing(b.value1)||d.fromMaybe(!1)(h.bind(d.bindMaybe)(a.value1)(function(a){return h.bind(d.bindMaybe)(b.value1)(function(b){return f.pure(d.applicativeMaybe)(a.name===b.name&&a.optional===b.optional)})}))):a instanceof G&&b instanceof G||a instanceof F&&b instanceof F||a instanceof E&&b instanceof E||a instanceof
I&&b instanceof I?a.value0===b.value0:!1}});a.PositionedToken=H;a.LParen=m;a.RParen=n;a.LSquare=r;a.RSquare=p;a.Dash=t;a.VBar=B;a.Colon=q;a.Comma=w;a.Newline=x;a.TripleDot=y;a.Reference=C;a.LOpt=u;a.SOpt=A;a.Tag=z;a.Name=E;a.ShoutName=F;a.AngleName=G;a.Garbage=I;a.DoubleDash=v;a.prettyToken=b;a.eqToken=L;})(PS["Neodoc.Spec.Token"]=PS["Neodoc.Spec.Token"]||{});
(function(a){var b=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),c=new b(0,0);a.ParserState=b;a.getIndentation=function(a){return a.value0};a.initialState=c;a.setIndentation=function(a){return function(c){return new b(a,c.value1)}};})(PS["Neodoc.Spec.ParserState"]=PS["Neodoc.Spec.ParserState"]||{});
(function(a){var b=PS["Data.Pretty"],c=PS["Data.Bifunctor"],e=PS["Data.Maybe"],d=PS["Data.Either"],g=PS["Data.String.Ext"],k=PS["Data.Optimize.Uncurried"],l=PS["Control.Lazy"],h=PS["Control.Alt"],f=PS["Neodoc.Spec.Token"],m=PS["Neodoc.Spec.ParserState"],n=PS["Neodoc.Parsing.Parser"],r=PS["Neodoc.Parsing.Parser.Combinators"],p=PS["Data.List.Types"],t=PS["Control.Category"],B=PS["Data.Unit"],q=PS["Control.MonadZero"],w=PS["Data.Eq"],x=PS["Control.Bind"],y=PS["Control.Applicative"],C=function(a){return new n.Parser(function(b){if(b.value3 instanceof
p.Cons){var c=a(b.value3.value0.value1);if(c instanceof e.Just){if(!(b.value3.value1 instanceof p.Cons||b.value3.value1 instanceof p.Nil))throw Error("Failed pattern match at Neodoc.Spec.TokenParser line 55, column 25 - line 57, column 28: "+[b.value3.value1.constructor.name]);return new n.Step(!0,n.setI(b.value3.value1)(b),new d.Right(c.value0))}return new n.Step(!1,b,new d.Left(n.error("Token did not match predicate")))}return new n.Step(!1,b,new d.Left(n.error("Expected token, but met EOF")))})},
u=function(){return r.asErrorMessage("short-option")(C(function(a){return a instanceof f.SOpt?new e.Just({chars:a.value0,arg:a.value1}):e.Nothing.value}))}(),A=function(){return r.asErrorMessage("NAME")(C(function(a){return a instanceof f.ShoutName?new e.Just(a.value0):e.Nothing.value}))}(),z=function(){return r.asErrorMessage("reference")(C(function(a){return a instanceof f.Reference?new e.Just(a.value0):e.Nothing.value}))}(),E=function(){return r.asErrorMessage("name")(C(function(a){return a instanceof
f.Name?new e.Just(a.value0):e.Nothing.value}))}(),F=function(a){return h.alt(n.altParser)(C(function(b){var c=q.guard(e.monadZeroMaybe);b=w.eq(f.eqToken)(b)(a);return c(b)}))(l.defer(n.lazyParser)(function(c){return n.fail("Expected "+b.pretty(f.prettyToken)(a))}))},G=F(f.Newline.value),I=F(f.RParen.value),v=F(f.RSquare.value),H=F(f.TripleDot.value),L=F(f.VBar.value),J=F(f.LSquare.value),K=F(f.LParen.value),S=function(){return r.asErrorMessage("long-option")(C(function(a){return a instanceof f.LOpt?
new e.Just({name:a.value0,arg:a.value1}):e.Nothing.value}))}(),x=x.bind(n.bindParser)(n.getInput)(function(a){return a instanceof p.Cons?n.fail("Expected EOF"):y.pure(n.applicativeParser)(B.unit)}),R=F(f.DoubleDash.value),P=F(f.Dash.value),N=F(f.Comma.value),O=F(f.Colon.value),D=C(e.Just.create),M=function(){return r.asErrorMessage("\x3cname\x3e")(C(function(a){return a instanceof f.AngleName?new e.Just(a.value0):e.Nothing.value}))}();a.angleName=M;a.anyToken=D;a.colon=O;a.comma=N;a.dash=P;a.doubleDash=
R;a.eof=x;a.lopt=S;a.lparen=K;a.lsquare=J;a.match=F;a.name=E;a.newline=G;a.reference=z;a.rparen=I;a.rsquare=v;a.runTokenParser=function(a){return function(b){return c.lmap(d.bifunctorEither)(n.extractError(t.id(t.categoryFn)))(n.runParser(new k.Args5(B.unit,m.initialState,B.unit,a,b)))}};a.shoutName=A;a.sopt=u;a.tag=function(a){return r.asErrorMessage(g.concat("tag: ")(a))(C(function(b){return b instanceof f.Tag&&g.upperCaseEq(b.value0)(a)?new e.Just(b.value1):e.Nothing.value}))};a.token=C;a.tripleDot=
H;a.vbar=L;})(PS["Neodoc.Spec.TokenParser"]=PS["Neodoc.Spec.TokenParser"]||{});(function(a){a.trimDescSection=function(a){a="\n"+a;for(var b=/(.*(--?\S* *(((?!\[default *:|\[env *:)\S*) *(\.{3})?)?)|(^\s*)?\[(default|env): ("(?:[^"\\]|\\.)*"\s*|.*)*\])/gmi,e="",d;null!==(d=b.exec(a));)d.index===b.lastIndex&&b.lastIndex++,e="["!==d[0][0]?e+"\n":e+" ",e+=d[0];return e};})(PS["Neodoc.Spec.Lexer"]=PS["Neodoc.Spec.Lexer"]||{});
(function(a){var b=PS["Neodoc.Spec.Lexer"],c=PS["Data.Array"],e=PS["Data.Bifunctor"],d=PS["Data.NonEmpty"],g=PS["Data.List"],k=PS["Data.Monoid"],l=PS["Data.Functor"],h=PS["Data.Optimize.Uncurried"],f=PS["Control.Alt"],m=PS["Control.Apply"],n=PS["Control.Lazy"],r=PS["Data.Either"],p=PS["Data.Foldable"],t=PS["Data.Maybe"],B=PS["Data.String"],q=PS["Data.String.Regex"],w=PS["Data.String.Ext"],x=PS["Neodoc.Spec.Token"],y=PS["Neodoc.Spec.Error"],C=PS["Neodoc.Parsing.Parser.Pos"],u=PS["Neodoc.Parsing.Parser"],
A=PS["Neodoc.Parsing.Parser.String"],z=PS["Neodoc.Parsing.Parser.Combinators"],E=PS["Control.Bind"],F=PS["Data.Unit"],G=PS["Data.List.Types"],I=PS["Control.Applicative"],v=PS["Control.Category"],H=function(){function a(){}a.value=new a;return a}(),L=function(){function a(){}a.value=new a;return a}(),J=l["void"](u.functorParser)(A.oneOf(["\n","\r"," ","\t"])),K=f.alt(u.altParser)(E.bind(u.bindParser)(A.satisfy(function(a){return "\n"===a||"\r"===a||" "===a||"\t"===a}))(function(){return K}))(u["return"](F.unit)),
S=r.fromRight()(q.regex("\\[(([^\\]](?!\\s*-?\\s*options\\s*))*?.?)\\s*-?\\s*options\\s*(\\.\\.\\.)?\\s*\\]")(q.parseFlags("gmi"))),R=r.fromRight()(q.regex("[a-zA-Z]")(q.parseFlags("gi"))),P=f.alt(u.altParser)(A.alphaNum)(A.oneOf(["_","-"])),N=z.between(A["char"]("["))(A["char"]("]"))(E.bind(u.bindParser)(l.map(u.functorParser)(function(a){return B.trim(p.foldMap(G.foldableList)(k.monoidString)(B.singleton)(a))})(g.some(u.alternativeParser)(u.lazyParser)(A.noneOf(["]"]))))(function(a){a=c.uncons(B.split(":")(a));
if(a instanceof t.Nothing||a instanceof t.Just&&0===c.length(a.value0.tail))return u.fail("Expected label");if(a instanceof t.Just){var b=B.trim(B.joinWith(":")(a.value0.tail));return u["return"](new x.Tag(a.value0.head,b))}throw Error("Failed pattern match at Neodoc.Spec.Lexer line 203, column 3 - line 208, column 29: "+[a.constructor.name]);})),O=n.defer(u.lazyParser)(function(a){return E.bind(u.bindParser)(A["char"]("-"))(function(){return E.bind(u.bindParser)(f.alt(u.altParser)(A.eof)(z.lookAhead(z.choice(p.foldableArray)([l["void"](u.functorParser)(J),
l["void"](u.functorParser)(A["char"]("|")),l["void"](u.functorParser)(A["char"]("]")),l["void"](u.functorParser)(A["char"](")")),l["void"](u.functorParser)(A.string("..."))]))))(function(){return u["return"](x.Dash.value)})})}),D=l.map(u.functorParser)(x.Reference.create)(E.bind(u.bindParser)(A["char"]("@"))(function(){return l.map(u.functorParser)(p.foldMap(G.foldableList)(k.monoidString)(B.singleton))(z.many(A.noneOf([" ","\n"])))})),M=n.defer(u.lazyParser)(function(a){return E.bind(u.bindParser)(A.string("--"))(function(){return E.bind(u.bindParser)(f.alt(u.altParser)(A.eof)(z.lookAhead(z.choice(p.foldableArray)([l["void"](u.functorParser)(J),
l["void"](u.functorParser)(A["char"]("]")),l["void"](u.functorParser)(A["char"](")"))]))))(function(){return u["return"](x.DoubleDash.value)})})}),U=m.apply(u.applyParser)(l.map(u.functorParser)(w.concat)(l.map(u.functorParser)(B.singleton)(A.alphaNum)))(z.manyChar(z.choice(p.foldableArray)([P,A.oneOf(["-","_","/"]),z["try"](m.applyFirst(u.applyParser)(A["char"]("."))(z.notFollowedBy(A.string(".."))))]))),X=E.bind(u.bindParser)(U)(function(a){return u["return"](function(){var b=B.toUpper(a)===a&&
q.test(R)(a);if(b)return new x.ShoutName(a);if(!b)return new x.Name(a);throw Error("Failed pattern match at Neodoc.Spec.Lexer line 153, column 12 - line 155, column 24: "+[b.constructor.name]);}())}),T=E.bind(u.bindParser)(A["char"]("\x3c"))(function(){return E.bind(u.bindParser)(z.someChar(z.choice(p.foldableArray)([P,A.noneOf(["\x3c","\x3e"])])))(function(a){return E.bind(u.bindParser)(A["char"]("\x3e"))(function(){return u["return"](w.concat(w.concat("\x3c")(a))("\x3e"))})})}),ca=n.defer(u.lazyParser)(function(a){return E.bind(u.bindParser)(A.string("--"))(function(){return E.bind(u.bindParser)(m.apply(u.applyParser)(l.map(u.functorParser)(w.concat)(l.map(u.functorParser)(B.singleton)(A.alphaNum)))(z.manyChar(z.choice(p.foldableArray)([A.alphaNum,
z["try"](m.applyFirst(u.applyParser)(m.applyFirst(u.applyParser)(A["char"]("."))(z.notFollowedBy(A.string(".."))))(z.lookAhead(A.alphaNum))),m.applyFirst(u.applyParser)(A.oneOf(["-","/"]))(z.lookAhead(A.alphaNum))]))))(function(a){return E.bind(u.bindParser)(z.option(t.Nothing.value)(l.map(u.functorParser)(t.Just.create)(E.bind(u.bindParser)(z.option(!1)(l.voidLeft(u.functorParser)(A["char"]("["))(!0)))(function(a){var b=E.bind(u.bindParser),c;if(a)c=z.optional(A["char"]("\x3d"));else {if(a)throw Error("Failed pattern match at Neodoc.Spec.Lexer line 274, column 5 - line 276, column 5: "+
[a.constructor.name]);c=l["void"](u.functorParser)(A["char"]("\x3d"));}return b(c)(function(){return E.bind(u.bindParser)(z.choice(p.foldableArray)([T,U]))(function(b){return E.bind(u.bindParser)(I.when(u.applicativeParser)(a)(l["void"](u.functorParser)(A["char"]("]"))))(function(){return u["return"]({name:b,optional:a})})})})}))))(function(b){return E.bind(u.bindParser)(f.alt(u.altParser)(A.eof)(z.lookAhead(z.choice(p.foldableArray)([l["void"](u.functorParser)(J),l["void"](u.functorParser)(A.oneOf(["]",
")",",","|"])),l["void"](u.functorParser)(A.string("..."))]))))(function(){return u["return"](new x.LOpt(a,b))})})})})}),da=n.defer(u.lazyParser)(function(a){var b=f.alt(u.altParser)(A.alphaNum)(A.oneOf(["?"]));return E.bind(u.bindParser)(A["char"]("-"))(function(){return E.bind(u.bindParser)(b)(function(a){return E.bind(u.bindParser)(l.map(u.functorParser)(c.fromFoldable(G.foldableList))(z.many(b)))(function(b){return E.bind(u.bindParser)(z.option(t.Nothing.value)(l.map(u.functorParser)(t.Just.create)(z.choice(p.foldableArray)([E.bind(u.bindParser)(z.option(!1)(l.voidLeft(u.functorParser)(A["char"]("["))(!0)))(function(a){var b=
E.bind(u.bindParser),c;if(a)c=z.optional(A["char"]("\x3d"));else {if(a)throw Error("Failed pattern match at Neodoc.Spec.Lexer line 236, column 7 - line 238, column 7: "+[a.constructor.name]);c=l["void"](u.functorParser)(A["char"]("\x3d"));}return b(c)(function(){return E.bind(u.bindParser)(z.choice(p.foldableArray)([T,U]))(function(b){return E.bind(u.bindParser)(I.when(u.applicativeParser)(a)(l["void"](u.functorParser)(A["char"]("]"))))(function(){return u["return"]({name:b,optional:a})})})})}),E.bind(u.bindParser)(T)(function(a){return u["return"]({name:a,
optional:!1})})]))))(function(c){return E.bind(u.bindParser)(f.alt(u.altParser)(A.eof)(z.lookAhead(z.choice(p.foldableArray)([l["void"](u.functorParser)(J),l["void"](u.functorParser)(A.oneOf(["]",")",",","|"])),l["void"](u.functorParser)(A.string("..."))]))))(function(){return u["return"](new x.SOpt(new d.NonEmpty(a,b),c))})})})})})}),Q=n.defer(u.lazyParser)(function(a){return m.applyFirst(u.applyParser)(z.choice(p.foldableArray)([l.voidLeft(u.functorParser)(A["char"](","))(x.Comma.value),l.voidLeft(u.functorParser)(A["char"]("("))(x.LParen.value),
l.voidLeft(u.functorParser)(A["char"](")"))(x.RParen.value),l.voidLeft(u.functorParser)(A["char"]("]"))(x.RSquare.value),l.voidLeft(u.functorParser)(A.string("..."))(x.TripleDot.value),l.voidLeft(u.functorParser)(A.eol)(x.Newline.value),D,z["try"](ca),z["try"](da),l.map(u.functorParser)(x.AngleName.create)(T),X,z["try"](N),l.voidLeft(u.functorParser)(A["char"]("["))(x.LSquare.value),l.map(u.functorParser)(x.Garbage.create)(A.anyChar)]))(A.spaces)}),Y=n.defer(u.lazyParser)(function(a){return m.applyFirst(u.applyParser)(z.choice(p.foldableArray)([l.voidLeft(u.functorParser)(A["char"]("("))(x.LParen.value),
l.voidLeft(u.functorParser)(A["char"](")"))(x.RParen.value),l.voidLeft(u.functorParser)(A["char"]("]"))(x.RSquare.value),l.voidLeft(u.functorParser)(A["char"]("|"))(x.VBar.value),l.voidLeft(u.functorParser)(A["char"](":"))(x.Colon.value),l.voidLeft(u.functorParser)(A["char"](","))(x.Comma.value),l.voidLeft(u.functorParser)(A.string("..."))(x.TripleDot.value),l.voidLeft(u.functorParser)(A["char"]("["))(x.LSquare.value),D,z["try"](ca),z["try"](da),z["try"](M),O,l.map(u.functorParser)(x.AngleName.create)(T),
X]))(K)}),W=function(a){var b;if(a instanceof H)b=Y;else if(a instanceof L)b=Q;else throw Error("Failed pattern match at Neodoc.Spec.Lexer line 92, column 19 - line 94, column 58: "+[a.constructor.name]);return E.bind(u.bindParser)(K)(function(){return E.bind(u.bindParser)(z.many(m.apply(u.applyParser)(l.map(u.functorParser)(x.PositionedToken.create)(A.getPosition))(b)))(function(a){return E.bind(u.bindParser)(f.alt(u.altParser)(A.eof)(l["void"](u.functorParser)(E.bind(u.bindParser)(u.getInput)(function(a){return u.fail("Unexpected input: "+
a)}))))(function(){return u["return"](a)})})})},Z=function(a){return function(b){if(a instanceof H)b=q.replace(S)("@$1")(b);else if(!(a instanceof L))throw Error("Failed pattern match at Neodoc.Spec.Lexer line 77, column 16 - line 79, column 38: "+[a.constructor.name]);return e.lmap(r.bifunctorEither)(function(a){return y.SpecParseError(u.extractError(v.id(v.categoryFn))(a))})(u.runParser(new h.Args5(F.unit,C.initialPos,F.unit,b,W(a))))}},g=Z(H.value);a.Usage=H;a.Descriptions=L;a._angleName=T;a._anyName=
U;a._eoa=M;a._longOption=ca;a._reference=D;a._shortOption=da;a._stdin=O;a._tag=N;a.identLetter=P;a.lex=Z;a.lexDescs=function(a){return Z(L.value)(b.trimDescSection(a))};a.lexUsage=g;a.maybeShoutName=X;a.maybeShoutNameRegex=R;a.parseDescriptionToken=Q;a.parseTokens=W;a.parseUsageToken=Y;a.referenceRegex=S;a.skipSpaces=K;a.white=J;})(PS["Neodoc.Spec.Lexer"]=PS["Neodoc.Spec.Lexer"]||{});
(function(a){var b=PS["Data.Maybe"],c=PS["Neodoc.Spec.ParserState"],e=PS["Neodoc.Parsing.Parser"],d=PS["Neodoc.Parsing.Parser.Combinators"],g=PS["Control.Bind"],k=PS["Data.List.Types"],l=PS["Control.Applicative"],h=PS["Data.Functor"],f=PS["Control.Apply"],m=PS["Control.MonadZero"],n=PS["Data.Ord"],r=PS["Data.Eq"],p=g.bind(e.bindParser)(e.getInput)(function(a){return a instanceof k.Cons?l.pure(e.applicativeParser)(a.value0.value0):e.fail("Expected token, met EOF")}),t=function(a){return g.bind(e.bindParser)(p)(function(b){return g.bind(e.bindParser)(h.map(e.functorParser)(c.getIndentation)(e.getState))(function(c){return m.guard(e.monadZeroParser)(a(b.value1)(c))})})},
B=d.withErrorMessage(t(n.greaterThanOrEq(n.ordInt)))("indentation"),q=d.withErrorMessage(t(n.lessThan(n.ordInt)))("less indentation"),n=d.withErrorMessage(t(n.greaterThan(n.ordInt)))("more indentation"),r=d.withErrorMessage(t(r.eq(r.eqInt)))("same indentation");a.checkIndentation=t;a.indented=B;a.lessIndented=q;a.markIndent=function(a){var k=function(a){return e.modifyState(function(b){return c.setIndentation(a)(b)})};return g.bind(e.bindParser)(d.optionMaybe(p))(function(l){return d["try"](function(){return l instanceof
b.Just?g.bind(e.bindParser)(h.map(e.functorParser)(c.getIndentation)(e.getState))(function(b){return f.applyFirst(e.applyParser)(f.applySecond(e.applyParser)(k(l.value0.value1))(a))(k(b))}):a}())})};a["markIndent'"]=function(a){return function(b){var k=function(a){return e.modifyState(function(b){return c.setIndentation(a)(b)})};return g.bind(e.bindParser)(h.map(e.functorParser)(c.getIndentation)(e.getState))(function(c){return d["try"](f.applyFirst(e.applyParser)(f.applySecond(e.applyParser)(k(a))(b))(k(c)))})}};
a.moreIndented=n;a.nextTokPos=p;a.sameIndent=r;})(PS["Neodoc.Spec.Parser.Combinators"]=PS["Neodoc.Spec.Parser.Combinators"]||{});
(function(a){var b=PS["Data.Bifunctor"],c=PS["Data.NonEmpty"],e=PS["Data.NonEmpty.Extra"],d=PS["Neodoc.Data.Layout"],g=PS["Neodoc.Data.UsageLayout"],k=PS["Data.Functor"],l=PS["Control.Alt"],h=PS["Control.Apply"],f=PS["Control.Bind"],m=PS["Control.Lazy"],n=PS["Data.Either"],r=PS["Data.List"],p=PS["Data.Maybe"],t=PS["Data.Tuple"],B=PS["Neodoc.Data.OptionArgument"],q=PS["Neodoc.Parsing.Parser"],w=PS["Neodoc.Parsing.Parser.Combinators"],x=PS["Neodoc.Spec.Error"],y=PS["Neodoc.Spec.TokenParser"],C=PS["Neodoc.Spec.Parser.Combinators"],
u=PS["Data.Foldable"],A=PS["Data.Unit"],z=PS["Data.List.Types"],E=PS["Data.Semigroup"],F=PS["Control.MonadZero"];a.parse=function(a){var G=h.applySecond(q.applyParser)(y.dash)(q["return"](g.Stdin.value)),v=w.option(!1)(k.voidLeft(q.functorParser)(h.applySecond(q.applyParser)(C.indented)(y.tripleDot))(!0)),H=f.bind(q.bindParser)(y.sopt)(function(a){var b=f.bind(p.bindMaybe)(a.arg)(function(a){return new p.Just(new B.OptionArgument(a.name,a.optional))});return k.map(q.functorParser)(g.OptionStack.create(a.chars)(b))(v)}),
L=k.map(q.functorParser)(g.Reference.create)(y.reference),J=w.asErrorMessage("Program name")(y.name),K=h.apply(q.applyParser)(k.map(q.functorParser)(g.Positional.create)(l.alt(q.altParser)(y.shoutName)(y.angleName)))(v),S=function(a){return f.bind(q.bindParser)(h.applySecond(q.applyParser)(C.moreIndented)(h.apply(q.applyParser)(k.map(q.functorParser)(t.Tuple.create)(w.optionMaybe(w.choice(u.foldableArray)([k.voidLeft(q.functorParser)(y.lparen)(y.rparen),k.voidLeft(q.functorParser)(y.lsquare)(y.rsquare)]))))(a)))(function(a){return f.bind(q.bindParser)(p.fromMaybe(q["return"](A.unit))(a.value0))(function(){return q["return"](a.value1)})})},
R=f.bind(q.bindParser)(y.lopt)(function(a){var b=f.bind(p.bindMaybe)(a.arg)(function(a){return new p.Just(new B.OptionArgument(a.name,a.optional))});return k.map(q.functorParser)(g.Option.create(a.name)(b))(v)}),H=l.alt(q.altParser)(R)(H),P=function(a){return function(b){var d=function(a){return function(a){return a}}();if(b instanceof z.Cons)b=new c.NonEmpty(b.value0,b.value1);else throw Error("Failed pattern match at Neodoc.Spec.Parser.Usage line 175, column 3 - line 175, column 36: "+[b.constructor.name]);
return d(b)}},R=h.apply(q.applyParser)(k.map(q.functorParser)(g.Command.create)(y.name))(v),N=m.defer(q.lazyParser)(function(a){return f.bind(q.bindParser)(w.between(h.applySecond(q.applyParser)(C.indented)(y.lparen))(y.rparen)(w.sepBy1(w.some(M))(y.vbar)))(function(a){return h.apply(q.applyParser)(k.map(q.functorParser)(d.Group.create(!1))(v))(q["return"](P()(k.map(z.functorList)(P())(a))))})}),O=m.defer(q.lazyParser)(function(a){return f.bind(q.bindParser)(w.between(h.applySecond(q.applyParser)(C.indented)(y.lsquare))(y.rsquare)(w.sepBy1(w.some(M))(y.vbar)))(function(a){return h.apply(q.applyParser)(k.map(q.functorParser)(d.Group.create(!0))(v))(q["return"](P()(k.map(z.functorList)(P())(a))))})}),
D=m.defer(q.lazyParser)(function(a){return w.choice(u.foldableArray)([N,O])}),M=w.asErrorMessage("Option, Positional, Command, Group or Reference")(w.choice(u.foldableArray)([k.map(q.functorParser)(d.Elem.create)(K),k.map(q.functorParser)(d.Elem.create)(R),k.map(q.functorParser)(d.Elem.create)(L),k.map(q.functorParser)(d.Elem.create)(G),k.map(q.functorParser)(d.Elem.create)(H),m.defer(q.lazyParser)(function(a){return D})])),U=function(a){return f.bind(q.bindParser)(w.asErrorMessage("Option, Positional, Command, Group or Reference elements")(w.sepBy1(w.many(w["try"](h.applySecond(q.applyParser)(C.moreIndented)(M))))(y.vbar)))(function(a){return f.bind(q.bindParser)(w.choice(u.foldableArray)([w["try"](f.bind(q.bindParser)(S(f.bind(q.bindParser)(S(f.bind(q.bindParser)(y.doubleDash)(function(){return w.many(M)})))(function(){return w.many(M)})))(function(){return f.bind(q.bindParser)(w.many(M))(function(){return q["return"](p.Just.create(new d.Elem(g.EOA.value)))})})),
w.withErrorMessage(f.bind(q.bindParser)(l.alt(q.altParser)(y.eof)(w.lookAhead(l.alt(q.altParser)(C.lessIndented)(C.sameIndent))))(function(){return q["return"](p.Nothing.value)}))("End of usage line")]))(function(b){var c=r.reverse(function(){var c=r.reverse(a);if(c instanceof z.Nil)return p.maybe(z.Nil.value)(function(a){return r.singleton(r.singleton(a))})(b);if(c instanceof z.Cons)return new z.Cons(E.append(z.semigroupList)(c.value0)(p.maybe(z.Nil.value)(r.singleton)(b)),c.value1);throw Error("Failed pattern match at Neodoc.Spec.Parser.Usage line 108, column 29 - line 110, column 58: "+
[c.constructor.name]);}()),c=r.filter(function(a){return !r["null"](a)})(c);return q["return"](c instanceof z.Nil?p.Nothing.value:new p.Just(new d.Group(!1,!1,P()(k.map(z.functorList)(P())(c)))))})})};return b.lmap(n.bifunctorEither)(x.SpecParseError)(y.runTokenParser(a)(f.bind(q.bindParser)(w.withErrorMessage(C.nextTokPos)("Program name"))(function(a){return f.bind(q.bindParser)(J)(function(b){return f.bind(q.bindParser)(C["markIndent'"](a.value1)(h.apply(q.applyParser)(k.map(q.functorParser)(c.NonEmpty.create)(U()))(w.many(f.bind(q.bindParser)(w.optional(w["try"](f.bind(q.bindParser)(f.bind(q.bindParser)(y.name)(function(a){return F.guard(q.monadZeroParser)("or"===
a)}))(function(){return y.colon}))))(function(){return f.bind(q.bindParser)(J)(function(a){var c=b!==a;if(c)return q.fatal('Program name mismatch: Expected "'+(b+('", but got "'+(a+'"'))));if(!c)return U();throw Error("Failed pattern match at Neodoc.Spec.Parser.Usage line 63, column 13 - line 69, column 32: "+[c.constructor.name]);})})))))(function(a){return f.bind(q.bindParser)(w.withErrorMessage(y.eof)("End of usage section"))(function(){return q["return"]({program:b,layouts:k.mapFlipped(c.functorNonEmpty(z.functorList))(a)(function(a){if(a instanceof
p.Just&&a.value0 instanceof d.Group)return e.toList(a.value0.value2);if(a instanceof p.Just&&a.value0 instanceof d.Elem)return r.singleton(new c.NonEmpty(a.value0,z.Nil.value));if(a instanceof p.Nothing)return z.Nil.value;throw Error("Failed pattern match at Neodoc.Spec.Parser.Usage line 76, column 19 - line 79, column 35: "+[a.constructor.name]);})})})})})})))};})(PS["Neodoc.Spec.Parser.Usage"]=PS["Neodoc.Spec.Parser.Usage"]||{});
(function(a){var b=PS["Data.Pretty"],c=PS["Data.Bifunctor"],e=PS["Data.NonEmpty"],d=PS["Data.Functor"],g=PS["Data.Function"],k=PS["Data.Foldable"],l=PS["Control.Lazy"],h=PS["Control.Bind"],f=PS["Control.Alt"],m=PS["Control.Apply"],n=PS["Data.String"],r=PS["Data.List"],p=PS["Neodoc.Parsing.Parser"],t=PS["Neodoc.Parsing.Parser.Combinators"],B=PS["Neodoc.Spec.Error"],q=PS["Neodoc.Spec.TokenParser"],w=PS["Neodoc.Spec.Parser.Combinators"],x=PS["Data.Either"],y=PS["Data.Maybe"],C=PS["Data.Array"],u=PS["Neodoc.Value"],
A=PS["Neodoc.OptionAlias"],z=PS["Neodoc.Data.OptionArgument"],E=PS["Neodoc.Data.Description"],F=PS["Data.Show"],G=PS["Data.Semigroup"],I=PS["Data.Eq"],v=PS["Data.HeytingAlgebra"],H=PS["Control.Applicative"],L=PS["Control.MonadZero"],J=PS["Data.List.Types"],K=PS["Control.Category"],S=PS["Data.Monoid"],R=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),P=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),N=function(){return function(a){a=
y.fromMaybe(a)(n.stripSuffix("\x3e")(a));return y.fromMaybe(a)(n.stripPrefix("\x3c")(a))}}(),O=g.on(I.eq(I.eqString))(function(a){return n.toUpper(N(a))}),D=function(a){return v.not(v.heytingAlgebraFunction(v.heytingAlgebraBoolean))(O(a))},M=function(a){return a instanceof P?!0:!1},U=function(a){return a instanceof R?!0:!1},X=function(a){return a instanceof P?new y.Just(a.value0):y.Nothing.value},T=function(a){return a instanceof R?x.either(g["const"](y.Nothing.value))(y.Just.create)(u.parse(a.value0)(!0)):
y.Nothing.value};a.Default=R;a.Env=P;a.getDefaultValue=T;a.getEnvKey=X;a.isDefaultTag=U;a.isEnvTag=M;a.notPosArgsEq=D;a.parse=function(a){var n=function(a){var b=t.choice(k.foldableArray)([q.eof,d["void"](p.functorParser)(t.lookAhead(h.bind(p.bindParser)(q.newline)(function(){return h.bind(p.bindParser)(H.when(p.applicativeParser)(!a)(w.lessIndented))(function(){return t.choice(k.foldableArray)([d["void"](p.functorParser)(q.sopt),d["void"](p.functorParser)(q.lopt),d["void"](p.functorParser)(q.angleName),
d["void"](p.functorParser)(q.shoutName)])})})))]);return m.applyFirst(p.applyParser)(w.markIndent(d.map(p.functorParser)(r.catMaybes)(g.flip(t.manyTill)(b)(t.choice(k.foldableArray)(d.map(d.functorArray)(t["try"])([d.map(p.functorParser)(function(a){return y.Just.create(R.create(a))})(q.tag("default")),d.map(p.functorParser)(function(a){return y.Just.create(P.create(a))})(q.tag("env")),d.voidLeft(p.functorParser)(q.anyToken)(y.Nothing.value)]))))))(f.alt(p.altParser)(d["void"](p.functorParser)(q.eof))(d["void"](p.functorParser)(t.some(q.newline))))},
u=function(){var a=h.bind(p.bindParser)(h.bind(p.bindParser)(q.sopt)(function(a){return h.bind(p.bindParser)(t.withErrorMessage(L.guard(p.monadZeroParser)(0===C.length(a.chars.value1)))("No stacked options"))(function(){return H.pure(p.applicativeParser)({flag:a.chars.value0,arg:a.arg})})}))(function(a){return h.bind(p.bindParser)(y.maybe(t.optionMaybe(h.bind(p.bindParser)(t.optionMaybe(t.choice(k.foldableArray)([d.voidLeft(p.functorParser)(q.lparen)(d.voidLeft(p.functorParser)(q.rparen)(!1)),d.voidLeft(p.functorParser)(q.lsquare)(d.voidLeft(p.functorParser)(q.rsquare)(!0))])))(function(a){return h.bind(p.bindParser)(f.alt(p.altParser)(q.shoutName)(q.angleName))(function(b){return h.bind(p.bindParser)(y.fromMaybe(H.pure(p.applicativeParser)(!1))(a))(function(a){return H.pure(p.applicativeParser)({name:b,
optional:a})})})})))(function(a){return H.pure(p.applicativeParser)(y.Just.create(a))})(a.arg))(function(b){return h.bind(p.bindParser)(t.option(!1)(d.voidLeft(p.functorParser)(q.tripleDot)(!0)))(function(c){return H.pure(p.applicativeParser)({alias:new A.Short(a.flag),arg:b,repeatable:c})})})}),c=h.bind(p.bindParser)(q.lopt)(function(a){return h.bind(p.bindParser)(y.maybe(t.optionMaybe(h.bind(p.bindParser)(t.optionMaybe(t.choice(k.foldableArray)([d.voidLeft(p.functorParser)(q.lparen)(d.voidLeft(p.functorParser)(q.rparen)(!1)),
d.voidLeft(p.functorParser)(q.lsquare)(d.voidLeft(p.functorParser)(q.rsquare)(!0))])))(function(a){return h.bind(p.bindParser)(f.alt(p.altParser)(q.shoutName)(q.angleName))(function(b){return h.bind(p.bindParser)(y.fromMaybe(H.pure(p.applicativeParser)(!1))(a))(function(a){return H.pure(p.applicativeParser)({name:b,optional:a})})})})))(function(a){return H.pure(p.applicativeParser)(y.Just.create(a))})(a.arg))(function(b){return h.bind(p.bindParser)(t.option(!1)(d.voidLeft(p.functorParser)(q.tripleDot)(!0)))(function(c){return H.pure(p.applicativeParser)({alias:new A.Long(a.name),
arg:b,repeatable:c})})})}),g=function(){var f=function(a){var b;if(a.optional)b="[";else {if(a.optional)throw Error("Failed pattern match at Neodoc.Spec.Parser.Description line 205, column 12 - line 205, column 33: "+[a.optional.constructor.name]);b="";}var c=a.name;if(a.optional)a="]";else {if(a.optional)throw Error("Failed pattern match at Neodoc.Spec.Parser.Description line 205, column 44 - line 205, column 65: "+[a.optional.constructor.name]);a="";}return b+(c+a)},g=t.asErrorMessage("option")(t.choice(k.foldableArray)([t["try"](a),
c]));return h.bind(p.bindParser)(t.sepBy1(g)(t.optional(m.applySecond(p.applyParser)(m.applySecond(p.applyParser)(q.comma)(t.many(q.newline)))(w.indented))))(function(a){return h.bind(p.bindParser)(k.foldl(J.foldableList)(function(a){return function(c){return h.bind(p.bindParser)(a)(function(a){var d=k.elem(J.foldableList)(A.eqOptionAlias)(c)(a);if(d)return p.fatal("Option appears multiple times: "+b.pretty(A.prettyOptionAlias)(c));if(!d)return H.pure(p.applicativeParser)(G.append(J.semigroupList)(a)(r.singleton(c)));
throw Error("Failed pattern match at Neodoc.Spec.Parser.Description line 166, column 9 - line 168, column 44: "+[d.constructor.name]);})}})(H.pure(p.applicativeParser)(J.Nil.value))(d.map(J.functorList)(function(a){return a.alias})(a)))(function(b){return h.bind(p.bindParser)(k.foldl(J.foldableList)(function(a){return function(b){return h.bind(p.bindParser)(a)(function(a){if(a instanceof y.Nothing)return H.pure(p.applicativeParser)(new y.Just(b));if(a instanceof y.Just){var c=D(a.value0.name)(b.name);
if(c)return p.fatal("Option-arguments mismatch: "+(F.show(F.showString)(f(a.value0))+(" and "+F.show(F.showString)(f(b)))));if(!c)return H.pure(p.applicativeParser)(y.Just.create(function(){var c={},d;for(d in a.value0)({}).hasOwnProperty.call(a.value0,d)&&(c[d]=a.value0[d]);c.optional=a.value0.optional||b.optional;return c}()));throw Error("Failed pattern match at Neodoc.Spec.Parser.Description line 177, column 13 - line 187, column 27: "+[c.constructor.name]);}throw Error("Failed pattern match at Neodoc.Spec.Parser.Description line 174, column 9 - line 187, column 27: "+
[a.constructor.name]);})}})(H.pure(p.applicativeParser)(y.Nothing.value))(r.catMaybes(d.map(J.functorList)(function(a){return a.arg})(a))))(function(c){var f=k.foldl(J.foldableList)(v.disj(v.heytingAlgebraBoolean))(!1)(d.map(J.functorList)(function(a){return a.repeatable})(a));return H.pure(p.applicativeParser)(function(a){a=function(a){return function(a){return a}}();var d;if(b instanceof J.Cons)d={aliases:new e.NonEmpty(b.value0,b.value1),arg:c,env:y.Nothing.value,repeatable:f};else throw Error("Failed pattern match at Neodoc.Spec.Parser.Description line 195, column 30 - line 201, column 10: "+
[b.constructor.name]);return a(d)}())})})})}();return h.bind(p.bindParser)(g)(function(a){return h.bind(p.bindParser)(n(!1))(function(c){var f=d.map(J.functorList)(X)(r.filter(M)(c)),g=h.bind(y.bindMaybe)(r.head(f))(K.id(K.categoryFn));c=d.map(J.functorList)(T)(r.filter(U)(c));var l=h.bind(y.bindMaybe)(r.head(c))(K.id(K.categoryFn));return h.bind(p.bindParser)(H.when(p.applicativeParser)(1<r.length(c))(p.fatal("Option "+(k.intercalate(e.foldableNonEmpty(J.foldableList))(S.monoidString)(", ")(d.map(e.functorNonEmpty(J.functorList))(b.pretty(A.prettyOptionAlias))(a.aliases))+
" has multiple defaults!"))))(function(){return h.bind(p.bindParser)(H.when(p.applicativeParser)(1<r.length(f))(p.fatal("Option "+(k.intercalate(e.foldableNonEmpty(J.foldableList))(S.monoidString)(", ")(d.map(e.functorNonEmpty(J.functorList))(b.pretty(A.prettyOptionAlias))(a.aliases))+" has multiple environment mappings!"))))(function(){return h.bind(p.bindParser)(H.when(p.applicativeParser)(y.isJust(l)&&y.isNothing(a.arg))(p.fatal("Option "+(k.intercalate(e.foldableNonEmpty(J.foldableList))(S.monoidString)(", ")(d.map(e.functorNonEmpty(J.functorList))(b.pretty(A.prettyOptionAlias))(a.aliases))+
" does not take arguments. Cannot specify defaults."))))(function(){return H.pure(p.applicativeParser)(new E.OptionDescription(a.aliases,a.repeatable,h.bind(y.bindMaybe)(a.arg)(function(a){return H.pure(y.applicativeMaybe)(new z.OptionArgument(a.name,a.optional))}),l,g))})})})})})}(),I=h.bind(p.bindParser)(f.alt(p.altParser)(q.angleName)(q.shoutName))(function(){return h.bind(p.bindParser)(t.option(!1)(d.voidLeft(p.functorParser)(q.tripleDot)(!0)))(function(){return h.bind(p.bindParser)(n(!1))(function(){return H.pure(p.applicativeParser)(E.CommandDescription.value)})})}),
W=l.defer(p.lazyParser)(function(a){return t.asErrorMessage("--option or \x3cpositional\x3e description")(t.choice(k.foldableArray)([u,I]))}),N=function(a){return h.bind(p.bindParser)(f.alt(p.altParser)(d.map(p.functorParser)(y.Just.create)(W))(d.voidLeft(p.functorParser)(n(!0))(y.Nothing.value)))(function(b){if(b instanceof y.Just)return N(new J.Cons(b.value0,a));if(b instanceof y.Nothing)return t.choice(k.foldableArray)([h.bind(p.bindParser)(W)(function(b){return N(new J.Cons(b,a))}),H.pure(p.applicativeParser)(a)]);
throw Error("Failed pattern match at Neodoc.Spec.Parser.Description line 69, column 5 - line 75, column 10: "+[b.constructor.name]);})};f.alt(p.altParser)(f.alt(p.altParser)(q.angleName)(q.shoutName))(q.name);return c.lmap(x.bifunctorEither)(B.SpecParseError)(q.runTokenParser(a)(m.applyFirst(p.applyParser)(w.markIndent(d.map(p.functorParser)(r.reverse)(N(J.Nil.value))))(q.eof)))};a.posArgsEq=O;a.stripAngles=N;})(PS["Neodoc.Spec.Parser.Description"]=PS["Neodoc.Spec.Parser.Description"]||{});
(function(a){var b=PS["Neodoc.Spec.Parser.Usage"].parse;a.parseDescription=PS["Neodoc.Spec.Parser.Description"].parse;a.parseUsage=b;})(PS["Neodoc.Spec.Parser"]=PS["Neodoc.Spec.Parser"]||{});
(function(a){var b=PS["Data.Pretty"],c=PS["Data.Maybe"],e=PS["Data.Foldable"],d=PS["Data.String"],g=PS["Data.Array"],k=PS["Neodoc.Value"],l=PS["Data.Ord"],h=PS["Data.Ordering"],f=PS["Data.Eq"],m=PS["Data.Functor"],n=PS["Data.List.Types"],r=PS["Data.Monoid"],p=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),t=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,
c,d)}}};return a}(),B=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),q=function(){function a(){}a.value=new a;return a}(),w=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),x=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),y=new b.Pretty(function(a){if(a instanceof q)return "-";if(a instanceof B)return "-- "+
e.intercalate(n.foldableList)(r.monoidString)(" ")(m.map(n.functorList)(b.pretty(k.prettyValue))(a.value0));if(a instanceof w)return a.value0;if(a instanceof p){var f=c.maybe("")(function(a){return "\x3d"+a})(a.value1);return "--"+(a.value0+f)}if(a instanceof t)return f=c.maybe("")(function(a){return "\x3d"+a})(a.value2),"-"+(d.fromCharArray(g.cons(a.value0)(a.value1))+f);throw Error("Failed pattern match at Neodoc.ArgParser.Token line 30, column 3 - line 31, column 3: "+[a.constructor.name]);}),C=new b.Pretty(function(a){return b.pretty(y)(a.value0)}),
u=new f.Eq(function(a){return function(b){return a instanceof p&&b instanceof p?a.value0===b.value0&&f.eq(c.eqMaybe(f.eqString))(a.value1)(b.value1):a instanceof t&&b instanceof t?a.value0===b.value0&&f.eq(f.eqArray(f.eqChar))(a.value1)(b.value1)&&f.eq(c.eqMaybe(f.eqString))(a.value2)(b.value2):a instanceof B&&b instanceof B?f.eq(n.eqList(k.eqValue))(a.value0)(b.value0):a instanceof q&&b instanceof q?!0:a instanceof w&&b instanceof w?a.value0===b.value0:!1}}),A=new l.Ord(function(){return u},function(a){return function(b){if(a instanceof
p&&b instanceof p){var d=l.compare(l.ordString)(a.value0)(b.value0);return d instanceof h.LT?h.LT.value:d instanceof h.GT?h.GT.value:l.compare(c.ordMaybe(l.ordString))(a.value1)(b.value1)}if(a instanceof p)return h.LT.value;if(b instanceof p)return h.GT.value;if(a instanceof t&&b instanceof t){d=l.compare(l.ordChar)(a.value0)(b.value0);if(d instanceof h.LT)return h.LT.value;if(d instanceof h.GT)return h.GT.value;d=l.compare(l.ordArray(l.ordChar))(a.value1)(b.value1);return d instanceof h.LT?h.LT.value:
d instanceof h.GT?h.GT.value:l.compare(c.ordMaybe(l.ordString))(a.value2)(b.value2)}if(a instanceof t)return h.LT.value;if(b instanceof t)return h.GT.value;if(a instanceof B&&b instanceof B)return l.compare(n.ordList(k.ordValue))(a.value0)(b.value0);if(a instanceof B)return h.LT.value;if(b instanceof B)return h.GT.value;if(a instanceof q&&b instanceof q)return h.EQ.value;if(a instanceof q)return h.LT.value;if(b instanceof q)return h.GT.value;if(a instanceof w&&b instanceof w)return l.compare(l.ordString)(a.value0)(b.value0);
throw Error("Failed pattern match at Neodoc.ArgParser.Token line 22, column 1 - line 22, column 38: "+[a.constructor.name,b.constructor.name]);}});a.PositionedToken=x;a.LOpt=p;a.SOpt=t;a.EOA=B;a.Stdin=q;a.Lit=w;a.getSource=function(a){return a.value1};a.getToken=function(a){return a.value0};a.ordToken=A;a.eqToken=u;a.prettyToken=y;a.prettyPositionedToken=C;})(PS["Neodoc.ArgParser.Token"]=PS["Neodoc.ArgParser.Token"]||{});
(function(a){var b=PS["Data.Either"],c=PS["Data.Bifunctor"],e=PS["Data.Optimize.Uncurried"],d=PS["Control.Apply"],g=PS["Data.List"],k=PS["Data.String"],l=PS["Data.Foldable"],h=PS["Neodoc.Parsing.Parser"],f=PS["Neodoc.Parsing.Parser.String"],m=PS["Neodoc.Parsing.Parser.Combinators"],n=PS["Neodoc.Parsing.Parser.Pos"],r=PS["Data.Array"],p=PS["Control.Plus"],t=PS["Neodoc.ArgParser.Token"],B=PS["Neodoc.Value"],q=PS["Control.Bind"],w=PS["Control.Applicative"],x=PS["Data.Functor"],y=PS["Data.List.Types"],
C=PS["Data.Monoid"],u=PS["Data.Unit"],A=PS["Data.Semigroup"],z=PS["Control.Category"],E=function(){var a=q.bind(h.bindParser)(f["char"]("-"))(function(){return w.pure(h.applicativeParser)(t.Stdin.value)}),b=x.map(h.functorParser)(function(a){return t.Lit.create(l.foldMap(y.foldableList)(C.monoidString)(k.singleton)(a))})(g.many(h.alternativeParser)(h.lazyParser)(f.anyChar)),c=["\x3d"," ","\t","\n","\r"],e=r.cons("-")(c),n=q.bind(h.bindParser)(f.string("--"))(function(){return w.pure(h.applicativeParser)(new t.EOA(p.empty(y.plusList)))}),
u=q.bind(h.bindParser)(f["char"]("\x3d"))(function(){return x.map(h.functorParser)(l.foldMap(y.foldableList)(C.monoidString)(k.singleton))(g.many(h.alternativeParser)(h.lazyParser)(f.anyChar))}),z=q.bind(h.bindParser)(f.string("--"))(function(){return q.bind(h.bindParser)(x.map(h.functorParser)(l.foldMap(y.foldableList)(C.monoidString)(k.singleton))(g.some(h.alternativeParser)(h.lazyParser)(f.noneOf(c))))(function(a){return q.bind(h.bindParser)(m.optionMaybe(u))(function(b){return w.pure(h.applicativeParser)(new t.LOpt(a,
b))})})}),A=q.bind(h.bindParser)(f["char"]("-"))(function(){return q.bind(h.bindParser)(f.noneOf(e))(function(a){return q.bind(h.bindParser)(r.many(h.alternativeParser)(h.lazyParser)(f.noneOf(c)))(function(b){return q.bind(h.bindParser)(m.optionMaybe(u))(function(c){return w.pure(h.applicativeParser)(new t.SOpt(a,b,c))})})})});return m.choice(l.foldableArray)(x.map(x.functorArray)(m["try"])([d.applyFirst(h.applyParser)(z)(f.eof),d.applyFirst(h.applyParser)(A)(f.eof),d.applyFirst(h.applyParser)(n)(f.eof),
d.applyFirst(h.applyParser)(a)(f.eof),d.applyFirst(h.applyParser)(b)(f.eof)]))}();a.lex=function(a){return function(d){var f=function(a){return function(c){if(a instanceof y.Nil)return w.pure(b.applicativeEither)(y.Nil.value);if(a instanceof y.Cons)return q.bind(b.bindEither)(h.runParser(new e.Args5(u.unit,n.initialPos,u.unit,a.value0,E)))(function(d){return d instanceof t.EOA?b.Right.create(g.singleton(new t.PositionedToken(new t.EOA(x.map(y.functorList)(B.StringValue.create)(a.value1)),a.value0,
c))):q.bind(b.bindEither)(f(a.value1)(c+1|0))(function(f){return b.Right.create(A.append(y.semigroupList)(g.singleton(new t.PositionedToken(d,a.value0,c)))(f))})});throw Error("Failed pattern match at Neodoc.ArgParser.Lexer line 102, column 1 - line 114, column 58: "+[a.constructor.name,c.constructor.name]);}};return c.lmap(b.bifunctorEither)(h.extractError(z.id(z.categoryFn)))(f(a)(1))}};})(PS["Neodoc.ArgParser.Lexer"]=PS["Neodoc.ArgParser.Lexer"]||{});
(function(a){var b=PS["Data.Foldable"],c=PS["Neodoc.Data.Layout"],e=PS["Neodoc.Data.SolvedLayout"],d=PS["Data.NonEmpty"],g=PS["Data.List.Types"],k=PS["Data.HeytingAlgebra"],l=function(){function a(a,b,c,d,f){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=f;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return new a(b,c,d,f,e)}}}}};return a}(),h=function(a){if(a instanceof c.Elem)return e.isFreeElem(a.value0.value1);if(a instanceof
c.Group)return b.all(d.foldableNonEmpty(g.foldableList))(k.heytingAlgebraBoolean)(b.all(d.foldableNonEmpty(g.foldableList))(k.heytingAlgebraBoolean)(h))(a.value2);throw Error("Failed pattern match at Neodoc.ArgParser.Arg line 71, column 1 - line 71, column 58: "+[a.constructor.name]);};a.Arg=l;a.getArg=function(a){return a.value1};a.getArgKey=function(a){return a.value2};a.getFallback=function(a){return a.value3};a.getId=function(a){return a.value0};a.isArgRepeatable=function(a){return e.isElemRepeatable(a.value1)};
a.isFreeLayout=h;a.isOption=function(a){return e.isOption(a.value1)};a.setId=function(a){return function(b){return new l(a,b.value1,b.value2,b.value3,b.value4)}};})(PS["Neodoc.ArgParser.Arg"]=PS["Neodoc.ArgParser.Arg"]||{});
(function(a){var b=PS["Data.Function"],c=PS["Data.Eq"],e=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),d=function(){function a(a,b,c,d,e){this.value0=a;this.value1=b;this.value2=c;this.value3=d;this.value4=e;}a.create=function(b){return function(c){return function(d){return function(f){return function(e){return new a(b,c,d,f,e)}}}}};return a}(),g=function(a){if(a instanceof e||a instanceof
d)return a.value0;throw Error("Failed pattern match at Neodoc.ArgParser.ParseLayout line 56, column 1 - line 56, column 30: "+[a.constructor.name]);},b=new c.Eq(b.on(c.eq(c.eqInt))(g));a.ParseElem=e;a.ParseGroup=d;a.getId=g;a.eqParseLayout=b;})(PS["Neodoc.ArgParser.ParseLayout"]=PS["Neodoc.ArgParser.ParseLayout"]||{});
(function(a){var b=PS["Neodoc.Data.Layout"],c=PS["Neodoc.Data.SolvedLayout"],e=PS["Neodoc.ArgParser.Token"],d=PS["Neodoc.Data.LayoutConversion"],g=PS["Data.Foldable"],k=PS["Data.Lazy"],l=PS["Data.List"],h=PS["Data.Maybe"],f=PS["Data.NonEmpty"],m=PS["Data.Pretty"],n=PS["Data.Tuple"],r=PS["Neodoc.Data.Description"],p=PS["Neodoc.Error"],t=PS["Neodoc.Error.Class"],B=PS["Neodoc.OptionAlias"],q=PS["Neodoc.Parsing.Parser"],w=PS["Control.Bind"],x=PS["Control.Applicative"],y=PS["Data.List.Types"],C=PS["Data.Unit"],
u=PS["Data.Function"],A=PS["Data.Functor"],z=PS["Data.HeytingAlgebra"],E=PS["Data.Eq"],F=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),G=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),I=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),v=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,
c)}};return a}(),H=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),L=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),J=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),K=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};
return a}(),S=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),R=G.create,P=function(a){return function(b){if(b instanceof e.LOpt||b instanceof e.SOpt)return "option "+a.value1;if(b instanceof e.EOA)return "option --";if(b instanceof e.Stdin)return "option -";if(b instanceof e.Lit)return "command "+a.value1;throw Error("Failed pattern match at Neodoc.ArgParser.Type line 128, column 3 - line 128, column 46: "+[b.constructor.name]);
}(a.value0)},N=q.modifyState(function(a){var b={},c;for(c in a)({}).hasOwnProperty.call(a,c)&&(b[c]=a[c]);b.hasTerminated=!0;return b}),O=function(a){return new m.Pretty(function(b){if(b instanceof F||b instanceof G)return m.pretty(a)(b.value0);throw Error("Failed pattern match at Neodoc.ArgParser.Type line 104, column 3 - line 104, column 30: "+[b.constructor.name]);})},D=new m.Pretty(function(a){if(a instanceof I||a instanceof v||a instanceof H)return k.force(a.value1);if(a instanceof L)return k.force(a.value2);
if(a instanceof J)return k.force(a.value1);if(a instanceof K)return a.value0;if(a instanceof S)return k.force(a.value1);throw Error("Failed pattern match at Neodoc.ArgParser.Type line 174, column 3 - line 174, column 56: "+[a.constructor.name]);}),t=new t.ToNeodocError(function(a){return new p.ArgParserError(m.pretty(D)(a))}),M=function(a){return q.modifyState(function(b){var c={},d;for(d in b)({}).hasOwnProperty.call(b,d)&&(c[d]=b[d]);c.depth=a(b.depth);return c})},U=F.create,X=A.map(q.functorParser)(function(a){return a.hasTerminated})(q.getState),
T=function(a){return function(b){return l.head(l.filter(function(b){return b instanceof r.OptionDescription?g.any(f.foldableNonEmpty(y.foldableList))(z.heytingAlgebraBoolean)(function(b){return E.eq(B.eqOptionAlias)(b)(a)})(b.value0):!1})(b))}},ca=function(a){return w.bind(q.bindParser)(q.getConfig)(function(b){return w.bind(q.bindParser)(x.pure(q.applicativeParser)(b.spec))(function(b){return x.pure(q.applicativeParser)(T(a)(b.descriptions))})})};a.OptionTakesNoArgumentError=I;a.OptionRequiresArgumentError=
v;a.MissingArgumentsError=H;a.UnexpectedInputError=L;a.MalformedInputError=J;a.GenericError=K;a.InternalError=S;a.findDescription=T;a.genericError=function(a){return new K(a)};a.hasTerminated=X;a.internalError=function(a){return S.create(a)(k.defer(function(b){return "internal error: "+a}))};a.isKnown=function(a){if(a instanceof F)return !0;if(a instanceof G)return !1;throw Error("Failed pattern match at Neodoc.ArgParser.Type line 109, column 1 - line 109, column 25: "+[a.constructor.name]);};a.isUnknown=
function(a){if(a instanceof G)return !0;if(a instanceof F)return !1;throw Error("Failed pattern match at Neodoc.ArgParser.Type line 111, column 1 - line 111, column 29: "+[a.constructor.name]);};a.known=U;a.lookupDescription=ca;a["lookupDescription'"]=function(a){var b=new r.OptionDescription(f.singleton(y.plusList)(a),!1,h.Nothing.value,h.Nothing.value,h.Nothing.value);return A.map(q.functorParser)(h.fromMaybe(b))(ca(a))};a.malformedInputError=function(a){return J.create(a)(k.defer(function(b){return "malformed input: "+
a}))};a.missingArgumentsError=function(a){return H.create(a)(k.defer(function(b){b=d.flattenBranch(a);return "missing "+m.pretty(c.prettySolvedLayoutArg)(b.value0)}))};a.modifyDepth=M;a.optionRequiresArgumentError=function(a){return v.create(a)(k.defer(function(b){return "option requires argument: "+m.pretty(B.prettyOptionAlias)(a)}))};a.optionTakesNoArgumentError=function(a){return I.create(a)(k.defer(function(b){return "option takes no argument: "+m.pretty(B.prettyOptionAlias)(a)}))};a.setDepth=function(a){return M(u["const"](a))};
a.setDone=N;a.setErrorAtDepth=function(a){return function(b){return w.bind(q.bindParser)(q.getGlobalState)(function(c){return c.deepestError instanceof h.Just&&a>c.deepestError.value0.value0?q.modifyGlobalState(function(c){var d={},f;for(f in c)({}).hasOwnProperty.call(c,f)&&(d[f]=c[f]);d.deepestError=new h.Just(new n.Tuple(a,b));return d}):c.deepestError instanceof h.Nothing?q.modifyGlobalState(function(c){var d={},f;for(f in c)({}).hasOwnProperty.call(c,f)&&(d[f]=c[f]);d.deepestError=new h.Just(new n.Tuple(a,
b));return d}):x.pure(q.applicativeParser)(C.unit)})}};a.skipIf=function(a){return function(b){return function(c){return w.bind(q.bindParser)(a)(function(a){if(a)return x.pure(q.applicativeParser)(b);if(!a)return c;throw Error("Failed pattern match at Neodoc.ArgParser.Type line 262, column 22 - line 262, column 45: "+[a.constructor.name]);})}}};a.unIsKnown=function(a){if(a instanceof G||a instanceof F)return a.value0;throw Error("Failed pattern match at Neodoc.ArgParser.Type line 113, column 1 - line 113, column 26: "+
[a.constructor.name]);};a.unexpectedInputError=function(a){return function(d){var f=function(a){return function(d){if(a instanceof y.Nil&&d instanceof y.Nil)return "";if(a instanceof y.Nil&&d instanceof y.Cons&&d.value0 instanceof F)return "unexpected "+P(d.value0.value0);if(d instanceof y.Cons&&d.value0 instanceof G)return "unknown "+P(d.value0.value0);if(a instanceof y.Cons){var f=m.pretty(b.prettyLayout(c.prettySolvedLayoutArg))(a.value0);if(d instanceof y.Nil)d="";else if(d instanceof y.Cons)d=", but got "+
m.pretty(O(e.prettyPositionedToken))(d.value0);else throw Error("Failed pattern match at Neodoc.ArgParser.Type line 151, column 3 - line 151, column 23: "+[d.constructor.name]);return "expected "+(f+d)}throw Error("Failed pattern match at Neodoc.ArgParser.Type line 148, column 1 - line 156, column 42: "+[a.constructor.name,d.constructor.name]);}};return L.create(a)(d)(k.defer(function(b){return f(a)(d)}))}};a.unknown=R;a.prettyIsKnown=O;a.prettyArgParseError=D;a.toNeodocErrorArgParseError=t;})(PS["Neodoc.ArgParser.Type"]=
PS["Neodoc.ArgParser.Type"]||{});
(function(a){var b=PS["Data.Array"],c=PS["Data.Array.Partial"],e=PS["Control.Plus"],d=PS["Data.Either"],g=PS["Data.List"],k=PS["Data.Maybe"],l=PS["Data.String"],h=PS["Data.Pretty"],f=PS["Neodoc.Parsing.Parser"],m=PS["Neodoc.ArgParser.Type"],n=PS["Neodoc.ArgParser.Token"],r=PS["Neodoc.OptionAlias"],p=PS["Neodoc.Value"],t=PS["Neodoc.Data.OptionArgument"],B=PS["Data.Function"],q=PS["Data.List.Types"],w=PS["Data.Semigroup"],x=PS["Control.Applicative"],y=PS["Control.Bind"],C=PS["Data.Functor"],u=PS["Data.Unfoldable"],
A=function(){function a(a,b,c){this.value0=a;this.value1=b;this.value2=c;}a.create=function(b){return function(c){return function(d){return new a(b,c,d)}}};return a}(),z=function(a){return function(b){return new f.Parser(function(c){var e=function(a){return function(b){return new f.Step(!0,f.setI(a)(c),b)}},g=function(a){return new f.Step(!1,c,d.Left.create(new f.ParseError(!1,new d.Left(a))))},h=f.getI(c);if(h instanceof q.Cons){var l=b(h.value0.value0);if(l instanceof k.Nothing)return g("expected "+
(a+(", but got: "+h.value0.value1)));if(l instanceof k.Just)return e(h.value1)(new d.Right(l.value0));throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 63, column 7 - line 65, column 40: "+[l.constructor.name]);}return g("expected "+a)})}},E=z("-")(function(a){return a instanceof n.Stdin?new k.Just(new p.BoolValue(!0)):k.Nothing.value}),F=z("option-argument")(function(a){return a instanceof n.Lit?new k.Just(p.read(a.value0)(!1)):k.Nothing.value}),G=z("--")(function(a){return a instanceof
n.EOA?new k.Just(new p.ArrayValue(g.toUnfoldable(u.unfoldableArray)(a.value0))):k.Nothing.value});a.OptRes=A;a.command=function(a){return function(b){return z(a)(function(a){return a instanceof n.Lit&&a.value0===b?new k.Just(new p.BoolValue(!0)):k.Nothing.value})}};a.eoa=G;a.longOption=function(a){return function(c){return function(d){var e=k.isNothing(d),l=function(b){return function(g){if(b instanceof n.LOpt&&b.value1 instanceof k.Nothing&&b.value0===c&&a)return x.pure(f.applicativeParser)({rawValue:k.Nothing.value,
hasConsumedArg:!1,explicitArg:!1});if(b instanceof n.LOpt&&!e&&b.value0===c){if(b.value1 instanceof k.Just)return x.pure(f.applicativeParser)({rawValue:new k.Just(b.value1.value0),hasConsumedArg:!1,explicitArg:!0});if(g instanceof k.Just&&g.value0 instanceof n.Lit)return x.pure(f.applicativeParser)({rawValue:new k.Just(g.value0.value0),hasConsumedArg:!0,explicitArg:!1});g=k.maybe(!0)(t.isOptionArgumentOptional)(d);if(g=a||g)return x.pure(f.applicativeParser)({rawValue:k.Nothing.value,hasConsumedArg:!1,
explicitArg:!1});if(!g)return f["fatal'"](m.optionRequiresArgumentError(new r.Long(c)));throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 134, column 17 - line 139, column 79: "+[g.constructor.name]);}if(b instanceof n.LOpt&&e&&b.value0===c){if(b.value1 instanceof k.Just)return f["fatal'"](m.optionTakesNoArgumentError(new r.Long(c)));if(b.value1 instanceof k.Nothing)return x.pure(f.applicativeParser)({rawValue:k.Nothing.value,hasConsumedArg:!1,explicitArg:!1});throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 144, column 7 - line 149, column 26: "+
[b.value1.constructor.name]);}return f.fail("Invalid token: "+h.pretty(n.prettyToken)(b))}};return y.bind(f.bindParser)(f.getInput)(function(c){if(c instanceof q.Cons){var d=C.map(k.functorMaybe)(n.getToken)(g.head(c.value1));return y.bind(f.bindParser)(l(c.value0.value0)(d))(function(d){return y.bind(f.bindParser)(f.setInput(c.value1 instanceof q.Cons&&d.hasConsumedArg?c.value1.value1:c.value1))(function(){return x.pure(f.applicativeParser)(function(){if(a){var c=p.ArrayValue.create(k.maybe([])(function(a){return b.singleton(p.StringValue.create(a))})(d.rawValue));
return new A(c,!0,!1)}if(!a)return c=k.maybe(new p.BoolValue(!0))(B.flip(p.read)(!1))(d.rawValue),A.create(c)(!0)(!d.explicitArg);throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 91, column 14 - line 99, column 57: "+[a.constructor.name]);}())})})}return f.fail("Expected token, met EOF")})}}};a.optionArgument=F;a.positional=function(a){return function(b){return z(a)(function(a){return a instanceof n.Lit?new k.Just(p.read(a.value0)(!1)):k.Nothing.value})}};a.shortOption=function(a){return function(d){return function(v){var u=
k.isNothing(v),z=function(e){return function(g){if(e instanceof n.SOpt&&e.value0===d&&!u&&b["null"](e.value1)){if(e.value2 instanceof k.Just)return x.pure(f.applicativeParser)({rawValue:new k.Just(e.value2.value0),remainder:k.Nothing.value,hasConsumedArg:!1,explicitArg:!0});if(g instanceof k.Just&&g.value0 instanceof n.Lit)return x.pure(f.applicativeParser)({rawValue:new k.Just(g.value0.value0),remainder:k.Nothing.value,hasConsumedArg:!0,explicitArg:!1});g=k.maybe(!0)(t.isOptionArgumentOptional)(v);
if(g=a||g)return x.pure(f.applicativeParser)({rawValue:k.Nothing.value,remainder:k.Nothing.value,hasConsumedArg:!1,explicitArg:!1});if(!g)return f["fatal'"](m.optionRequiresArgumentError(new r.Short(d)));throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 227, column 17 - line 233, column 80: "+[g.constructor.name]);}if(e instanceof n.SOpt&&e.value0===d&&!u&&!b["null"](e.value1))return g=l.fromCharArray(e.value1)+k.maybe("")(function(a){return "\x3d"+a})(e.value2),x.pure(f.applicativeParser)({rawValue:new k.Just(g),
remainder:k.Nothing.value,hasConsumedArg:!1,explicitArg:k.isJust(e.value2)});if(e instanceof n.SOpt&&e.value0===d&&u&&!b["null"](e.value1))return x.pure(f.applicativeParser)({rawValue:k.Nothing.value,hasConsumedArg:!1,explicitArg:k.isJust(e.value2),remainder:x.pure(k.applicativeMaybe)(new n.SOpt(c.head()(e.value1),c.tail()(e.value1),e.value2))});if(e instanceof n.SOpt&&e.value0===d&&u&&b["null"](e.value1)){if(e.value2 instanceof k.Just)return f["fatal'"](m.optionTakesNoArgumentError(new r.Short(e.value0)));
if(e.value2 instanceof k.Nothing)return x.pure(f.applicativeParser)({rawValue:k.Nothing.value,remainder:k.Nothing.value,hasConsumedArg:!1,explicitArg:!1});throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 264, column 7 - line 270, column 26: "+[e.value2.constructor.name]);}return f.fail("Invalid token: "+h.pretty(n.prettyToken)(e))}};return y.bind(f.bindParser)(f.getInput)(function(c){if(c instanceof q.Cons){var d=C.map(k.functorMaybe)(n.getToken)(g.head(c.value1));return y.bind(f.bindParser)(z(c.value0.value0)(d))(function(d){var h=
a&&k.isNothing(d.remainder);if(h){var h=k.maybe([])(function(a){return b.singleton(p.StringValue.create(a))})(d.rawValue),m=k.maybe([])(B["const"]([p.StringValue.create(l.drop(2)(c.value0.value1))]))(d.remainder),h=p.ArrayValue.create(w.append(w.semigroupArray)(m)(h));m=c.value1 instanceof q.Cons&&d.hasConsumedArg?c.value1.value1:c.value1;return C.voidLeft(f.functorParser)(f.setInput(m))(new A(h,!0,!1))}if(!h){var h=k.maybe(new p.BoolValue(!0))(B.flip(p.read)(!1))(d.rawValue),r;r=c.value1 instanceof
q.Cons&&d.hasConsumedArg?c.value1.value1:c.value1;var t="-"+l.drop(2)(c.value0.value1),m=k.maybe(e.empty(q.plusList))(function(a){return g.singleton(new n.PositionedToken(a,t,c.value0.value2))})(d.remainder),v=g.length(m),u=function(){var a=0<v;if(a)return C.mapFlipped(q.functorList)(r)(function(a){return new n.PositionedToken(a.value0,a.value1,a.value2+v|0)});if(!a)return r;throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 193, column 25 - line 196, column 36: "+[a.constructor.name]);
}(),m=w.append(q.semigroupList)(m)(u);return C.voidLeft(f.functorParser)(f.setInput(m))(A.create(h)(!1)(!d.explicitArg))}throw Error("Failed pattern match at Neodoc.ArgParser.Argument line 166, column 9 - line 200, column 60: "+[h.constructor.name]);})}return f.fail("Expected token, met EOF")})}}};a.stdin=E;a.token=z;})(PS["Neodoc.ArgParser.Argument"]=PS["Neodoc.ArgParser.Argument"]||{});
(function(a){var b=PS["Data.Tuple"],c=PS["Data.Optimize.Uncurried"],e=PS["Data.Newtype"],d=PS["Data.List"],g=PS["Data.Function"],k=PS["Data.Either"],l=PS["Data.Maybe"],h=PS["Data.Traversable"],f=PS["Data.Foldable"],m=PS["Control.MonadPlus.Partial"],n=PS["Neodoc.Parsing.Parser"],r=PS["Neodoc.ArgParser.Type"],p=PS["Control.Bind"],t=PS["Control.Applicative"],B=PS["Data.Eq"],q=PS["Data.List.Types"],w=PS["Data.Unit"],x=PS["Data.Functor"],y=PS["Data.Ord"],C=function(){function a(a,b,c,d){this.value0=a;
this.value1=b;this.value2=c;this.value3=d;}a.create=function(b){return function(c){return function(d){return function(e){return new a(b,c,d,e)}}}};return a}(),u=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),A=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),z=function(a){return a instanceof A?!0:!1},E=function(a){return a instanceof u?!0:!1},
F=function(a){if(a instanceof u||a instanceof A)return a.value0.value1.depth;throw Error("Failed pattern match at Neodoc.ArgParser.Evaluate line 64, column 1 - line 64, column 70: "+[a.constructor.name]);};a.ErrorEvaluation=u;a.SuccessEvaluation=A;a.ParserCont=C;a.evalParsers=function(a){return function(b){if(0===d.length(b.value1))return n["fail'"](r.internalError("no parsers to evaluate"));var v=function(a){return function(b){return p.bind(n.bindParser)(b)(function(b){return p.bind(n.bindParser)(h["for"](n.applicativeParser)(q.traversableList)(a)(function(a){if(a instanceof
u||a instanceof A)return a.value0.value2.deepestError instanceof l.Just?r.setErrorAtDepth(a.value0.value2.deepestError.value0.value0)(a.value0.value2.deepestError.value0.value1):t.pure(n.applicativeParser)(w.unit);throw Error("Failed pattern match at Neodoc.ArgParser.Evaluate line 136, column 33 - line 144, column 25: "+[a.constructor.name]);}))(function(){return t.pure(n.applicativeParser)(b)})})}};return p.bind(n.bindParser)(n.getParseState)(function(h){var r=x.mapFlipped(q.functorList)(b.value1)(function(a){return n.runParser(c.Args5.create(h.value0)(h.value1)(h.value2)(h.value3)(new n.Parser(function(b){var c=
n.unParser(a)(b),d=new C(c.value1.value0,c.value1.value1,c.value1.value2,c.value1.value3);return new n.Step(c.value0,c.value1,function(){if(c.value2 instanceof k.Left&&c.value2.value0.value0)return new k.Left(c.value2.value0);if(c.value2 instanceof k.Left)return k.Right.create(new u(d,c.value2.value0));if(c.value2 instanceof k.Right)return k.Right.create(new A(d,c.value2.value0));throw Error("Failed pattern match at Neodoc.ArgParser.Evaluate line 87, column 30 - line 90, column 66: "+[c.value2.constructor.name]);
}())})))});return p.bind(n.bindParser)(function(){var a=m.mlefts(q.monadPlusList)(r);return a instanceof q.Cons?new n.Parser(function(b){return new n.Step(!1,b,new k.Left(a.value0))}):t.pure(n.applicativeParser)(w.unit)}())(function(){var c=m.mrights(q.monadPlusList)(r),t=d.reverse(d.filter(z)(c)),x=d.filter(E)(c),C=g.on(B.eq(B.eqInt))(F),G=g.on(y.compare(y.ordInt))(F),x=d.last(d.groupBy(C)(d.sortBy(G)(x))),H=p.bind(l.bindMaybe)(d.last(d.groupBy(C)(d.sortBy(G)(t))))(function(c){return g.flip(f.maximumBy(q.foldableNonEmptyList))(c)(g.on(y.compare(a))(function(a){var c=
function(a){return function(a){return a}}();if(a instanceof A)a=b.value0(a.value1);else throw Error("Failed pattern match at Neodoc.ArgParser.Evaluate line 109, column 61 - line 110, column 37: "+[a.constructor.name]);return c(a)}))});if(H instanceof l.Just&&H.value0 instanceof A)return v(c)(new n.Parser(function(a){return new n.Step(!0,new n.ParseArgs(H.value0.value0.value0,H.value0.value0.value1,H.value0.value0.value2,H.value0.value0.value3),new k.Right(H.value0.value1))}));if(x instanceof l.Just){var I=
e.unwrap(q.newtypeNonEmptyList)(x.value0);return I.value0 instanceof u&&(d["null"](I.value1)||!d["null"](h.value3))?p.bind(n.bindParser)(v(c)(new n.Parser(function(a){return new n.Step(!1,new n.ParseArgs(I.value0.value0.value0,I.value0.value0.value1,I.value0.value0.value2,I.value0.value0.value3),new k.Right(w.unit))})))(function(){return p.bind(n.bindParser)(n.getState)(function(a){return p.bind(n.bindParser)(n.getGlobalState)(function(b){return b.deepestError instanceof l.Just&&b.deepestError.value0.value0>
a.depth?n["fail'"](b.deepestError.value0.value1):n["throw"](I.value0.value1)})})}):n.fail("")}return n.fail("The impossible happened. Failure without error")})})}};a.fork=function(a){return p.bind(n.bindParser)(n.getConfig)(function(d){return p.bind(n.bindParser)(n.getState)(function(e){return p.bind(n.bindParser)(n.getGlobalState)(function(f){return p.bind(n.bindParser)(n.getInput)(function(g){var h=n.runParser(c.Args5.create(d)(e)(f)(g)(new n.Parser(function(c){var d=n.unParser(a)(c),e=new C(n.getC(d.value1),
n.getS(d.value1),n.getG(d.value1),n.getI(d.value1));c=n.Step;var f=d.value0,g=d.value1;if(d.value2 instanceof k.Left)d=new k.Right(new k.Left(new b.Tuple(n.getG(d.value1),d.value2.value0)));else if(d.value2 instanceof k.Right)d=new k.Right(new k.Right(new b.Tuple(e,d.value2.value0)));else throw Error("Failed pattern match at Neodoc.ArgParser.Evaluate line 174, column 29 - line 176, column 60: "+[d.value2.constructor.name]);return new c(f,g,d)})));return function(a){return function(a){return function(a){return a}}()(function(){if(h instanceof
k.Right&&h.value0 instanceof k.Left)return new n.Parser(function(a){return new n.Step(!1,n.setG(h.value0.value0.value0)(a),new k.Left(h.value0.value0.value1))});if(h instanceof k.Right&&h.value0 instanceof k.Right)return t.pure(n.applicativeParser)(h.value0.value0);throw Error("Failed pattern match at Neodoc.ArgParser.Evaluate line 177, column 17 - line 181, column 32: "+[h.constructor.name]);}())}()})})})})};a.getEvaluationDepth=F;a.isErrorEvaluation=E;a.isSuccessEvaluation=z;a.resume=function(a){return new n.Parser(function(b){return new n.Step(!0,
new n.ParseArgs(a.value0.value0,a.value0.value1,a.value0.value2,a.value0.value3),new k.Right(a.value1))})};})(PS["Neodoc.ArgParser.Evaluate"]=PS["Neodoc.ArgParser.Evaluate"]||{});
(function(a){var b=PS["Data.Maybe"],c=PS["Control.Alt"],e=PS["Neodoc.Env"],d=PS["Neodoc.Value"],g=PS["Neodoc.Value.Origin"],k=PS["Neodoc.Value.RichValue"],l=PS["Neodoc.Data.SolvedLayout"],h=PS["Neodoc.Data.Description"],f=PS["Data.Functor"],m=PS["Control.Applicative"];a.getFallbackValue=function(a){return function(n){return function(p){return function(r){var t=function(){return function(c){if(c instanceof l.Option&&c.value1 instanceof b.Nothing&&!a.requireFlags){var e=m.pure(b.applicativeMaybe);if(c.value2)c=
new d.ArrayValue([]);else {if(c.value2)throw Error("Failed pattern match at Neodoc.ArgParser.Fallback line 54, column 14 - line 55, column 39: "+[c.value2.constructor.name]);c=new d.BoolValue(!1);}return e(c)}if(c instanceof l.Option&&c.value1 instanceof b.Just&&c.value1.value0.value1&&!a.requireFlags){e=m.pure(b.applicativeMaybe);if(c.value2)c=new d.ArrayValue([]);else {if(c.value2)throw Error("Failed pattern match at Neodoc.ArgParser.Fallback line 58, column 14 - line 59, column 39: "+[c.value2.constructor.name]);
c=new d.BoolValue(!1);}return e(c)}return c instanceof l.Stdin?m.pure(b.applicativeMaybe)(new d.BoolValue(!1)):c instanceof l.EOA?m.pure(b.applicativeMaybe)(new d.ArrayValue([])):b.Nothing.value}}();return c.alt(b.altMaybe)(c.alt(b.altMaybe)(f.mapFlipped(b.functorMaybe)(function(a){return a instanceof b.Just&&a.value0 instanceof h.OptionDescription&&a.value0.value4 instanceof b.Just?f.map(b.functorMaybe)(d.StringValue.create)(e.lookup(a.value0.value4.value0)(n)):b.Nothing.value}(p))(k.from(g.Environment.value)))(f.mapFlipped(b.functorMaybe)(function(a){return function(c){if(a instanceof
l.Option&&c instanceof b.Just&&c.value0 instanceof h.OptionDescription&&c.value0.value3 instanceof b.Just){var e=m.pure(b.applicativeMaybe);if(a.value2)c=d.ArrayValue.create(d.intoArray(c.value0.value3.value0));else {if(a.value2)throw Error("Failed pattern match at Neodoc.ArgParser.Fallback line 44, column 12 - line 46, column 21: "+[a.value2.constructor.name]);c=c.value0.value3.value0;}return e(c)}return b.Nothing.value}}(r)(p))(k.from(g.Default.value))))(f.mapFlipped(b.functorMaybe)(t(r))(k.from(g.Empty.value)))}}}};})(PS["Neodoc.ArgParser.Fallback"]=
PS["Neodoc.ArgParser.Fallback"]||{});(function(a){var b=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}();a.ArgParseResult=b;a.getResult=function(a){return a.value1};})(PS["Neodoc.ArgParser.Result"]=PS["Neodoc.ArgParser.Result"]||{});
(function(a){var b=PS["Data.List"],c=PS["Data.Array"],e=PS["Data.Optimize.Uncurried"],d=PS["Data.List.Partial"],g=PS["Data.Bifunctor"],k=PS["Data.List.NonEmpty"],l=PS["Data.Function"],h=PS["Data.Tuple"],f=PS["Data.Either"],m=PS["Data.String"],n=PS["Data.NonEmpty"],r=PS["Data.Maybe"],p=PS["Data.Traversable"],t=PS["Data.Foldable"],B=PS["Data.Map"],q=PS["Control.Alt"],w=PS["Control.MonadPlus.Partial"],x=PS["Control.Monad.State"],y=PS["Data.NonEmpty.Extra"],C=PS["Neodoc.Value"],u=PS["Neodoc.Value.RichValue"],
A=PS["Neodoc.Value.Origin"],z=PS["Neodoc.Data.Layout"],E=PS["Neodoc.Data.Description"],F=PS["Neodoc.Data.SolvedLayout"],G=PS["Neodoc.OptionAlias"],I=PS["Neodoc.ArgKey.Class"],v=PS["Neodoc.Parsing.Parser"],H=PS["Neodoc.Parsing.Parser.Combinators"],L=PS["Neodoc.ArgParser.Type"],J=PS["Neodoc.ArgParser.Token"],K=PS["Neodoc.ArgParser.Argument"],S=PS["Neodoc.ArgParser.Evaluate"],R=PS["Neodoc.ArgParser.Fallback"],P=PS["Neodoc.ArgParser.Result"],N=PS["Neodoc.ArgParser.Arg"],O=PS["Neodoc.ArgParser.ParseLayout"],
D=PS["Data.List.Types"],M=PS["Data.Functor"],U=PS["Control.Apply"],X=PS["Control.Monad.State.Trans"],T=PS["Data.Identity"],ca=PS["Control.Monad.State.Class"],da=PS["Data.Semiring"],Q=PS["Control.Bind"],Y=PS["Control.Applicative"],W=PS["Data.Unfoldable"],Z=PS["Data.HeytingAlgebra"],ea=PS["Data.Eq"],V=PS["Data.Semigroup"],aa=PS["Data.Ord"],ja=PS["Control.Monad"],oa=function(a){if(a instanceof D.Nil)return D.Nil.value;if(a instanceof D.Cons){var b=function(a){if(a instanceof O.ParseElem)return z.Elem.create(N.getArg(a.value2));
if(a instanceof O.ParseGroup)return z.Group.create(a.value2)(a.value3)(M.map(n.functorNonEmpty(D.functorList))(function(a){return M.map(n.functorNonEmpty(D.functorList))(b)(a)})(a.value4));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 768, column 1 - line 768, column 25: "+[a.constructor.name]);};return new D.Cons(b(a.value0),oa(a.value1))}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 768, column 1 - line 768, column 25: "+[a.constructor.name]);},ba=function(a){var b=
U.applyFirst(X.applyStateT(T.monadIdentity))(ca.get(X.monadStateStateT(T.monadIdentity)))(ca.modify(X.monadStateStateT(T.monadIdentity))(function(a){return a+1|0})),c=function(a){if(a instanceof z.Elem)return Q.bind(X.bindStateT(T.monadIdentity))(b)(function(b){return Y.pure(X.applicativeStateT(T.monadIdentity))(new O.ParseElem(b,N.isFreeLayout(a),N.setId(b)(a.value0)))});if(a instanceof z.Group)return Q.bind(X.bindStateT(T.monadIdentity))(b)(function(b){return M.map(X.functorStateT(T.functorIdentity))(O.ParseGroup.create(b)(N.isFreeLayout(a))(a.value0)(a.value1))(p["for"](X.applicativeStateT(T.monadIdentity))(n.traversableNonEmpty(D.traversableList))(a.value2)(p.traverse(n.traversableNonEmpty(D.traversableList))(X.applicativeStateT(T.monadIdentity))(c)))});
throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 754, column 1 - line 763, column 27: "+[a.constructor.name]);};return x.evalState(p["for"](X.applicativeStateT(T.monadIdentity))(D.traversableList)(a)(c))(0)},wa=function(a){return function(b){return function(c){return function(d){var e=function(d){if(d instanceof z.Elem){var f;f=d.value0 instanceof F.Option?L.findDescription(d.value0.value0)(c):r.Nothing.value;f=Q.bind(r.bindMaybe)(M.map(r.functorMaybe)(u.unRichValue)(R.getFallbackValue(a)(b)(f)(d.value0)))(function(a){var b=
Y.pure(r.applicativeMaybe),c={},e;for(e in a)({}).hasOwnProperty.call(a,e)&&(c[e]=a[e]);if(e=F.isElemRepeatable(d.value0))a=C.ArrayValue.create(C.intoArray(a.value));else {if(e)throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 800, column 21 - line 802, column 35: "+[e.constructor.name]);a=a.value;}c.value=a;return b(c)});return z.Elem.create(new N.Arg(0,d.value0,I.toArgKey(F.toArgKeySolvedLayoutArg)(d.value0),f,!1))}if(d instanceof z.Group)return z.Group.create(d.value0)(d.value1)(M.map(n.functorNonEmpty(D.functorList))(function(a){return M.map(n.functorNonEmpty(D.functorList))(e)(a)})(d.value2));
throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 791, column 1 - line 811, column 52: "+[d.constructor.name]);};return M.map(n.functorNonEmpty(D.functorList))(e)(d)}}}},ma=function(a){return Q.bind(v.bindParser)(v.getInput)(function(a){var c=C.ArrayValue.create(b.toUnfoldable(W.unfoldableArray)(M.map(D.functorList)(function(a){return C.StringValue.create(J.getSource(a))})(a)));return Q.bind(v.bindParser)(L.setDone)(function(){return Q.bind(v.bindParser)(L.setDepth(99999))(function(){return Q.bind(v.bindParser)(v.setInput(D.Nil.value))(function(){return v["return"](c)})})})})},
pa=function(a){a=a instanceof O.ParseGroup&&a.value4.value0.value0 instanceof O.ParseElem&&a.value4.value0.value0.value2.value1 instanceof F.Positional&&a.value4.value0.value1 instanceof D.Nil&&a.value4.value1 instanceof D.Nil&&(a.value3||a.value4.value0.value0.value2.value1.value1)?new r.Just(a.value4.value0.value0.value2):a instanceof O.ParseElem&&a.value2.value1 instanceof F.Positional&&a.value2.value1.value1?new r.Just(a.value2):r.Nothing.value;return a},sa=function(a){return function(b){if(b instanceof
F.Positional)return K.positional(b.value0)(b.value0);if(b instanceof F.Command)return K.command(b.value0)(b.value0);if(b instanceof F.Stdin)return K.stdin;if(b instanceof F.EOA)return q.alt(v.altParser)(K.eoa)(v["return"](new C.ArrayValue([])));if(b instanceof F.Option)return Q.bind(v.bindParser)(v.getParseState)(function(d){return d.value3 instanceof D.Cons&&(d.value3.value0.value0 instanceof J.LOpt||d.value3.value0.value0 instanceof J.SOpt)?Q.bind(v.bindParser)(Q.bind(v.bindParser)(L["lookupDescription'"](b.value0))(function(a){return a instanceof
E.OptionDescription?v["return"](new h.Tuple(a.value0,new h.Tuple(a.value3,a.value4))):v["fail'"](L.internalError("invalid option description"))}))(function(e){var g=t.any(n.foldableNonEmpty(D.foldableList))(Z.heytingAlgebraBoolean)(function(a){return t.elem(t.foldableArray)(ea.eqString)(a)(d.value0.options.stopAt)})(M.mapFlipped(n.functorNonEmpty(D.functorList))(e.value0)(function(a){if(a instanceof G.Short)return "-"+m.singleton(a.value0);if(a instanceof G.Long)return "--"+a.value0;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 713, column 64 - line 715, column 55: "+
[a.constructor.name]);}));e=y.toList(M.mapFlipped(n.functorNonEmpty(D.functorList))(e.value0)(function(a){if(a instanceof G.Short)return new f.Left(a.value0);if(a instanceof G.Long)return new f.Right(a.value0);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 708, column 48 - line 710, column 49: "+[a.constructor.name]);}));var h=w.mlefts(D.monadPlusList)(e),k=w.mrights(D.monadPlusList)(e);return Q.bind(v.bindParser)(function(a){return function(a){return function(a){return a}}()(function(){if(d.value3.value0.value0 instanceof
J.LOpt)return k instanceof D.Nil?v.fail("Option has no long alias"):H.choice(D.foldableList)(M.mapFlipped(D.functorList)(k)(function(a){return H["try"](K.longOption(g)(a)(b.value1))}));if(d.value3.value0.value0 instanceof J.SOpt)return h instanceof D.Nil?v.fail("Option has no short alias"):H.choice(D.foldableList)(M.mapFlipped(D.functorList)(h)(function(a){return H["try"](K.shortOption(g)(a)(b.value1))}));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 718, column 55 - line 728, column 50: "+
[d.value3.value0.value0.constructor.name]);}())}())(function(d){var e=g&&d.value1;if(e)return Q.bind(v.bindParser)(ma())(function(a){return v["return"](new C.ArrayValue(V.append(V.semigroupArray)(C.intoArray(d.value0))(C.intoArray(a))))});if(!e){if(e=r.isJust(b.value1)&&b.value2&&d.value2)return Q.bind(v.bindParser)(c.many(v.alternativeParser)(v.lazyParser)(K.optionArgument))(function(a){return v["return"](new C.ArrayValue(V.append(V.semigroupArray)(C.intoArray(d.value0))(a)))});if(!e)return v["return"](d.value0);
throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 736, column 17 - line 740, column 34: "+[e.constructor.name]);}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 731, column 11 - line 740, column 34: "+[e.constructor.name]);})}):v.fail("Expected long or short option")});throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 688, column 3 - line 688, column 46: "+[b.constructor.name]);}(a)},ta=function(a){return function(b){var c=function(){var c=function(a){if(a instanceof
z.Group)return t.any(n.foldableNonEmpty(D.foldableList))(Z.heytingAlgebraBoolean)(t.any(n.foldableNonEmpty(D.foldableList))(Z.heytingAlgebraBoolean)(c))(a.value2);if(a instanceof z.Elem)return function(a){return function(b){return a instanceof J.LOpt&&b instanceof F.Option?ea.eq(G.eqOptionAlias)(new G.Long(a.value0))(b.value0):a instanceof J.SOpt&&b instanceof F.Option?ea.eq(G.eqOptionAlias)(new G.Short(a.value0))(b.value0):a instanceof J.Lit&&b instanceof F.Command?a.value0===b.value0:a instanceof
J.EOA&&b instanceof F.EOA||a instanceof J.Stdin&&b instanceof F.Stdin?!0:!1}}(b)(a.value0);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 865, column 3 - line 872, column 26: "+[a.constructor.name]);};return t.any(n.foldableNonEmpty(D.foldableList))(Z.heytingAlgebraBoolean)(t.any(D.foldableList)(Z.heytingAlgebraBoolean)(t.any(n.foldableNonEmpty(D.foldableList))(Z.heytingAlgebraBoolean)(c)))(a.layouts)}();return function(){return t.any(D.foldableList)(Z.heytingAlgebraBoolean)(function(a){return a instanceof
E.OptionDescription?(a=b instanceof J.LOpt?t.elem(n.foldableNonEmpty(D.foldableList))(G.eqOptionAlias)(new G.Long(b.value0))(a.value0):b instanceof J.SOpt?t.elem(n.foldableNonEmpty(D.foldableList))(G.eqOptionAlias)(new G.Short(b.value0))(a.value0):!1,a):!1})(a.descriptions)}()||c}},la=function(a){return Q.bind(v.bindParser)(v.getParseState)(function(b){var c=B.lookup(J.ordToken)(a)(b.value2.isKnownCache);if(c instanceof r.Just)return v["return"](c.value0);if(c instanceof r.Nothing){var d=ta(b.value0.spec)(a);
return M.voidRight(v.functorParser)(d)(v.modifyGlobalState(function(b){var c={},e;for(e in b)({}).hasOwnProperty.call(b,e)&&(c[e]=b[e]);c.isKnownCache=B.alter(J.ordToken)(l["const"](new r.Just(d)))(a)(b.isKnownCache);return c}))}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 848, column 3 - line 854, column 12: "+[c.constructor.name]);})},ia=function(a){return function(b){return ea.eq(A.eqOrigin)(a)(u.getOrigin(b))}},ga={depth:0,hasTerminated:!1},ha={deepestError:r.Nothing.value,
isKnownCache:B.empty,matchCache:B.empty,argCache:B.empty},fa=function(a){return t.sum(D.foldableList)(da.semiringInt)(M.map(D.functorList)(function(a){return A.weight(u.unRichValue(h.snd(a)).origin)})(a))},na=function(){var a=new F.Command("?",!0),b=I.toArgKey(F.toArgKeySolvedLayoutArg)(a);return new N.Arg(-1,a,b,r.Nothing.value,!0)}(),qa=Q.bind(v.bindParser)(v.getInput)(function(a){return a instanceof D.Cons&&(a.value0.value0 instanceof J.LOpt||a.value0.value0 instanceof J.SOpt)?Q.bind(v.bindParser)(la(a.value0.value0))(function(b){if(b)return v.fail("expected unknown option");
if(!b)return M.voidLeft(v.functorParser)(U.applySecond(v.applyParser)(v.setInput(a.value1))(L.modifyDepth(function(a){return a+1|0})))(new h.Tuple(na,u.from(A.Argv.value)(new C.StringValue(a.value0.value1))));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 832, column 7 - line 836, column 79: "+[b.constructor.name]);}):v.fail("expected unknown option")}),va=function(a){var c=function(a){return function(c){return g.lmap(h.bifunctorTuple)(b.reverse)(function(b){return function(c){var d=
b;a:for(;;){if(d instanceof D.Nil)return new h.Tuple(c,!1);if(d instanceof D.Cons){var e=a(d.value0);if(e)return new h.Tuple(V.append(D.semigroupList)(d.value1)(c),!0);if(!e){e=d.value1;c=new D.Cons(d.value0,c);d=e;continue a}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 598, column 28 - line 598, column 79: "+[e.constructor.name]);}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 456, column 3 - line 456, column 75: "+[d.constructor.name,c.constructor.name]);
}}}(c)(D.Nil.value))}},f=function(a){return new O.ParseElem(N.getId(a),!0,a)},k=function(a){return new h.Tuple(a.value1.value0,a.value1.value1)},m=function(a){return function(b){return new e.Args4(a(b.value0),b.value1,b.value2,b.value3)}},n=function(b){return 0<=N.getId(b)?N.isArgRepeatable(b)||a.value1&&N.isOption(b):!1},u=function(a){if(a instanceof O.ParseGroup||a instanceof O.ParseElem)return !a.value1;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 604, column 3 - line 604, column 42: "+
[a.constructor.name]);},w=function(a){return a.value0},x=function(a){var f=function(g){if(g.value2 instanceof D.Cons)return v["catch"](function(){var b=u(g.value2.value0)&&g.value1;if(b)return f(new e.Args5(g.value0,!0,g.value2.value1,new D.Cons(g.value2.value0,g.value3),g.value4));if(!b)return b=a.value1&&!g.value1,Q.bind(v.bindParser)(S.fork(ua(a.value0+1|0)(b)(g.value2.value0)))(function(a){return f(new e.Args5(g.value0,g.value1||u(g.value2.value0),g.value2.value1,g.value3,new D.Cons(new h.Tuple(g.value2.value0,
a),g.value4)))});throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 476, column 7 - line 496, column 79: "+[b.constructor.name]);}())(function(a){return function(b){b=g.value0 instanceof r.Just&&a.depth>g.value0.value0.value0||g.value0 instanceof r.Nothing?new r.Just(new h.Tuple(a.depth,b)):g.value0;return f(new e.Args5(b,g.value1||u(g.value2.value0),g.value2.value1,new D.Cons(g.value2.value0,g.value3),g.value4))}});if(g.value2 instanceof D.Nil&&g.value4 instanceof D.Nil)return Q.bind(v.bindParser)(v.getInput)(function(d){var m=
b.sortBy(l.on(aa.compare(aa.ordInt))(O.getId))(g.value3);return Q.bind(v.bindParser)(v["return"](function(){if(g.value1)return c(function(a){return (a instanceof O.ParseGroup?a.value2:!1)&&u(a)})(m);if(!g.value1)return new h.Tuple(m,!1);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 518, column 8 - line 520, column 26: "+[g.value1.constructor.name]);}()))(function(c){var d=function(){if(a.value1)return b.filter(function(a){return !(a instanceof O.ParseGroup&&a.value2)})(c.value0);
if(!a.value1)return c.value0;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 530, column 12 - line 530, column 72: "+[a.value1.constructor.name]);}();if(d instanceof D.Nil){var l=b.catMaybes(M.mapFlipped(D.functorList)(c.value0)(function(a){return a instanceof O.ParseElem?Q.bind(r.bindMaybe)(N.getFallback(a.value2))(function(b){return new r.Just(new h.Tuple(a,new h.Tuple(a.value2,b)))}):r.Nothing.value}));return v["return"](new e.Args4(M.map(D.functorList)(k)(l),M.map(D.functorList)(w)(l),
g.value1||c.value1,r.Nothing.value))}if(c.value1)return f(new e.Args5(g.value0,!1,d,D.Nil.value,D.Nil.value));if(d instanceof D.Cons)return Q.bind(v.bindParser)(v.getInput)(function(a){return Q.bind(v.bindParser)(v.getState)(function(b){if(g.value0 instanceof r.Just&&g.value0.value0.value0>b.depth)return Q.bind(v.bindParser)(L.setErrorAtDepth(g.value0.value0.value0)(v.extractError(L.genericError)(g.value0.value0.value1)))(function(){return v["throw"](g.value0.value0.value1)});if(a instanceof D.Nil){var c=
oa(d),c=L.missingArgumentsError(y["fromList'"]()(c));return U.applySecond(v.applyParser)(L.setErrorAtDepth(b.depth)(c))(v["fail'"](c))}return Q.bind(v.bindParser)(p["for"](v.applicativeParser)(D.traversableList)(a)(function(a){return Q.bind(v.bindParser)(la(a.value0))(function(b){return v["return"](function(){if(b)return L.known(a);if(!b)return L.unknown(a);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 568, column 26 - line 570, column 38: "+[b.constructor.name]);}())})}))(function(a){a=
L.unexpectedInputError(oa(d))(a);return U.applySecond(v.applyParser)(L.setErrorAtDepth(b.depth)(a))(v["fail'"](a))})})});throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 530, column 7 - line 572, column 51: "+[d.constructor.name]);})});if(g.value2 instanceof D.Nil&&g.value4 instanceof D.Cons){var m=b.sortBy(l.on(aa.compare(aa.ordInt))(function(a){return fa(h.snd(h.snd(a)))}))(g.value4),n=h.fst(d.last()(m)),q=function(){var a;if(n instanceof O.ParseElem)a=N.isArgRepeatable(n.value2);
else if(n instanceof O.ParseGroup)a=n.value3;else throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 616, column 3 - line 616, column 64: "+[n.constructor.name]);if(a)return new r.Just(n);if(!a)return r.Nothing.value;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 588, column 17 - line 588, column 66: "+[a.constructor.name]);}(),t=M.map(D.functorList)(h.fst)(d.init()(m)),m=h.snd(d.last()(m)),x=h.snd(m);return Q.bind(v.bindParser)(S.resume(m))(function(){return v["return"](new e.Args4(x,
b.sortBy(l.on(aa.compare(aa.ordInt))(O.getId))(V.append(D.semigroupList)(t)(g.value3)),g.value1,q))})}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 466, column 3 - line 594, column 79: "+[g.constructor.name]);};return f(new e.Args5(r.Nothing.value,!1,a.value2,D.Nil.value,D.Nil.value))},z=function(c){return Q.bind(v.bindParser)(v.getParseState)(function(d){var g=Q.bind(v.bindParser),k;if(d.value0.options.allowUnknown)k=H.many(qa);else {if(d.value0.options.allowUnknown)throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 322, column 17 - line 322, column 78: "+
[d.value0.options.allowUnknown.constructor.name]);k=Y.pure(v.applicativeParser)(D.Nil.value);}return g(k)(function(g){return Q.bind(v.bindParser)(q.alt(v.altParser)(M.map(v.functorParser)(m(r.Just.create))(H["try"](x(new e.Args3(c.value0+1|0,!1,c.value2)))))(v["return"](new e.Args4(r.Nothing.value,c.value2,!1,r.Nothing.value))))(function(k){if(k.value0 instanceof r.Just&&k.value0.value0 instanceof D.Cons){var p=M.map(D.functorList)(f)(b.filter(n)(M.map(D.functorList)(h.fst)(k.value0.value0))),p=b.nub(O.eqParseLayout)(V.append(D.semigroupList)(r.maybe(D.Nil.value)(b.singleton)(k.value3))(V.append(D.semigroupList)(c.value3)(p)));
return z(new e.Args6(c.value0+1|0,c.value1,k.value1,p,!0,V.append(D.semigroupList)(c.value5)(V.append(D.semigroupList)(g)(k.value0.value0))))}return Q.bind(v.bindParser)(function(){if(c.value4)return q.alt(v.altParser)(M.map(v.functorParser)(m(r.Just.create))(H["try"](x(new e.Args3(c.value0+1|0,!1,c.value3)))))(v["return"](new e.Args4(r.Nothing.value,c.value3,!1,r.Nothing.value)));if(!c.value4){if(d.value0.options.repeatableOptions){var a=l.flip(b.filter)(c.value3)(function(a){return a instanceof
O.ParseElem?n(a.value2):!1});return q.alt(v.altParser)(M.map(v.functorParser)(m(r.Just.create))(H["try"](x(new e.Args3(c.value0+1|0,!1,a)))))(v["return"](new e.Args4(r.Nothing.value,c.value3,!1,r.Nothing.value)))}if(!d.value0.options.repeatableOptions)return v["return"](new e.Args4(r.Nothing.value,c.value3,!1,r.Nothing.value));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 365, column 18 - line 372, column 60: "+[d.value0.options.repeatableOptions.constructor.name]);}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 361, column 11 - line 372, column 60: "+
[c.value4.constructor.name]);}())(function(d){if(d.value0 instanceof r.Just&&d.value0.value0 instanceof D.Cons){var l=M.map(D.functorList)(f)(b.filter(n)(M.map(D.functorList)(h.fst)(d.value0.value0))),l=b.nub(O.eqParseLayout)(V.append(D.semigroupList)(r.maybe(D.Nil.value)(b.singleton)(d.value3))(V.append(D.semigroupList)(d.value1)(l))),m=t.any(D.foldableList)(Z.heytingAlgebraBoolean)(function(a){return ia(A.Argv.value)(h.snd(a))})(d.value0.value0);if(m)return z(new e.Args6(c.value0+1|0,c.value1,c.value2,
l,!0,V.append(D.semigroupList)(c.value5)(V.append(D.semigroupList)(g)(d.value0.value0))));if(!m)return z(new e.Args6(c.value0+1|0,c.value1,c.value2,l,!1,V.append(D.semigroupList)(c.value5)(V.append(D.semigroupList)(g)(d.value0.value0))));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 378, column 13 - line 380, column 85: "+[m.constructor.name]);}if(k.value1 instanceof D.Nil)return v["return"](V.append(D.semigroupList)(c.value5)(g));if(k.value1 instanceof D.Cons&&a.value2){var p=
function(a){return function(d){return a instanceof D.Nil?v["return"](d):Q.bind(v.bindParser)(H["try"](x(new e.Args3(c.value0+1|0,!0,a))))(function(a){var f=!b["null"](a.value0)&&(t.any(D.foldableList)(Z.heytingAlgebraBoolean)(function(a){return ia(A.Argv.value)(h.snd(a))})(a.value0)||a.value2);if(f)return z(new e.Args6(c.value0+1|0,!1,a.value1,c.value3,!0,V.append(D.semigroupList)(d)(a.value0)));if(!f)return p(a.value1)(V.append(D.semigroupList)(d)(a.value0));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 410, column 21 - line 412, column 58: "+
[f.constructor.name]);})}};return p(k.value1)(V.append(D.semigroupList)(c.value5)(g))}return v.fail("...")})})})})};return L.skipIf(L.hasTerminated)(D.Nil.value)(z(new e.Args6(a.value0,a.value2,a.value3,D.Nil.value,!0,D.Nil.value)))},ua=function(a){return function(c){return function(d){var f=function(d){return function(f){if(d.optionsFirst&&r.isJust(pa(f))){var g=r.fromJust()(pa(f));return M.map(v.functorParser)(function(a){return b.singleton(h.Tuple.create(g)(u.from(A.Argv.value)(a)))})(ma(N.getArg(g)))}if(f instanceof
O.ParseGroup){var k=function(a){return function(b){return Q.bind(v.bindParser)(q.alt(v.altParser)(a)(v["return"](D.Nil.value)))(function(c){var d=t.any(D.foldableList)(Z.heytingAlgebraBoolean)(function(a){return ia(A.Argv.value)(h.snd(a))})(c);if(d)return k(a)(V.append(D.semigroupList)(b)(c));if(!d)return v["return"](V.append(D.semigroupList)(b)(c));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 659, column 9 - line 661, column 34: "+[d.constructor.name]);})}},l=M.mapFlipped(D.functorList)(y.toList(f.value4))(function(b){b=
y.toList(b);return ra(new e.Args3(a,!0,b))}),m=S.evalParsers(aa.ordInt)(new e.Args2(fa,l));return Q.bind(v.bindParser)(m)(function(a){var b=f.value3&&t.any(D.foldableList)(Z.heytingAlgebraBoolean)(function(a){return ia(A.Argv.value)(h.snd(a))})(a);if(b)return k(m)(a);if(!b)return v["return"](a);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 652, column 7 - line 654, column 23: "+[b.constructor.name]);})}if(f instanceof O.ParseElem){var l=N.getArg(f.value2),n=U.applyFirst(v.applyParser)(M.map(v.functorParser)(u.from(A.Argv.value))(sa(l)))(L.modifyDepth(function(a){return a+
1|0}));if(c)return M.map(v.functorParser)(function(a){return b.singleton(h.Tuple.create(f.value2)(a))})(function(){var a=N.getFallback(f.value2);return a instanceof r.Just?q.alt(v.altParser)(n)(v["return"](a.value0)):n}());if(!c)return function(){var a=N.isArgRepeatable(f.value2);if(a)return b.some(v.alternativeParser)(v.lazyParser);if(!a)return ja.liftM1(v.monadParser)(b.singleton);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 676, column 24 - line 676, column 80: "+[a.constructor.name]);
}()(M.map(v.functorParser)(h.Tuple.create(f.value2))(n));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 671, column 7 - line 677, column 44: "+[c.constructor.name]);}throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 640, column 3 - line 643, column 33: "+[d.constructor.name,f.constructor.name]);}};return L.skipIf(L.hasTerminated)(D.Nil.value)(Q.bind(v.bindParser)(v.getConfig)(function(a){var b=Q.bind(v.bindParser),c;if(a.options.allowUnknown)c=H.many(qa);else {if(a.options.allowUnknown)throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 635, column 10 - line 635, column 72: "+
[a.options.allowUnknown.constructor.name]);c=Y.pure(v.applicativeParser)(D.Nil.value);}return b(c)(function(b){return Q.bind(v.bindParser)(f(a.options)(d))(function(a){return Y.pure(v.applicativeParser)(V.append(D.semigroupList)(b)(a))})})}))}}},ra=function(a){if(a.value2 instanceof D.Nil)return v["return"](D.Nil.value);var c=function(a){if(a instanceof O.ParseGroup||a instanceof O.ParseElem)return a.value1;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 273, column 3 - line 273, column 37: "+
[a.constructor.name]);};return Q.bind(v.bindParser)(v.getConfig)(function(d){var f=function(){var e=!d.options.laxPlacement;if(e)return M.map(D.functorList)(k.toList)(b.groupBy(l.on(ea.eq(ea.eqBoolean))(c))(a.value2));if(!e)return b.singleton(a.value2);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 259, column 13 - line 261, column 30: "+[e.constructor.name]);}();return M.map(v.functorParser)(b.concat)(p["for"](v.applicativeParser)(D.traversableList)(f)(function(b){var c=va(new e.Args4(a.value0,
d.options.repeatableOptions,a.value1,b));if(d.options.allowUnknown)return Q.bind(v.bindParser)(H.many(qa))(function(a){return Q.bind(v.bindParser)(c)(function(b){return Y.pure(v.applicativeParser)(V.append(D.semigroupList)(a)(b))})});if(!d.options.allowUnknown)return c;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 264, column 9 - line 269, column 17: "+[d.options.allowUnknown.constructor.name]);}))})},ka=function(){var a=I.toArgKey(F.toArgKeySolvedLayoutArg)(F.EOA.value);return new N.Arg(-2,
F.EOA.value,a,r.Nothing.value,!0)}();a._EOA=ka;a._UNKNOWN_ARG=na;a.byOrigin=fa;a.initialGlobalState=ha;a.initialState=ga;a.isFrom=ia;a.isKnownToken=ta;a.parse=function(a){return function(d){return function(f){return function(g){var k=function(){return Q.bind(v.bindParser)(v.getInput)(function(a){return a instanceof D.Nil?Y.pure(v.applicativeParser)(D.Nil.value):Q.bind(v.bindParser)(v.getConfig)(function(d){return Q.bind(v.bindParser)(p["for"](v.applicativeParser)(D.traversableList)(a)(function(a){return Q.bind(v.bindParser)(la(a.value0))(function(b){return v["return"](function(){if(b)return L.known(a);
if(!b)return L.unknown(a);throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 179, column 18 - line 181, column 30: "+[b.constructor.name]);}())})}))(function(a){if(d.options.allowUnknown){var e=b.filter(L.isUnknown)(a),f=b.filter(L.isKnown)(a);if(f=b["null"](f)){a=b.filter(function(a){a=L.unIsKnown(a).value0 instanceof J.Lit?!0:!1;return a})(e);if(f=b["null"](a))return v["return"](M.mapFlipped(D.functorList)(e)(function(a){a=L.unIsKnown(a);a.value0 instanceof J.EOA?(a=C.ArrayValue.create(c.fromFoldable(D.foldableList)(a.value0.value0)),
a=u.from(A.Argv.value)(a),a=new h.Tuple(ka,a)):(a=C.StringValue.create(J.getSource(a)),a=u.from(A.Argv.value)(a),a=new h.Tuple(na,a));return a}));if(!f)return v["fail'"](L.unexpectedInputError(D.Nil.value)(a));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 193, column 25 - line 205, column 69: "+[f.constructor.name]);}if(!f)return v["fail'"](L.unexpectedInputError(D.Nil.value)(a));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 188, column 17 - line 206, column 62: "+
[f.constructor.name]);}if(!d.options.allowUnknown)return v["fail'"](L.unexpectedInputError(D.Nil.value)(a));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 184, column 9 - line 207, column 54: "+[d.options.allowUnknown.constructor.name]);})})})}(),l=function(a){return function(b){var c=function(a){return new F.Option(a,r.Nothing.value,!0)};if(a instanceof D.Nil)return r.Nothing.value;if(a instanceof D.Cons)return new r.Just(function(){var d=new n.NonEmpty(c(a.value0),M.map(D.functorList)(c)(a.value1)),
f=new n.NonEmpty(z.Group.create(b)(!0)(M.mapFlipped(n.functorNonEmpty(D.functorList))(d)(function(a){return new n.NonEmpty(new z.Elem(a),D.Nil.value)})),D.Nil.value),d=new n.NonEmpty(z.Group.create(b)(!0)(M.mapFlipped(n.functorNonEmpty(D.functorList))(d)(function(a){return new n.NonEmpty(z.Elem.create(new N.Arg(0,a,I.toArgKey(F.toArgKeySolvedLayoutArg)(a),function(){if(b)return r.Just.create(u.from(A.Empty.value)(new C.BoolValue(!1)));if(!b)return r.Nothing.value;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 236, column 36 - line 238, column 49: "+
[b.constructor.name]);}(),!1)),D.Nil.value)})),D.Nil.value),d=ba(y.toList(d));return U.applyFirst(v.applyParser)(M.map(v.functorParser)(P.ArgParseResult.create(new r.Just(f)))(ra(new e.Args3(0,!0,d))))(k)}());throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 227, column 33 - line 244, column 55: "+[a.constructor.name]);}},m=Q.bind(v.bindParser)(v.getConfig)(function(a){if(a.options.allowUnknown)a=r.Just.create(new n.NonEmpty(z.Elem.create(N.getArg(na)),new D.Cons(z.Elem.create(N.getArg(ka)),
D.Nil.value)));else {if(a.options.allowUnknown)throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 215, column 19 - line 220, column 33: "+[a.options.allowUnknown.constructor.name]);a=r.Nothing.value;}return M.map(v.functorParser)(P.ArgParseResult.create(a))(k)}),x=b.concat(y.toList(a.layouts)),w=M.mapFlipped(D.functorList)(x)(function(b){var c=wa(d)(f)(a.descriptions)(b),c=ba(y.toList(c));return Q.bind(v.bindParser)(ra(new e.Args3(0,!0,c)))(function(a){return Q.bind(v.bindParser)(k)(function(c){var e=
function(){if(d.allowUnknown)return y.append(D.semigroupList)(D.applicativeList)(M.map(n.functorNonEmpty(D.functorList))(function(a){return z.Elem.create(N.getArg(a))})(new n.NonEmpty(na,new D.Cons(ka,D.Nil.value))))(b);if(!d.allowUnknown)return b;throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 137, column 29 - line 141, column 30: "+[d.allowUnknown.constructor.name]);}();return v["return"](new P.ArgParseResult(new r.Just(e),V.append(D.semigroupList)(a)(c)))})})}),x=t.any(n.foldableNonEmpty(D.foldableList))(Z.heytingAlgebraBoolean)(b["null"])(a.layouts),
w=V.append(D.semigroupList)(w);if(x)x=b.singleton(m);else {if(x)throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 152, column 14 - line 152, column 61: "+[x.constructor.name]);x=D.Nil.value;}var B=w(x);return v.runParser(e.Args5.create({env:f,options:d,spec:a})(ga)(ha)(g)(function(){var a=function(){var a=b["null"](B);if(a)return m;if(!a)return S.evalParsers(aa.ordInt)(new e.Args2(function(a){return fa(P.getResult(a))},B));throw Error("Failed pattern match at Neodoc.ArgParser.Parser line 155, column 17 - line 157, column 77: "+
[a.constructor.name]);}();return v["catch"](a)(function(a){return function(a){var b=V.append(D.semigroupList)(d.helpFlags)(d.versionFlags),b=l(b)(!1);return b instanceof r.Just?q.alt(v.altParser)(b.value0)(v["throw"](a)):v["throw"](a)}})}()))}}}};a.parseArg=sa;a.parseBranch=ra;a.parseLayout=ua;a.solve=va;a.termAs=pa;a.terminate=ma;a.toArgBranch=wa;a.toParseBranch=ba;a.toSimpleBranch=oa;a.unknownOption=qa;})(PS["Neodoc.ArgParser.Parser"]=PS["Neodoc.ArgParser.Parser"]||{});
(function(a){var b=PS["Data.Either"],c=PS["Data.Bifunctor"],e=PS["Data.List"],d=PS["Neodoc.Parsing.Parser"],g=PS["Neodoc.ArgParser.Type"],k=PS["Neodoc.ArgParser.Parser"],l=PS["Neodoc.ArgParser.Lexer"],h=PS["Control.Bind"],f=PS["Data.Foldable"];a.run=function(a){return function(m){return function(n){return function(p){var r=c.lmap(b.bifunctorEither)(d.extractError(g.genericError)),B=c.lmap(b.bifunctorEither)(g.malformedInputError);return h.bind(b.bindEither)(B(l.lex(e.fromFoldable(f.foldableArray)(p))(m)))(function(b){return r(k.parse(a)(m)(n)(b))})}}}};})(PS["Neodoc.ArgParser"]=
PS["Neodoc.ArgParser"]||{});
(function(a){var b=PS["Data.Maybe"],c=PS["Data.List"],e=PS["Data.NonEmpty.Extra"],d=PS["Data.String"],g=PS["Data.Set"],k=PS["Neodoc.ArgKey"],l=PS["Neodoc.ArgKey.Class"],h=PS["Neodoc.OptionAlias"],f=PS["Neodoc.Data.Description"],m=PS["Neodoc.Data.SolvedLayout"],n=PS["Data.Eq"],r=PS["Data.Ord"],p=PS["Data.Functor"],t=PS["Data.List.Types"],B=PS["Control.Bind"],q=new n.Eq(function(a){return function(b){return n.eq(g.eqSet(k.eqArgKey))(a)(b)}}),w=new r.Ord(function(){return q},function(a){return function(b){return r.compare(g.ordSet(k.ordArgKey))(a)(b)}});
a.Key=function(a){return a};a.toKey=function(a){return g.fromFoldable(t.foldableList)(k.ordArgKey)(function(d){return d instanceof m.Option?p.map(t.functorList)(k.OptionKey.create)(b.fromMaybe(c.singleton(d.value0))(B.bind(b.bindMaybe)(a.value1)(function(a){return a instanceof f.OptionDescription?b.Just.create(new t.Cons(d.value0,e.toList(a.value0))):b.Nothing.value}))):c.singleton(l.toArgKey(m.toArgKeySolvedLayoutArg)(a.value0))}(a.value0))};a.toStrKeys=function(a){return p.map(t.functorList)(function(a){if(a instanceof
k.PositionalKey||a instanceof k.CommandKey)return a.value0;if(a instanceof k.OptionKey&&a.value0 instanceof h.Long)return "--"+a.value0.value0;if(a instanceof k.OptionKey&&a.value0 instanceof h.Short)return "-"+d.singleton(a.value0.value0);if(a instanceof k.EOAKey)return "--";if(a instanceof k.StdinKey)return "-";throw Error("Failed pattern match at Neodoc.Evaluate.Key line 60, column 5 - line 60, column 46: "+[a.constructor.name]);})(c.fromFoldable(g.foldableSet)(a))};a.eqKey=q;a.ordKey=w;})(PS["Neodoc.Evaluate.Key"]=
PS["Neodoc.Evaluate.Key"]||{});
(function(a){var b=PS["Data.Tuple"],c=PS["Data.NonEmpty"],e=PS["Data.Bifunctor"],d=PS["Data.Map"],g=PS["Data.StrMap"],k=PS["Data.Maybe"],l=PS["Data.List"],h=PS["Data.Array"],f=PS["Data.Foldable"],m=PS["Control.Alt"],n=PS["Neodoc.Data.Layout"],r=PS["Neodoc.Data.Description"],p=PS["Neodoc.Data.SolvedLayout"],t=PS["Neodoc.Data.OptionArgument"],B=PS["Neodoc.Value.RichValue"],q=PS["Neodoc.ArgParser.Arg"],w=PS["Neodoc.Value"],x=PS["Neodoc.Value.Origin"],y=PS["Neodoc.Evaluate.Annotate"],C=PS["Neodoc.Evaluate.Key"],
u=PS["Data.Functor"],A=PS["Data.HeytingAlgebra"],z=PS["Control.Bind"],E=PS["Data.Function"],F=PS["Control.Applicative"],G=PS["Data.List.Types"],I=PS["Data.Semigroup"],v=PS["Data.Eq"],H=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),L=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),J=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),K=function(){function a(){}
a.value=new a;return a}(),S=function(){function a(){}a.value=new a;return a}(),R=function(){return function(a){if(a instanceof p.Option)return new J(u.map(k.functorMaybe)(t.isOptionArgumentOptional)(a.value1),a.value2);if(a instanceof p.Positional)return new L(a.value1);if(a instanceof p.Command)return new H(a.value1);if(a instanceof p.EOA)return K.value;if(a instanceof p.Stdin)return S.value;throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 158, column 3 - line 158, column 74: "+[a.constructor.name]);
}}(),P=function(a){return function(b){return b instanceof H?new H(a):b instanceof L?new L(a):b instanceof J?new J(b.value0,a):b}},N=function(a){return a instanceof H||a instanceof L?a.value0:a instanceof J?a.value1:!1},O=function(a){return function(b){return P(N(b)||a)(b)}},D=function(a){return a instanceof J&&a.value0 instanceof k.Nothing?!0:!1},M=function(a){if(a instanceof n.Elem)return d.singleton(C.toKey(a.value0))(e.lmap(b.bifunctorTuple)(R)(a.value0));if(a instanceof n.Group){var g=function(a){return function(c){return function(d){if(c.value0 instanceof
J&&d.value0 instanceof J){var e=z.bind(k.bindMaybe)(m.alt(k.altMaybe)(c.value1)(d.value1))(function(a){return z.bind(k.bindMaybe)(m.alt(k.altMaybe)(d.value1)(c.value1))(function(c){c=new b.Tuple(a,c);return c.value0 instanceof r.OptionDescription&&c.value1 instanceof r.OptionDescription?F.pure(k.applicativeMaybe)(new r.OptionDescription(c.value0.value0,c.value0.value1,m.alt(k.altMaybe)(c.value0.value2)(c.value1.value2),m.alt(k.altMaybe)(c.value0.value3)(c.value1.value3),m.alt(k.altMaybe)(c.value0.value4)(c.value1.value4))):
c.value0 instanceof r.OptionDescription?F.pure(k.applicativeMaybe)(new r.OptionDescription(c.value0.value0,c.value0.value1,c.value0.value2,c.value0.value3,c.value0.value4)):c.value1 instanceof r.OptionDescription?F.pure(k.applicativeMaybe)(new r.OptionDescription(c.value1.value0,c.value1.value1,c.value1.value2,c.value1.value3,c.value1.value4)):k.Nothing.value})}),f=z.bind(k.bindMaybe)(m.alt(k.altMaybe)(c.value0.value0)(d.value0.value0))(function(a){return z.bind(k.bindMaybe)(m.alt(k.altMaybe)(d.value0.value0)(c.value0.value0))(function(b){return F.pure(k.applicativeMaybe)(a||
b)})});return new b.Tuple(new J(f,a||c.value0.value1||d.value0.value1),e)}return new b.Tuple(O(a||N(d.value0))(c.value0),c.value1)}}},h=g(!0),l=function(a){return f.foldl(c.foldableNonEmpty(G.foldableList))(d.unionWith(C.ordKey)(a))(d.empty)},g=g(!1),p=u.map(c.functorNonEmpty(G.functorList))(function(a){var b=l(h);a=u.map(c.functorNonEmpty(G.functorList))(M)(a);return b(a)})(a.value2),p=u.map(c.functorNonEmpty(G.functorList))(function(c){return u.map(d.functorMap)(e.lmap(b.bifunctorTuple)(O(a.value1)))(c)})(p);
return l(g)(p)}throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 169, column 1 - line 169, column 77: "+[a.constructor.name]);};a.reduce=function(a){return function(m){return function(r){return function(t){if(r instanceof k.Nothing)return g.empty;if(r instanceof k.Just){var J=function(a){return function(c){return new b.Tuple(a.value0,new b.Tuple(a.value1.value0,B.RichValue({origin:k.fromJust()(f.maximum(x.ordOrigin)(f.foldableArray)([a.value1.value1.origin,c.value1.value1.origin])),
value:w.ArrayValue.create(I.append(I.semigroupArray)(w.intoArray(c.value1.value1.value))(w.intoArray(a.value1.value1.value)))})))}},K=function(a){a=u.mapFlipped(G.functorList)(d.toList(a))(function(a){var c=k.fromMaybe(a.value1.value1.value1.value)(function(){var b;(b=D(a.value1.value0))||(b=a.value1.value0 instanceof H?!0:!1);if(b){if(a.value1.value1.value1.value instanceof w.ArrayValue)return F.pure(k.applicativeMaybe)(function(){var b=f.all(f.foldableArray)(A.heytingAlgebraBoolean)(w.isBoolValue)(a.value1.value1.value1.value.value0)&&
!h["null"](a.value1.value1.value1.value.value0);if(b)return new w.IntValue(h.length(E.flip(h.filter)(a.value1.value1.value1.value.value0)(function(a){return a instanceof w.BoolValue?a.value0:!1})));if(!b)return new w.ArrayValue(a.value1.value1.value1.value.value0);throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 130, column 27 - line 137, column 47: "+[b.constructor.name]);}());if(a.value1.value1.value1.value instanceof w.BoolValue){if(b=N(a.value1.value0)){b=F.pure(k.applicativeMaybe);
var c;if(a.value1.value1.value1.value.value0)c=new w.IntValue(1);else {if(a.value1.value1.value1.value.value0)throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 141, column 38 - line 144, column 31: "+[a.value1.value1.value1.value.value0.constructor.name]);c=new w.IntValue(0);}return b(c)}if(!b)return k.Nothing.value;throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 139, column 27 - line 144, column 43: "+[b.constructor.name]);}return k.Nothing.value}if(!b)return k.Nothing.value;
throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 127, column 21 - line 146, column 35: "+[b.constructor.name]);}());return u.mapFlipped(G.functorList)(C.toStrKeys(a.value0))(function(d){return new b.Tuple(d,B.RichValue(function(){var b={},d;for(d in a.value1.value1.value1)({}).hasOwnProperty.call(a.value1.value1.value1,d)&&(b[d]=a.value1.value1.value1[d]);b.value=c;return b}()))})});return g.fromFoldable(G.foldableList)(l.concat(a))},L=function(a){return function(c){var e=function(a){return function(b){return function(c){return a(B.unRichValue(c).origin)(b)}}},
f=u.mapFlipped(G.functorList)(d.toList(a))(function(a){return z.bind(k.bindMaybe)(d.lookup(C.ordKey)(a.value0)(c))(function(c){c=l.filter(e(v.notEq(x.eqOrigin))(x.Empty.value))(c);var d=l.filter(e(v.notEq(x.eqOrigin))(x.Default.value))(c);c=d instanceof G.Nil?l.nub(B.eqRichValue)(c):d;c=u.mapFlipped(G.functorList)(c)(function(b){return B.RichValue(function(){var c={},d;for(d in b)({}).hasOwnProperty.call(b,d)&&(c[d]=b[d]);if(d=N(a.value1.value0))d=w.ArrayValue.create(w.intoArray(b.value));else {if(d)throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 112, column 31 - line 114, column 45: "+
[d.constructor.name]);d=b.value;}c.value=d;return c}())});return F.pure(k.applicativeMaybe)(u.mapFlipped(G.functorList)(c)(function(c){return new b.Tuple(a.value0,new b.Tuple(a.value1.value0,new b.Tuple(a.value1.value1,c)))}))})});return d.fromFoldableWith(C.ordKey)(G.foldableList)(J)(l.concat(l.catMaybes(f)))}};return u.map(g.functorStrMap)(function(a){return B.unRichValue(a).value})(function(){var a=d.fromFoldableWith(C.ordKey)(G.foldableList)(I.append(G.semigroupList))(u.map(G.functorList)(u.map(u.functorFn)(e.rmap(b.bifunctorTuple)(l.singleton))(e.lmap(b.bifunctorTuple)(function(a){return C.Key(y.findArgKeys(m)(a))})))(l.reverse(u.map(G.functorList)(e.lmap(b.bifunctorTuple)(q.getArgKey))(t)))),
f=u.map(c.functorNonEmpty(G.functorList))(y.annotateLayout(p.toArgKeySolvedLayoutArg)(m))(r.value0),f=M(new n.Group(!1,!1,new c.NonEmpty(f,G.Nil.value))),a=L(f)(a);return K(a)}())}throw Error("Failed pattern match at Neodoc.Evaluate.Reduce line 64, column 1 - line 64, column 36: "+[a.constructor.name,m.constructor.name,r.constructor.name,t.constructor.name]);}}}};})(PS["Neodoc.Evaluate.Reduce"]=PS["Neodoc.Evaluate.Reduce"]||{});
(function(a){var b=PS.Neodoc,c=PS["Data.Array"],e=PS["Data.Bifunctor"],d=PS["Data.Tuple"],g=PS["Data.Function.Uncurried"],k=PS["Data.Maybe"],l=PS["Data.Either"],h=PS["Data.StrMap"],f=PS["Data.String"],m=PS["Data.Char"],n=PS["Data.List"],r=PS["Data.List.NonEmpty"],p=PS["Data.Traversable"],t=PS["Data.Pretty"],B=PS["Data.String.Regex"],q=PS["Data.Foreign"],w=PS["Data.Foreign.Class"],x=PS["Data.Foreign.Extra"],y=PS["Data.Foldable"],C=PS["Data.String.Yarn"],u=PS["Control.Alt"],A=PS["Control.Monad.Eff.Exception"],
z=PS["Control.Monad.Eff.Console"],E=PS["Control.Monad.Eff"],F=PS["Control.Monad.Eff.Unsafe"],G=PS["Control.Monad.Except"],I=PS["Node.Process"],v=PS["Text.Wrap"],H=PS["Unsafe.Coerce"],L=PS["Neodoc.Spec"],J=PS["Neodoc.Options"],K=PS["Neodoc.Data.Layout"],S=PS["Neodoc.Data.UsageLayout"],R=PS["Neodoc.Data.EmptyableLayout"],P=PS["Neodoc.Error.Class"],N=PS["Neodoc.Error"],O=PS["Neodoc.Scanner"],D=PS["Neodoc.SpecConversions"],M=PS["Neodoc.Spec.Parser"],U=PS["Neodoc.Spec.Lexer"],X=PS["Neodoc.Solve"],T=PS["Neodoc.Value"],
ca=PS["Neodoc.ArgParser"],da=PS["Neodoc.Data.SolvedLayout"],Q=PS["Neodoc.OptionAlias"],Y=PS["Data.Show"],W=PS["Data.Functor"],Z=PS["Data.HeytingAlgebra"],ea=PS["Data.Monoid"],V=PS["Control.Bind"],aa=PS["Control.Monad.Except.Trans"],ja=PS["Data.Identity"],oa=PS["Data.List.Types"],ba=PS["Control.Applicative"],wa=PS["Neodoc.Scanner.Error"],ma=PS["Neodoc.Spec.Error"],pa=PS["Neodoc.Solve.Error"],sa=PS["Neodoc.ArgParser.Type"],ta=PS["Neodoc.Evaluate.Reduce"],la=PS["Control.Apply"],ia=PS["Control.Category"],
ga=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),ha=function(){function a(a){this.value0=a;}a.create=function(b){return new a(b)};return a}(),fa=function(){function a(a,b){this.value0=a;this.value1=b;}a.create=function(b){return function(c){return new a(b,c)}};return a}(),na=function(){return B.replace(function(a){return function(b){return l.fromRight()(B.regex(a)(B.parseFlags(b)))}}("(^\\s*(\r\n|\n|\r))|((\r\n|\n|\r)\\s*$)")("g"))("")}(),
qa=new Y.Show(function(a){if(a instanceof ga)return "VersionOutput "+(Y.show(h.showStrMap(T.showValue))(a.value0)+(" "+Y.show(Y.showString)(a.value1)));if(a instanceof fa)return "HelpOutput "+(Y.show(h.showStrMap(T.showValue))(a.value0)+(" "+Y.show(Y.showString)(a.value1)));if(a instanceof ha)return "Output "+Y.show(h.showStrMap(T.showValue))(a.value0);throw Error("Failed pattern match at Neodoc line 126, column 3 - line 126, column 73: "+[a.constructor.name]);}),va=function(a){return function(b){return function(d){return function(e){if(a instanceof
k.Just&&e instanceof N.ArgParserError){var g=function(a){return a instanceof k.Just?v.dedent(C.unlines(W.map(W.functorArray)(function(a){return "  "+a})(C.lines(v.dedent(a.value0))))):""}(d),h=function(){var b=f.uncons(e.value0);if(b instanceof k.Nothing)return e.value0;if(b instanceof k.Just)return b=f.singleton(m.toLower(b.value0.head))+b.value0.tail,a.value0+(": "+b);throw Error("Failed pattern match at Neodoc line 393, column 7 - line 397, column 35: "+[b.constructor.name]);}(),l=function(a){return function(b){return b instanceof
k.Just&&!c["null"](b.value0)?"See "+(a+(" "+(y.intercalate(y.foldableArray)(ea.monoidString)("/")(b.value0)+" for more information"))):""}}(a.value0)(b);return h+(function(){var a=0<f.length(h);if(a)return "\n";if(!a)return "";throw Error("Failed pattern match at Neodoc line 401, column 13 - line 401, column 57: "+[a.constructor.name]);}()+(g+(function(){var a=0<f.length(g);if(a)return "\n";if(!a)return "";throw Error("Failed pattern match at Neodoc line 403, column 13 - line 403, column 57: "+[a.constructor.name]);
}()+l)))}return t.pretty(N.prettyNeodocError)(e)}}}},ua=function(a){return V.bind(aa.bindExceptT(ja.monadIdentity))(u.alt(aa.altExceptT(oa.semigroupNonEmptyList)(ja.monadIdentity))(W.map(aa.functorExceptT(ja.functorIdentity))(l.Right.create)(w.read(w.stringIsForeign)(a)))(W.map(aa.functorExceptT(ja.functorIdentity))(l.Left.create)(w.read(L.isForeignOptionAlias(R.isForeignEmptyableLayout(S.isForeignUsageLayoutArg)))(a))))(function(a){return ba.pure(aa.applicativeExceptT(ja.monadIdentity))(e.lmap(l.bifunctorEither)(D.fromEmptyableSpec)(a))})},
ra=new t.Pretty(function(a){if(a instanceof ga||a instanceof fa)return a.value1;if(a instanceof ha)return t.pretty(t.prettyStrMap(T.prettyValue))(a.value0);throw Error("Failed pattern match at Neodoc line 121, column 3 - line 121, column 33: "+[a.constructor.name]);}),ka=function(a){return V.bind(l.bindEither)(P.capture(wa.toNeodocErrorScanError)(O.scan(v.dedent(a))))(function(b){return V.bind(l.bindEither)(V.bind(l.bindEither)(P.capture(ma.toNeodocErrorSpecParseError)(U.lexUsage(b.usage)))(function(a){return P.capture(ma.toNeodocErrorSpecParseError)(M.parseUsage(a))}))(function(c){return V.bind(l.bindEither)(W.map(l.functorEither)(n.concat)(p["for"](l.applicativeEither)(oa.traversableList)(b.options)(function(a){return V.bind(l.bindEither)(P.capture(ma.toNeodocErrorSpecParseError)(U.lexDescs(a)))(function(a){return P.capture(ma.toNeodocErrorSpecParseError)(M.parseDescription(a))})})))(function(d){return ba.pure(l.applicativeEither)({program:c.program,
layouts:c.layouts,descriptions:d,helpText:a,shortHelp:b.originalUsage})})})})},Ba=function(){return g.mkFn1(function(a){a=ka(a);if(a instanceof l.Left)return a=va(k.Nothing.value)(k.Nothing.value)(k.Nothing.value)(a.value0),A.throwException(b.jsError(a)({}));if(a instanceof l.Right)return ba.pure(E.applicativeEff)(w.write(L.asForeignOptionAlias(R.asForeignEmptyableLayout(S.asForeignUsageLayoutArg)))(D.toEmptyableSpec(a.value0)));throw Error("Failed pattern match at Neodoc line 351, column 5 - line 356, column 51: "+
[a.constructor.name]);})}(),xa=function(a){return function(b){return y.any(a)(Z.heytingAlgebraBoolean)(function(a){return k.maybe(!1)(function(a){return a instanceof T.IntValue&&0===a.value0||a instanceof T.BoolValue&&!a.value0||a instanceof T.ArrayValue&&0===a.value0.length?!1:!0})(h.lookup(a)(b))})}},za=function(a){if(a instanceof ga||a instanceof ha||a instanceof fa)return a.value0;throw Error("Failed pattern match at Neodoc line 106, column 1 - line 106, column 32: "+[a.constructor.name]);},Aa=
function(a){return function(b){return function(c){var d=k.fromMaybe(h.empty)(b.env),e=k.fromMaybe([])(b.argv);return V.bind(l.bindEither)(l.either(ba.pure(l.applicativeEither))(ka)(a))(function(a){return V.bind(l.bindEither)(P.capture(pa.toNeodocErrorSolveError)(X.solve({smartOptions:b.smartOptions})(a)))(function(f){return V.bind(l.bindEither)(P.capture(sa.toNeodocErrorArgParseError)(ca.run(f)({optionsFirst:b.optionsFirst,stopAt:b.stopAt,requireFlags:b.requireFlags,laxPlacement:b.laxPlacement,repeatableOptions:b.repeatableOptions,
allowUnknown:b.allowUnknown,helpFlags:n.fromFoldable(y.foldableArray)(b.helpFlags),versionFlags:n.fromFoldable(y.foldableArray)(b.versionFlags)})(d)(e)))(function(e){e=ta.reduce(d)(f.descriptions)(e.value0)(e.value1);var g=xa(y.foldableArray)(e)(W.map(W.functorArray)(t.pretty(Q.prettyOptionAlias))(b.helpFlags));if(g)return ba.pure(l.applicativeEither)(new fa(e,na(a.helpText)));if(!g){if(g=xa(y.foldableArray)(e)(W.map(W.functorArray)(t.pretty(Q.prettyOptionAlias))(b.versionFlags))){if(c instanceof
k.Just)return ba.pure(l.applicativeEither)(new ga(e,c.value0));if(c instanceof k.Nothing)return new l.Left(N.VersionMissingError.value);throw Error("Failed pattern match at Neodoc line 338, column 9 - line 340, column 53: "+[c.constructor.name]);}if(!g)return ba.pure(l.applicativeEither)(new ha(e));throw Error("Failed pattern match at Neodoc line 337, column 7 - line 341, column 32: "+[g.constructor.name]);}throw Error("Failed pattern match at Neodoc line 334, column 3 - line 341, column 32: "+[g.constructor.name]);
})})})}}},Ca=v.dedent("\n  This is an error with the program itself and not your fault.\n  Please bring this to the program author's attention.\n"),ya=function(a){return function(d){var e=function(a){return function(c){return function(e){return function(f){if(f instanceof l.Left){var g=va(a)(c)(e)(f.value0);if(d.dontExit)return A.throwException(b.jsError(g)({}));if(!d.dontExit){if(f=N.isDeveloperError(f.value0))g+="\n"+Ca;else if(f)throw Error("Failed pattern match at Neodoc line 276, column 26 - line 278, column 37: "+
[f.constructor.name]);return la.applySecond(E.applyEff)(z.error(g))(I.exit(1))}throw Error("Failed pattern match at Neodoc line 273, column 11 - line 280, column 5: "+[d.dontExit.constructor.name]);}if(f instanceof l.Right)return ba.pure(E.applicativeEff)(f.value0);throw Error("Failed pattern match at Neodoc line 270, column 50 - line 280, column 22: "+[f.constructor.name]);}}}},f=b.readPkgVersionImpl(k.Just.create)(k.Nothing.value);return function(){var b=k.maybe(W.map(E.functorEff)(c.drop(2))(I.argv))(ba.pure(E.applicativeEff))(d.argv)(),
g=k.maybe(I.getEnv)(ba.pure(E.applicativeEff))(d.env)(),h=e(k.Nothing.value)(k.Nothing.value)(k.Nothing.value),m=h(l.either(ba.pure(l.applicativeEither))(ka)(a))(),p=h(function(){var a=function(a){return function(a){return function(b){b=F.unsafePerformEff(a(b));return new l.Right(b)}}};return P.capture(pa.toNeodocErrorSolveError)(X["solve'"]({smartOptions:d.smartOptions,helpFlags:n.fromFoldable(y.foldableArray)(d.helpFlags),versionFlags:n.fromFoldable(y.foldableArray)(d.versionFlags)})(n.fromFoldable(y.foldableArray)(l.either(function(b){return W.map(W.functorArray)(a(K.prettyLayout(S.prettyUsageLayoutArg)))(b)})(ia.id(ia.categoryFn))(d.transforms.presolve)))(n.fromFoldable(y.foldableArray)(l.either(function(b){return W.map(W.functorArray)(a(K.prettyLayout(da.prettySolvedLayoutArg)))(b)})(ia.id(ia.categoryFn))(d.transforms.postsolve)))(m))}())(),
h=e(new k.Just(m.program))(new k.Just(W.map(W.functorArray)(t.pretty(Q.prettyOptionAlias))(d.helpFlags)))(new k.Just(m.shortHelp)),b=h(V.bind(l.bindEither)(P.capture(sa.toNeodocErrorArgParseError)(ca.run(p)({optionsFirst:d.optionsFirst,stopAt:d.stopAt,requireFlags:d.requireFlags,laxPlacement:d.laxPlacement,repeatableOptions:d.repeatableOptions,allowUnknown:d.allowUnknown,helpFlags:n.fromFoldable(y.foldableArray)(d.helpFlags),versionFlags:n.fromFoldable(y.foldableArray)(d.versionFlags)})(g)(b)))(function(a){return ba.pure(l.applicativeEither)(ta.reduce(g)(p.descriptions)(a.value0)(a.value1))}))(),
q=xa(y.foldableArray)(b)(W.map(W.functorArray)(t.pretty(Q.prettyOptionAlias))(d.helpFlags));if(q){h=na(m.helpText);if(d.dontExit)return new fa(b,h);if(!d.dontExit)return la.applySecond(E.applyEff)(z.log(h))(I.exit(0))();throw Error("Failed pattern match at Neodoc line 247, column 9 - line 250, column 5: "+[d.dontExit.constructor.name]);}if(!q){if(q=xa(y.foldableArray)(b)(W.map(W.functorArray)(t.pretty(Q.prettyOptionAlias))(d.versionFlags))){q=k.maybe(f)(function(a){return ba.pure(E.applicativeEff)(ba.pure(k.applicativeMaybe)(a))})(d.version)();
if(q instanceof k.Just){if(d.dontExit)return new ga(b,q.value0);if(!d.dontExit)return la.applySecond(E.applyEff)(z.log(q.value0))(I.exit(0))();throw Error("Failed pattern match at Neodoc line 255, column 13 - line 258, column 11: "+[d.dontExit.constructor.name]);}if(q instanceof k.Nothing)return h(new l.Left(N.VersionMissingError.value))();throw Error("Failed pattern match at Neodoc line 253, column 9 - line 258, column 70: "+[q.constructor.name]);}if(!q)return new ha(b);throw Error("Failed pattern match at Neodoc line 251, column 7 - line 259, column 30: "+
[q.constructor.name]);}throw Error("Failed pattern match at Neodoc line 245, column 3 - line 259, column 30: "+[q.constructor.name]);}}},Da=function(){var a=function(b){if(b instanceof T.BoolValue||b instanceof T.IntValue||b instanceof T.FloatValue||b instanceof T.StringValue)return H.unsafeCoerce(b.value0);if(b instanceof T.ArrayValue)return H.unsafeCoerce(W.map(W.functorArray)(a)(b.value0));throw Error("Failed pattern match at Neodoc line 156, column 3 - line 156, column 44: "+[b.constructor.name]);
};return g.mkFn2(function(b){return function(c){return function(){var e=l.either(function(a){return A.throwException(A.error(x.prettyForeignError(r.head(a))))})(ba.pure(E.applicativeEff))(G.runExcept(la.apply(aa.applyExceptT(ja.monadIdentity))(W.map(aa.functorExceptT(ja.functorIdentity))(d.Tuple.create)(ua(b)))(w.read(J.isForeign)(c))))(),e=ya(e.value0)(e.value1)();if(e instanceof ha)return q.toForeign(W.map(h.functorStrMap)(a)(e.value0));if(e instanceof fa)return e=h.insert(".help")(new T.StringValue(e.value1))(e.value0),
q.toForeign(W.map(h.functorStrMap)(a)(e));if(e instanceof ga)return e=h.insert(".version")(new T.StringValue(e.value1))(e.value0),q.toForeign(W.map(h.functorStrMap)(a)(e));throw Error("Failed pattern match at Neodoc line 145, column 10 - line 152, column 42: "+[e.constructor.name]);}}})}();a.VersionOutput=ga;a.Output=ha;a.HelpOutput=fa;a.lookup=function(a){return function(b){return h.lookup(a)(za(b))}};a["lookup'"]=function(a){return function(b){b=h.lookup(a)(za(b));return b instanceof k.Just?new l.Right(b.value0):
Q.fromString(a)instanceof l.Right?new l.Right(new T.BoolValue(!1)):l.Left.create("no such key: "+Y.show(Y.showString)(a))}};a.parseHelpText=ka;a.parseHelpTextJS=Ba;a.readSpec=ua;a.run=function(a){return ya(new l.Right(a))};a["run'"]=function(a){return ya(new l.Left(a))};a.runJS=Da;a.runPure=function(a){return Aa(new l.Right(a))};a["runPure'"]=function(a){return Aa(new l.Left(a))};a.prettyOutput=ra;a.showOutput=qa;})(PS.Neodoc=PS.Neodoc||{});var neodoc_purs_min=PS;

var neodoc = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.run = run;
exports.parse = parse;



var PS = _interopRequireWildcard(neodoc_purs_min);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var docopt = PS['Neodoc'];

function run(spec, opts) {
  return docopt.runJS(spec, opts)();
}

function parse() {
  return docopt.parseHelpTextJS.apply(docopt, arguments)();
}

exports.default = { run: run, parse: parse };
});

var neodoc$1 = neodoc;

var _process$env$DOMAIN;
var DEFAULT_SEVERITY_DISTRIBUTION = 'China CDC';
var DOMAIN = (_process$env$DOMAIN = process.env.DOMAIN) !== null && _process$env$DOMAIN !== void 0 ? _process$env$DOMAIN : '';

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime;

// `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}

var $every = arrayIteration.every;



var STRICT_METHOD$3 = arrayMethodIsStrict('every');
var USES_TO_LENGTH$4 = arrayMethodUsesToLength('every');

// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 || !USES_TO_LENGTH$4 }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

var _stackClear = stackClear;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/** Built-in value references. */
var Symbol$2 = _root.Symbol;

var _Symbol = Symbol$2;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$2.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag$1 && symToStringTag$1 in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$1;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$3).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

/* Built-in method references that are verified to be native. */
var Map$1 = _getNative(_root, 'Map');

var _Map = Map$1;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$4.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

var _Stack = Stack;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

var _setCacheAdd = setCacheAdd;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

var _SetCache = SetCache;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var _arraySome = arraySome;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_arraySome(other, function(othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays;

/** Built-in value references. */
var Uint8Array$1 = _root.Uint8Array;

var _Uint8Array = Uint8Array$1;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq_1(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = _mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$1;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

var _equalByTag = equalByTag;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

var isArray_1 = isArray$1;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var stubArray_1 = stubArray;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

var _getSymbols = getSymbols;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$6.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

var isBuffer_1 = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse_1;

module.exports = isBuffer;
});

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

var isLength_1 = isLength;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$1] = typedArrayTags[numberTag$1] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag$1] =
typedArrayTags[setTag$1] = typedArrayTags[stringTag$1] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike_1(value) &&
    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

var _baseIsTypedArray = baseIsTypedArray;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary;

var _nodeUtil = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;
});

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

var isTypedArray_1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value),
      isArg = !isArr && isArguments_1(value),
      isBuff = !isArr && !isArg && isBuffer_1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

  return value === proto;
}

var _isPrototype = isPrototype;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

var _nativeKeys = nativeKeys;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys$1(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

var keys_1 = keys$1;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}

var _getAllKeys = getAllKeys;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$9.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects;

/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

var _DataView = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = _getNative(_root, 'Promise');

var _Promise = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = _getNative(_root, 'Set');

var _Set = Set$1;

/* Built-in method references that are verified to be native. */
var WeakMap$2 = _getNative(_root, 'WeakMap');

var _WeakMap = WeakMap$2;

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$2 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
    (_Map && getTag(new _Map) != mapTag$2) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != setTag$2) ||
    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$2;
        case mapCtorString: return mapTag$2;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$2;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var _getTag = getTag;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$2 = '[object Object]';

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_1(object),
      othIsArr = isArray_1(other),
      objTag = objIsArr ? arrayTag$1 : _getTag(object),
      othTag = othIsArr ? arrayTag$1 : _getTag(other);

  objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$2 : othTag;

  var objIsObj = objTag == objectTag$2,
      othIsObj = othTag == objectTag$2,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer_1(object)) {
    if (!isBuffer_1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack);
    return (objIsArr || isTypedArray_1(object))
      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$a.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$a.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack);
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

var _baseIsEqual = baseIsEqual;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

var _baseIsMatch = baseIsMatch;

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject_1(value);
}

var _isStrictComparable = isStrictComparable;

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys_1(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, _isStrictComparable(value)];
  }
  return result;
}

var _getMatchData = getMatchData;

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

var _matchesStrictComparable = matchesStrictComparable;

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = _getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || _baseIsMatch(object, source, matchData);
  };
}

var _baseMatches = baseMatches;

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);
}

var isSymbol_1 = isSymbol$1;

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray_1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol_1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

var _isKey = isKey;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache;

var memoize_1 = memoize;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize_1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

var _memoizeCapped = memoizeCapped;

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var _stringToPath = stringToPath;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

var _arrayMap = arrayMap;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray_1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }
  if (isSymbol_1(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

var _baseToString = baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$2(value) {
  return value == null ? '' : _baseToString(value);
}

var toString_1 = toString$2;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray_1(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
}

var _castPath = castPath;

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol_1(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

var _toKey = toKey;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = _castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

var _baseGet = baseGet;

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$1(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

var get_1 = get$1;

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

var _baseHasIn = baseHasIn;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = _toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_1(length) && _isIndex(key, length) &&
    (isArray_1(object) || isArguments_1(object));
}

var _hasPath = hasPath;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}

var hasIn_1 = hasIn;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get_1(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn_1(object, path)
      : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

var _baseMatchesProperty = baseMatchesProperty;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var identity_1 = identity;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

var _baseProperty = baseProperty;

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return _baseGet(object, path);
  };
}

var _basePropertyDeep = basePropertyDeep;

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}

var property_1 = property;

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity_1;
  }
  if (typeof value == 'object') {
    return isArray_1(value)
      ? _baseMatchesProperty(value[0], value[1])
      : _baseMatches(value);
  }
  return property_1(value);
}

var _baseIteratee = baseIteratee;

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

var _baseSum = baseSum;

/**
 * This method is like `_.sum` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the value to be summed.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the sum.
 * @example
 *
 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
 *
 * _.sumBy(objects, function(o) { return o.n; });
 * // => 20
 *
 * // The `_.property` iteratee shorthand.
 * _.sumBy(objects, 'n');
 * // => 20
 */
function sumBy(array, iteratee) {
  return (array && array.length)
    ? _baseSum(array, _baseIteratee(iteratee))
    : 0;
}

var sumBy_1 = sumBy;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

var _arrayEach = arrayEach;

var defineProperty$4 = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty$1 = defineProperty$4;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty$1) {
    _defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$c.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$b.call(object, key) && eq_1(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignValue = assignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

var _copyObject = copyObject;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && _copyObject(source, keys_1(source), object);
}

var _baseAssign = baseAssign;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

var _nativeKeysIn = nativeKeysIn;

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$d.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$c.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

var _baseKeysIn = baseKeysIn;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn$1(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

var keysIn_1 = keysIn$1;

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && _copyObject(source, keysIn_1(source), object);
}

var _baseAssignIn = baseAssignIn;

var _cloneBuffer = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
});

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var _copyArray = copyArray;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}

var _copySymbols = copySymbols;

/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};

var _getSymbolsIn = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}

var _copySymbolsIn = copySymbolsIn;

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
}

var _getAllKeysIn = getAllKeysIn;

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$d = objectProto$e.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$d.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

var _initCloneArray = initCloneArray;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer;

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var _cloneDataView = cloneDataView;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var _cloneRegExp = cloneRegExp;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

var _cloneSymbol = cloneSymbol;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray;

/** `Object#toString` result references. */
var boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    mapTag$3 = '[object Map]',
    numberTag$2 = '[object Number]',
    regexpTag$2 = '[object RegExp]',
    setTag$3 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return _cloneArrayBuffer(object);

    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);

    case dataViewTag$3:
      return _cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return _cloneTypedArray(object, isDeep);

    case mapTag$3:
      return new Ctor;

    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);

    case regexpTag$2:
      return _cloneRegExp(object);

    case setTag$3:
      return new Ctor;

    case symbolTag$2:
      return _cloneSymbol(object);
  }
}

var _initCloneByTag = initCloneByTag;

/** Built-in value references. */
var objectCreate$1 = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var _baseCreate = baseCreate;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

var _initCloneObject = initCloneObject;

/** `Object#toString` result references. */
var mapTag$4 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike_1(value) && _getTag(value) == mapTag$4;
}

var _baseIsMap = baseIsMap;

/* Node.js helper references. */
var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

var isMap_1 = isMap;

/** `Object#toString` result references. */
var setTag$4 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike_1(value) && _getTag(value) == setTag$4;
}

var _baseIsSet = baseIsSet;

/* Node.js helper references. */
var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

var isSet_1 = isSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$3 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$2 = '[object Error]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    mapTag$5 = '[object Map]',
    numberTag$3 = '[object Number]',
    objectTag$3 = '[object Object]',
    regexpTag$3 = '[object RegExp]',
    setTag$5 = '[object Set]',
    stringTag$3 = '[object String]',
    symbolTag$3 = '[object Symbol]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] =
cloneableTags[arrayBufferTag$3] = cloneableTags[dataViewTag$4] =
cloneableTags[boolTag$3] = cloneableTags[dateTag$3] =
cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
cloneableTags[int32Tag$2] = cloneableTags[mapTag$5] =
cloneableTags[numberTag$3] = cloneableTags[objectTag$3] =
cloneableTags[regexpTag$3] = cloneableTags[setTag$5] =
cloneableTags[stringTag$3] = cloneableTags[symbolTag$3] =
cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] =
cloneableTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject_1(value)) {
    return value;
  }
  var isArr = isArray_1(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value),
        isFunc = tag == funcTag$2 || tag == genTag$1;

    if (isBuffer_1(value)) {
      return _cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$3 || tag == argsTag$3 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? _copySymbolsIn(value, _baseAssignIn(result, value))
          : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet_1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_1(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? _getAllKeysIn : _getAllKeys)
    : (isFlat ? keysIn : keys_1);

  var props = isArr ? undefined : keysFunc(value);
  _arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var _baseClone = baseClone;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}

var cloneDeep_1 = cloneDeep;

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
var arrayFill = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
_export({ target: 'Array', proto: true }, {
  fill: arrayFill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');

var $findIndex = arrayIteration.findIndex;



var FIND_INDEX = 'findIndex';
var SKIPS_HOLES$1 = true;

var USES_TO_LENGTH$5 = arrayMethodUsesToLength(FIND_INDEX);

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; });

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$5 }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod$2 = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction$1(callbackfn);
    var O = toObject(that);
    var self = indexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod$2(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod$2(true)
};

var $reduce = arrayReduce.left;



var STRICT_METHOD$4 = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH$6 = arrayMethodUsesToLength('reduce', { 1: 0 });

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$4 || !USES_TO_LENGTH$6 }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var aPossiblePrototype = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

// makes subclassing work correct for wrapped built-ins
var inheritIfRequired = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    objectSetPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) objectSetPrototypeOf($this, NewTargetPrototype);
  return $this;
};

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod$3 = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod$3(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod$3(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod$3(3)
};

var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var defineProperty$5 = objectDefineProperty.f;
var trim = stringTrim.trim;

var NUMBER = 'Number';
var NativeNumber = global_1[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys$2 = descriptors ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys$2.length > j; j++) {
    if (has(NativeNumber, key = keys$2[j]) && !has(NumberWrapper, key)) {
      defineProperty$5(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global_1, NUMBER, NumberWrapper);
}

var propertyIsEnumerable$2 = objectPropertyIsEnumerable.f;

// `Object.{ entries, values }` methods implementation
var createMethod$4 = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!descriptors || propertyIsEnumerable$2.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

var objectToArray = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod$4(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod$4(false)
};

var $entries = objectToArray.entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
_export({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

var _baseClamp = baseClamp;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber$1(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber$1;

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber_1(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber_1(lower);
    lower = lower === lower ? lower : 0;
  }
  return _baseClamp(toNumber_1(number), lower, upper);
}

var clamp_1 = clamp;

// TODO(nnoll): Generalize to allow for sampling multiple uncertainty ranges
function sampleUniform(_ref, npoints) {
  var begin = _ref.begin,
      end = _ref.end;
  var sample = [];
  var delta = (end - begin) / npoints;
  var val = begin;

  while (sample.length < npoints) {
    sample.push(val);
    val += delta;
  }

  return sample;
}
function sampleRandom(_ref2) {
  var begin = _ref2.begin,
      end = _ref2.end;
  return (end - begin) * Math.random() + begin;
}

// Utility functions

function trypush(arr, val) {
  if (arr !== undefined) {
    arr.push(val);
    return arr;
  }

  return [val];
} // -----------------------------------------------------------------------
// Internal functions


function strength(mitigation) {
  return clamp_1(1 - mitigation / 100, 0.01, 1);
}

function sampleMitigationRealizations(intervals, numberStochasticRuns, meanOnly) {
  var noRanges = intervals.every(function (interval) {
    return interval.transmissionReduction.begin === interval.transmissionReduction.end;
  });

  if (noRanges || meanOnly) {
    return [intervals.map(function (interval) {
      return {
        val: strength(0.5 * (interval.transmissionReduction.begin + interval.transmissionReduction.end)),
        tMin: interval.timeRange.begin.valueOf(),
        tMax: interval.timeRange.end.valueOf()
      };
    })];
  }

  return Array(numberStochasticRuns).fill(1).map(function () {
    return intervals.map(function (interval) {
      return {
        val: strength(sampleRandom(interval.transmissionReduction)),
        tMin: interval.timeRange.begin.valueOf(),
        tMax: interval.timeRange.end.valueOf()
      };
    });
  });
}

function timeSeriesOf(measures) {
  var changePoints = {};
  measures.forEach(function (measure) {
    var val = measure.val,
        tMin = measure.tMin,
        tMax = measure.tMax;
    changePoints[tMin] = trypush(changePoints[tMin], val);
    changePoints[tMax] = trypush(changePoints[tMax], 1.0 / val);
  });
  var orderedChangePoints = Object.entries(changePoints).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        t = _ref2[0],
        vals = _ref2[1];

    return {
      t: Number(t),
      val: vals
    };
  }).sort(function (a, b) {
    return a.t - b.t;
  });

  if (orderedChangePoints.length > 0) {
    var mitigation = [{
      t: orderedChangePoints[0].t,
      y: 1.0
    }];
    orderedChangePoints.forEach(function (d, i) {
      var oldValue = mitigation[2 * i].y;
      var newValue = d.val.reduce(function (a, b) {
        return a * b;
      }, oldValue);
      mitigation.push({
        t: d.t,
        y: oldValue
      });
      mitigation.push({
        t: d.t,
        y: newValue
      });
    });
    return mitigation;
  }

  return [];
} // NOTE: Assumes containment is sorted ascending in time.


function interpolateTimeSeries(containment) {
  if (containment.length === 0) {
    return function () {
      return 1.0;
    };
  }

  var Ys = containment.map(function (d) {
    return d.y;
  });
  var Ts = containment.map(function (d) {
    return d.t;
  });
  return function (t) {
    if (t <= containment[0].t) {
      return containment[0].y;
    }

    if (t >= containment[containment.length - 1].t) {
      return containment[containment.length - 1].y;
    }

    var i = containment.findIndex(function (d) {
      return t < d.t;
    });

    var evalLinear = function evalLinear(t) {
      var deltaY = Ys[i] - Ys[i - 1];
      var deltaT = Ts[i] - Ts[i - 1];
      var dS = deltaY / deltaT;
      var dT = t - Ts[i - 1];
      return Ys[i - 1] + dS * dT;
    };

    return evalLinear(t);
  };
} // -----------------------------------------------------------------------
// Exported functions


function containmentMeasures(intervals, numberStochasticRuns, meanOnly) {
  return sampleMitigationRealizations(intervals, numberStochasticRuns, meanOnly).map(function (sample) {
    return interpolateTimeSeries(timeSeriesOf(sample));
  });
}

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER$2 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED$2 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
_export({ target: 'Array', proto: true, forced: FORCED$2 }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER$2) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER$2) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});

var $indexOf = arrayIncludes.indexOf;



var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD$5 = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH$7 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$5 || !USES_TO_LENGTH$7 }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// `Array.isArray` method
// https://tc39.github.io/ecma262/#sec-array.isarray
_export({ target: 'Array', stat: true }, {
  isArray: isArray
});

var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;

var FAILS_ON_PRIMITIVES$2 = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
  getOwnPropertyNames: nativeGetOwnPropertyNames$2
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

//
//   import { Convert, AgeGroup, AgeDistributionDatum, AgeDistributionArray, AgeDistributionData, CaseCountsArray, DateRange, CaseCountsDatum, CaseCountsData, MitigationInterval, NumericRangeNonNegative, PercentageRange, ScenarioArray, ScenarioDatum, ScenarioData, ScenarioDatumEpidemiological, ScenarioDatumMitigation, ScenarioDatumPopulation, ScenarioDatumSimulation, SeverityDistributionDatum, SeverityDistributionArray, SeverityDistributionData, Shareable } from "./file";
//
//   const ageGroup = Convert.toAgeGroup(json);
//   const ageDistributionDatum = Convert.toAgeDistributionDatum(json);
//   const ageDistributionArray = Convert.toAgeDistributionArray(json);
//   const ageDistributionData = Convert.toAgeDistributionData(json);
//   const caseCountsArray = Convert.toCaseCountsArray(json);
//   const dateRange = Convert.toDateRange(json);
//   const integer = Convert.toInteger(json);
//   const caseCountsDatum = Convert.toCaseCountsDatum(json);
//   const colorHex = Convert.toColorHex(json);
//   const caseCountsData = Convert.toCaseCountsData(json);
//   const integerPositive = Convert.toIntegerPositive(json);
//   const mitigationInterval = Convert.toMitigationInterval(json);
//   const integerNonNegative = Convert.toIntegerNonNegative(json);
//   const numericRangeNonNegative = Convert.toNumericRangeNonNegative(json);
//   const percentage = Convert.toPercentage(json);
//   const percentageRange = Convert.toPercentageRange(json);
//   const scenarioArray = Convert.toScenarioArray(json);
//   const scenarioDatum = Convert.toScenarioDatum(json);
//   const scenarioData = Convert.toScenarioData(json);
//   const scenarioDatumEpidemiological = Convert.toScenarioDatumEpidemiological(json);
//   const scenarioDatumMitigation = Convert.toScenarioDatumMitigation(json);
//   const scenarioDatumPopulation = Convert.toScenarioDatumPopulation(json);
//   const scenarioDatumSimulation = Convert.toScenarioDatumSimulation(json);
//   const severityDistributionDatum = Convert.toSeverityDistributionDatum(json);
//   const schemaVer = Convert.toSchemaVer(json);
//   const severityDistributionArray = Convert.toSeverityDistributionArray(json);
//   const severityDistributionData = Convert.toSeverityDistributionData(json);
//   const shareable = Convert.toShareable(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

var AgeGroup;

(function (AgeGroup) {
  AgeGroup["The09"] = "0-9";
  AgeGroup["The1019"] = "10-19";
  AgeGroup["The2029"] = "20-29";
  AgeGroup["The3039"] = "30-39";
  AgeGroup["The4049"] = "40-49";
  AgeGroup["The5059"] = "50-59";
  AgeGroup["The6069"] = "60-69";
  AgeGroup["The7079"] = "70-79";
  AgeGroup["The80"] = "80+";
})(AgeGroup || (AgeGroup = {}));

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
var Convert = /*#__PURE__*/function () {
  function Convert() {
    _classCallCheck(this, Convert);
  }

  _createClass(Convert, null, [{
    key: "toAgeDistributionArray",
    value: function toAgeDistributionArray(json) {
      return cast(JSON.parse(json), r("AgeDistributionArray"));
    }
  }, {
    key: "ageDistributionArrayToJson",
    value: function ageDistributionArrayToJson(value) {
      return JSON.stringify(uncast(value, r("AgeDistributionArray")), null, 2);
    }
  }, {
    key: "toAgeDistributionData",
    value: function toAgeDistributionData(json) {
      return cast(JSON.parse(json), r("AgeDistributionData"));
    }
  }, {
    key: "ageDistributionDataToJson",
    value: function ageDistributionDataToJson(value) {
      return JSON.stringify(uncast(value, r("AgeDistributionData")), null, 2);
    }
  }, {
    key: "toAgeDistributionDatum",
    value: function toAgeDistributionDatum(json) {
      return cast(JSON.parse(json), r("AgeDistributionDatum"));
    }
  }, {
    key: "ageDistributionDatumToJson",
    value: function ageDistributionDatumToJson(value) {
      return JSON.stringify(uncast(value, r("AgeDistributionDatum")), null, 2);
    }
  }, {
    key: "toCaseCountsArray",
    value: function toCaseCountsArray(json) {
      return cast(JSON.parse(json), r("CaseCountsArray"));
    }
  }, {
    key: "caseCountsArrayToJson",
    value: function caseCountsArrayToJson(value) {
      return JSON.stringify(uncast(value, r("CaseCountsArray")), null, 2);
    }
  }, {
    key: "toCaseCountsData",
    value: function toCaseCountsData(json) {
      return cast(JSON.parse(json), r("CaseCountsData"));
    }
  }, {
    key: "caseCountsDataToJson",
    value: function caseCountsDataToJson(value) {
      return JSON.stringify(uncast(value, r("CaseCountsData")), null, 2);
    }
  }, {
    key: "toCaseCountsDatum",
    value: function toCaseCountsDatum(json) {
      return cast(JSON.parse(json), r("CaseCountsDatum"));
    }
  }, {
    key: "caseCountsDatumToJson",
    value: function caseCountsDatumToJson(value) {
      return JSON.stringify(uncast(value, r("CaseCountsDatum")), null, 2);
    }
  }, {
    key: "toScenarioArray",
    value: function toScenarioArray(json) {
      return cast(JSON.parse(json), r("ScenarioArray"));
    }
  }, {
    key: "scenarioArrayToJson",
    value: function scenarioArrayToJson(value) {
      return JSON.stringify(uncast(value, r("ScenarioArray")), null, 2);
    }
  }, {
    key: "toScenarioData",
    value: function toScenarioData(json) {
      return cast(JSON.parse(json), r("ScenarioData"));
    }
  }, {
    key: "scenarioDataToJson",
    value: function scenarioDataToJson(value) {
      return JSON.stringify(uncast(value, r("ScenarioData")), null, 2);
    }
  }, {
    key: "toScenarioDatum",
    value: function toScenarioDatum(json) {
      return cast(JSON.parse(json), r("ScenarioDatum"));
    }
  }, {
    key: "scenarioDatumToJson",
    value: function scenarioDatumToJson(value) {
      return JSON.stringify(uncast(value, r("ScenarioDatum")), null, 2);
    }
  }, {
    key: "toScenarioDatumEpidemiological",
    value: function toScenarioDatumEpidemiological(json) {
      return cast(JSON.parse(json), r("ScenarioDatumEpidemiological"));
    }
  }, {
    key: "scenarioDatumEpidemiologicalToJson",
    value: function scenarioDatumEpidemiologicalToJson(value) {
      return JSON.stringify(uncast(value, r("ScenarioDatumEpidemiological")), null, 2);
    }
  }, {
    key: "toNumericRangeNonNegative",
    value: function toNumericRangeNonNegative(json) {
      return cast(JSON.parse(json), r("NumericRangeNonNegative"));
    }
  }, {
    key: "numericRangeNonNegativeToJson",
    value: function numericRangeNonNegativeToJson(value) {
      return JSON.stringify(uncast(value, r("NumericRangeNonNegative")), null, 2);
    }
  }, {
    key: "toScenarioDatumMitigation",
    value: function toScenarioDatumMitigation(json) {
      return cast(JSON.parse(json), r("ScenarioDatumMitigation"));
    }
  }, {
    key: "scenarioDatumMitigationToJson",
    value: function scenarioDatumMitigationToJson(value) {
      return JSON.stringify(uncast(value, r("ScenarioDatumMitigation")), null, 2);
    }
  }, {
    key: "toMitigationInterval",
    value: function toMitigationInterval(json) {
      return cast(JSON.parse(json), r("MitigationInterval"));
    }
  }, {
    key: "mitigationIntervalToJson",
    value: function mitigationIntervalToJson(value) {
      return JSON.stringify(uncast(value, r("MitigationInterval")), null, 2);
    }
  }, {
    key: "toDateRange",
    value: function toDateRange(json) {
      return cast(JSON.parse(json), r("DateRange"));
    }
  }, {
    key: "dateRangeToJson",
    value: function dateRangeToJson(value) {
      return JSON.stringify(uncast(value, r("DateRange")), null, 2);
    }
  }, {
    key: "toPercentageRange",
    value: function toPercentageRange(json) {
      return cast(JSON.parse(json), r("PercentageRange"));
    }
  }, {
    key: "percentageRangeToJson",
    value: function percentageRangeToJson(value) {
      return JSON.stringify(uncast(value, r("PercentageRange")), null, 2);
    }
  }, {
    key: "toScenarioDatumPopulation",
    value: function toScenarioDatumPopulation(json) {
      return cast(JSON.parse(json), r("ScenarioDatumPopulation"));
    }
  }, {
    key: "scenarioDatumPopulationToJson",
    value: function scenarioDatumPopulationToJson(value) {
      return JSON.stringify(uncast(value, r("ScenarioDatumPopulation")), null, 2);
    }
  }, {
    key: "toScenarioDatumSimulation",
    value: function toScenarioDatumSimulation(json) {
      return cast(JSON.parse(json), r("ScenarioDatumSimulation"));
    }
  }, {
    key: "scenarioDatumSimulationToJson",
    value: function scenarioDatumSimulationToJson(value) {
      return JSON.stringify(uncast(value, r("ScenarioDatumSimulation")), null, 2);
    }
  }, {
    key: "toSeverityDistributionArray",
    value: function toSeverityDistributionArray(json) {
      return cast(JSON.parse(json), r("SeverityDistributionArray"));
    }
  }, {
    key: "severityDistributionArrayToJson",
    value: function severityDistributionArrayToJson(value) {
      return JSON.stringify(uncast(value, r("SeverityDistributionArray")), null, 2);
    }
  }, {
    key: "toSeverityDistributionData",
    value: function toSeverityDistributionData(json) {
      return cast(JSON.parse(json), r("SeverityDistributionData"));
    }
  }, {
    key: "severityDistributionDataToJson",
    value: function severityDistributionDataToJson(value) {
      return JSON.stringify(uncast(value, r("SeverityDistributionData")), null, 2);
    }
  }, {
    key: "toSeverityDistributionDatum",
    value: function toSeverityDistributionDatum(json) {
      return cast(JSON.parse(json), r("SeverityDistributionDatum"));
    }
  }, {
    key: "severityDistributionDatumToJson",
    value: function severityDistributionDatumToJson(value) {
      return JSON.stringify(uncast(value, r("SeverityDistributionDatum")), null, 2);
    }
  }, {
    key: "toShareable",
    value: function toShareable(json) {
      return cast(JSON.parse(json), r("Shareable"));
    }
  }, {
    key: "shareableToJson",
    value: function shareableToJson(value) {
      return JSON.stringify(uncast(value, r("Shareable")), null, 2);
    }
  }]);

  return Convert;
}();

function invalidValue(typ, val) {
  throw Error("Invalid value ".concat(JSON.stringify(val), " for type ").concat(JSON.stringify(typ)));
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.json] = {
        key: p.js,
        typ: p.typ
      };
    });
    typ.jsonToJS = map;
  }

  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.js] = {
        key: p.json,
        typ: p.typ
      };
    });
    typ.jsToJSON = map;
  }

  return typ.jsToJSON;
}

function transform(val, typ, getProps) {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    var l = typs.length;

    for (var i = 0; i < l; i++) {
      var _typ = typs[i];

      try {
        return transform(val, _typ, getProps);
      } catch (_) {}
    }

    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue("array", val);
    return val.map(function (el) {
      return transform(el, typ, getProps);
    });
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }

    var d = new Date(val);

    if (isNaN(d.valueOf())) {
      return invalidValue("Date", val);
    }

    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== "object" || Array.isArray(val)) {
      return invalidValue("object", val);
    }

    var result = {};
    Object.getOwnPropertyNames(props).forEach(function (key) {
      var prop = props[key];
      var v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps);
    });
    Object.getOwnPropertyNames(val).forEach(function (key) {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps);
      }
    });
    return result;
  }

  if (typ === "any") return val;

  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }

  if (typ === false) return invalidValue(typ, val);

  while (typeof typ === "object" && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }

  if (Array.isArray(typ)) return transformEnum(typ, val);

  if (typeof typ === "object") {
    return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val) : typ.hasOwnProperty("arrayItems") ? transformArray(typ.arrayItems, val) : typ.hasOwnProperty("props") ? transformObject(getProps(typ), typ.additional, val) : invalidValue(typ, val);
  } // Numbers can be parsed by Date but shouldn't be.


  if (typ === Date && typeof val !== "number") return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return {
    arrayItems: typ
  };
}

function u$b() {
  for (var _len = arguments.length, typs = new Array(_len), _key = 0; _key < _len; _key++) {
    typs[_key] = arguments[_key];
  }

  return {
    unionMembers: typs
  };
}

function o(props, additional) {
  return {
    props: props,
    additional: additional
  };
}

function r(name) {
  return {
    ref: name
  };
}

var typeMap = {
  AgeDistributionArray: o([{
    json: "all",
    js: "all",
    typ: a(r("AgeDistributionData"))
  }], false),
  AgeDistributionData: o([{
    json: "data",
    js: "data",
    typ: a(r("AgeDistributionDatum"))
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  AgeDistributionDatum: o([{
    json: "ageGroup",
    js: "ageGroup",
    typ: r("AgeGroup")
  }, {
    json: "population",
    js: "population",
    typ: 0
  }], false),
  CaseCountsArray: o([{
    json: "all",
    js: "all",
    typ: a(r("CaseCountsData"))
  }], false),
  CaseCountsData: o([{
    json: "data",
    js: "data",
    typ: a(r("CaseCountsDatum"))
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  CaseCountsDatum: o([{
    json: "cases",
    js: "cases",
    typ: u$b(0, null)
  }, {
    json: "deaths",
    js: "deaths",
    typ: u$b(undefined, u$b(0, null))
  }, {
    json: "hospitalized",
    js: "hospitalized",
    typ: u$b(undefined, u$b(0, null))
  }, {
    json: "icu",
    js: "icu",
    typ: u$b(undefined, u$b(0, null))
  }, {
    json: "recovered",
    js: "recovered",
    typ: u$b(undefined, u$b(0, null))
  }, {
    json: "time",
    js: "time",
    typ: Date
  }], false),
  ScenarioArray: o([{
    json: "all",
    js: "all",
    typ: a(r("ScenarioData"))
  }], false),
  ScenarioData: o([{
    json: "data",
    js: "data",
    typ: r("ScenarioDatum")
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  ScenarioDatum: o([{
    json: "epidemiological",
    js: "epidemiological",
    typ: r("ScenarioDatumEpidemiological")
  }, {
    json: "mitigation",
    js: "mitigation",
    typ: r("ScenarioDatumMitigation")
  }, {
    json: "population",
    js: "population",
    typ: r("ScenarioDatumPopulation")
  }, {
    json: "simulation",
    js: "simulation",
    typ: r("ScenarioDatumSimulation")
  }], false),
  ScenarioDatumEpidemiological: o([{
    json: "hospitalStayDays",
    js: "hospitalStayDays",
    typ: 3.14
  }, {
    json: "icuStayDays",
    js: "icuStayDays",
    typ: 3.14
  }, {
    json: "infectiousPeriodDays",
    js: "infectiousPeriodDays",
    typ: 3.14
  }, {
    json: "latencyDays",
    js: "latencyDays",
    typ: 3.14
  }, {
    json: "overflowSeverity",
    js: "overflowSeverity",
    typ: 3.14
  }, {
    json: "peakMonth",
    js: "peakMonth",
    typ: 0
  }, {
    json: "r0",
    js: "r0",
    typ: r("NumericRangeNonNegative")
  }, {
    json: "seasonalForcing",
    js: "seasonalForcing",
    typ: 3.14
  }], false),
  NumericRangeNonNegative: o([{
    json: "begin",
    js: "begin",
    typ: 3.14
  }, {
    json: "end",
    js: "end",
    typ: 3.14
  }], false),
  ScenarioDatumMitigation: o([{
    json: "mitigationIntervals",
    js: "mitigationIntervals",
    typ: a(r("MitigationInterval"))
  }], false),
  MitigationInterval: o([{
    json: "color",
    js: "color",
    typ: ""
  }, {
    json: "name",
    js: "name",
    typ: ""
  }, {
    json: "timeRange",
    js: "timeRange",
    typ: r("DateRange")
  }, {
    json: "transmissionReduction",
    js: "transmissionReduction",
    typ: r("PercentageRange")
  }], false),
  DateRange: o([{
    json: "begin",
    js: "begin",
    typ: Date
  }, {
    json: "end",
    js: "end",
    typ: Date
  }], false),
  PercentageRange: o([{
    json: "begin",
    js: "begin",
    typ: 3.14
  }, {
    json: "end",
    js: "end",
    typ: 3.14
  }], false),
  ScenarioDatumPopulation: o([{
    json: "ageDistributionName",
    js: "ageDistributionName",
    typ: ""
  }, {
    json: "caseCountsName",
    js: "caseCountsName",
    typ: ""
  }, {
    json: "hospitalBeds",
    js: "hospitalBeds",
    typ: 0
  }, {
    json: "icuBeds",
    js: "icuBeds",
    typ: 0
  }, {
    json: "importsPerDay",
    js: "importsPerDay",
    typ: 3.14
  }, {
    json: "initialNumberOfCases",
    js: "initialNumberOfCases",
    typ: 0
  }, {
    json: "populationServed",
    js: "populationServed",
    typ: 0
  }], false),
  ScenarioDatumSimulation: o([{
    json: "numberStochasticRuns",
    js: "numberStochasticRuns",
    typ: 0
  }, {
    json: "simulationTimeRange",
    js: "simulationTimeRange",
    typ: r("DateRange")
  }], false),
  SeverityDistributionArray: o([{
    json: "all",
    js: "all",
    typ: a(r("SeverityDistributionData"))
  }], false),
  SeverityDistributionData: o([{
    json: "data",
    js: "data",
    typ: a(r("SeverityDistributionDatum"))
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  SeverityDistributionDatum: o([{
    json: "ageGroup",
    js: "ageGroup",
    typ: r("AgeGroup")
  }, {
    json: "confirmed",
    js: "confirmed",
    typ: 3.14
  }, {
    json: "critical",
    js: "critical",
    typ: 3.14
  }, {
    json: "fatal",
    js: "fatal",
    typ: 3.14
  }, {
    json: "isolated",
    js: "isolated",
    typ: 3.14
  }, {
    json: "palliative",
    js: "palliative",
    typ: 3.14
  }, {
    json: "severe",
    js: "severe",
    typ: 3.14
  }], false),
  Shareable: o([{
    json: "ageDistributionData",
    js: "ageDistributionData",
    typ: r("AgeDistributionData")
  }, {
    json: "scenarioData",
    js: "scenarioData",
    typ: r("ScenarioData")
  }, {
    json: "schemaVer",
    js: "schemaVer",
    typ: ""
  }, {
    json: "severityDistributionData",
    js: "severityDistributionData",
    typ: r("SeverityDistributionData")
  }], false),
  AgeGroup: ["0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80+"]
};

var monthToDay = function monthToDay(m) {
  return m * 30 + 15;
};

var jan2020 = new Date('2020-01-01').valueOf(); // time in ms

function withUncertainty(scenario) {
  var noRanges = scenario.mitigationIntervals.every(function (interval) {
    return interval.transmissionReduction.begin === interval.transmissionReduction.end;
  });

  if (scenario.r0.begin === scenario.r0.end && noRanges) {
    return false;
  }

  return true;
}
var msPerDay = 1000 * 60 * 60 * 24;
/**
 *
 * @param time - point in time, until which simulation runs, as epoch time
 * @param avgInfectionRate
 * @param peakMonth - counting number in range of 0-11
 * @param seasonalForcing -  seasonal variation in transmission. Usually a decimal number, e. g. 0.2
 * @returns
 */

function infectionRate(time, avgInfectionRate, peakMonth, seasonalForcing) {
  // this is super hacky
  var phase = ((time - jan2020) / msPerDay / 365 - monthToDay(peakMonth) / 365) * 2 * Math.PI;
  return avgInfectionRate * (1 + seasonalForcing * Math.cos(phase));
}
function getPopulationParams(scenario, severity, ageDistribution, meanOnly) {
  var hospitalBeds = scenario.hospitalBeds,
      hospitalStayDays = scenario.hospitalStayDays,
      icuBeds = scenario.icuBeds,
      icuStayDays = scenario.icuStayDays,
      importsPerDay = scenario.importsPerDay,
      infectiousPeriodDays = scenario.infectiousPeriodDays,
      latencyDays = scenario.latencyDays,
      mitigationIntervals = scenario.mitigationIntervals,
      numberStochasticRuns = scenario.numberStochasticRuns,
      overflowSeverity = scenario.overflowSeverity,
      peakMonth = scenario.peakMonth,
      populationServed = scenario.populationServed,
      r0 = scenario.r0,
      seasonalForcing = scenario.seasonalForcing; // TODO: Make this a form-adjustable factor

  var sim = {
    ageDistribution: [{
      ageGroup: AgeGroup.The09,
      population: 0
    }, {
      ageGroup: AgeGroup.The1019,
      population: 0
    }, {
      ageGroup: AgeGroup.The2029,
      population: 0
    }, {
      ageGroup: AgeGroup.The3039,
      population: 0
    }, {
      ageGroup: AgeGroup.The4049,
      population: 0
    }, {
      ageGroup: AgeGroup.The5059,
      population: 0
    }, {
      ageGroup: AgeGroup.The6069,
      population: 0
    }, {
      ageGroup: AgeGroup.The7079,
      population: 0
    }, {
      ageGroup: AgeGroup.The80,
      population: 0
    }],
    importsPerDay: [],
    timeDelta: 0,
    timeDeltaDays: 0,
    frac: {
      severe: [],
      critical: [],
      fatal: [],
      isolated: [],
      palliative: []
    },
    rate: {
      latency: 1 / latencyDays,
      infection: function infection() {
        return -Infinity;
      },
      // Dummy infectionRate function. This is set below.
      recovery: [],
      severe: [],
      discharge: [],
      critical: [],
      stabilize: [],
      palliative: [],
      fatality: [],
      overflowFatality: []
    },
    populationServed: populationServed,
    numberStochasticRuns: numberStochasticRuns,
    hospitalBeds: hospitalBeds,
    icuBeds: icuBeds
  };

  var total = sumBy_1(ageDistribution, function (_ref) {
    var population = _ref.population;
    return population;
  });

  severity.forEach(function (_ref2, i) {
    var ageGroup = _ref2.ageGroup,
        confirmed = _ref2.confirmed,
        critical = _ref2.critical,
        isolated = _ref2.isolated,
        fatal = _ref2.fatal,
        severe = _ref2.severe,
        palliative = _ref2.palliative;
    var freq = 1.0 * ageDistribution[i].population / total;
    sim.ageDistribution[i].population = freq;
    sim.frac.severe[i] = severe / 100 * (confirmed / 100);
    sim.frac.critical[i] = sim.frac.severe[i] * (critical / 100);
    sim.frac.fatal[i] = sim.frac.critical[i] * (fatal / 100);
    sim.frac.palliative[i] = sim.frac.severe[i] * (palliative / 100);
    var dHospital = sim.frac.severe[i];
    var dCritical = critical / 100;
    var dFatal = fatal / 100;
    var dPalliative = palliative / 100; // Age specific rates

    sim.frac.isolated[i] = isolated / 100;
    sim.rate.recovery[i] = (1 - dHospital) / infectiousPeriodDays;
    sim.rate.severe[i] = dHospital / infectiousPeriodDays;
    sim.rate.discharge[i] = (1 - dCritical - dPalliative) / hospitalStayDays;
    sim.rate.palliative[i] = dPalliative / hospitalStayDays;
    sim.rate.critical[i] = dCritical / hospitalStayDays;
    sim.rate.stabilize[i] = (1 - dFatal) / icuStayDays;
    sim.rate.fatality[i] = dFatal / icuStayDays;
    sim.rate.overflowFatality[i] = overflowSeverity * sim.rate.fatality[i];
  }); // Get import rates per age class (assume flat)

  var L = Object.keys(sim.rate.recovery).length;
  sim.rate.recovery.forEach(function (_, i) {
    sim.importsPerDay[i] = importsPerDay / L;
  }); // Infectivity dynamics
  // interpolateTimeSeries(intervalsToTimeSeries(params.mitigationIntervals))

  var containmentRealization = containmentMeasures(mitigationIntervals, numberStochasticRuns, meanOnly);
  var r0s = meanOnly ? [0.5 * (r0.begin + r0.end)] : sampleUniform(r0, numberStochasticRuns);
  return r0s.map(function (tmpR0, i) {
    var elt = cloneDeep_1(sim);

    var avgInfectionRate = tmpR0 / infectiousPeriodDays;
    var containment = containmentRealization.length > 1 ? containmentRealization[i] : containmentRealization[0];

    elt.rate.infection = function (time) {
      return containment(time) * infectionRate(time, avgInfectionRate, peakMonth, seasonalForcing);
    };

    return elt;
  });
}
function initializePopulation(N, numCases, t0, ageDistribution) {
  var Z = sumBy_1(ageDistribution, function (_ref3) {
    var population = _ref3.population;
    return population;
  });

  var pop = {
    time: t0,
    current: {
      susceptible: [],
      exposed: [],
      infectious: [],
      severe: [],
      critical: [],
      overflow: []
    },
    cumulative: {
      recovered: [],
      hospitalized: [],
      critical: [],
      fatality: []
    }
  }; // specification of the initial condition: there are numCases at tMin
  // of those, 0.3 are infectious, the remainder is exposed and will turn
  // infectious as they propagate through the exposed categories.

  var initialInfectiousFraction = 0.3;
  ageDistribution.forEach(function (_ref4, i) {
    var population = _ref4.population;
    var n = Math.round(population / Z * N);
    pop.current.susceptible[i] = n;
    pop.current.exposed[i] = [0, 0, 0];
    pop.current.infectious[i] = 0;
    pop.current.severe[i] = 0;
    pop.current.critical[i] = 0;
    pop.current.overflow[i] = 0;
    pop.cumulative.hospitalized[i] = 0;
    pop.cumulative.recovered[i] = 0;
    pop.cumulative.critical[i] = 0;
    pop.cumulative.fatality[i] = 0;

    if (i === Math.round(ageDistribution.length / 2)) {
      pop.current.susceptible[i] -= numCases;
      pop.current.infectious[i] = initialInfectiousFraction * numCases;
      var e = (1 - initialInfectiousFraction) * numCases / pop.current.exposed[i].length;
      pop.current.exposed[i] = pop.current.exposed[i].map(function (_) {
        return e;
      });
    }
  });
  return pop;
}

var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH$8 = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

var SPECIES$2 = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max$1 = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$8 }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES$2];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
var stringRepeat = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};

// https://github.com/tc39/proposal-string-pad-start-end




var ceil$1 = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod$5 = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = String(requireObjectCoercible($this));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = toLength(maxLength);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

var stringPad = {
  // `String.prototype.padStart` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
  start: createMethod$5(false),
  // `String.prototype.padEnd` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
  end: createMethod$5(true)
};

var padStart = stringPad.start;

var abs = Math.abs;
var DatePrototype$1 = Date.prototype;
var getTime$1 = DatePrototype$1.getTime;
var nativeDateToISOString = DatePrototype$1.toISOString;

// `Date.prototype.toISOString` method implementation
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:
var dateToIsoString = (fails(function () {
  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  nativeDateToISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime$1.call(this))) throw RangeError('Invalid time value');
  var date = this;
  var year = date.getUTCFullYear();
  var milliseconds = date.getUTCMilliseconds();
  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
  return sign + padStart(abs(year), sign ? 6 : 4, 0) +
    '-' + padStart(date.getUTCMonth() + 1, 2, 0) +
    '-' + padStart(date.getUTCDate(), 2, 0) +
    'T' + padStart(date.getUTCHours(), 2, 0) +
    ':' + padStart(date.getUTCMinutes(), 2, 0) +
    ':' + padStart(date.getUTCSeconds(), 2, 0) +
    '.' + padStart(milliseconds, 3, 0) +
    'Z';
} : nativeDateToISOString;

// `Date.prototype.toISOString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations
_export({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== dateToIsoString }, {
  toISOString: dateToIsoString
});

var $values = objectToArray.values;

// `Object.values` method
// https://tc39.github.io/ecma262/#sec-object.values
_export({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});

var eulerStep = 0.5;
function evolve(pop, P, tMax, sample) {
  var dT = tMax - pop.time;
  var nSteps = Math.max(1, Math.round(dT / eulerStep));
  var dt = dT / nSteps;
  var currState = pop;

  for (var i = 0; i < nSteps; i++) {
    currState = stepODE(currState, P, dt);
  }

  return currState;
}

// NOTE: Assumes all subfields corresponding to populations have the same set of keys
function stepODE(pop, P, dt) {
  var t0 = pop.time;
  var t1 = pop.time + dt / 2 * msPerDay;
  var t2 = pop.time + dt * msPerDay;
  var k1 = derivative(fluxes(t0, pop, P));
  var k2 = derivative(fluxes(t1, advanceState(pop, k1, dt / 2, P.icuBeds), P));
  var k3 = derivative(fluxes(t1, advanceState(pop, k2, dt / 2, P.icuBeds), P));
  var k4 = derivative(fluxes(t2, advanceState(pop, k3, dt, P.icuBeds), P));
  var tdot = sumDerivatives([k1, k2, k3, k4], [1 / 6, 1 / 3, 1 / 3, 1 / 6]);
  var state = advanceState(pop, tdot, dt, P.icuBeds);
  state.time = t2.valueOf();
  return state;
}

function sum(arr) {
  return arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}
function gz(x) {
  return x > 0 ? x : 0;
}

function advanceState(pop, tdot, dt, nICUBeds) {
  var newPop = {
    time: 0,
    current: {
      susceptible: [],
      exposed: [],
      infectious: [],
      severe: [],
      critical: [],
      overflow: []
    },
    cumulative: {
      recovered: [],
      hospitalized: [],
      critical: [],
      fatality: []
    }
  }; // TODO(nnoll): Sort out types
  // @ts-ignore

  var update = function update(age, kind, compartment) {
    // @ts-ignore
    newPop[kind][compartment][age] = gz(pop[kind][compartment][age] + dt * tdot[kind][compartment][age]);
  }; // @ts-ignore


  var updateAt = function updateAt(age, kind, compartment, i) {
    // @ts-ignore
    newPop[kind][compartment][age][i] = gz(pop[kind][compartment][age][i] + dt * tdot[kind][compartment][age][i]);
  };

  for (var age = 0; age < pop.current.infectious.length; age++) {
    newPop.current.exposed[age] = Array(tdot.current.exposed[age].length);
    update(age, 'current', 'susceptible');

    for (var i = 0; i < pop.current.exposed[age].length; i++) {
      updateAt(age, 'current', 'exposed', i);
    }

    update(age, 'current', 'critical');
    update(age, 'current', 'infectious');
    update(age, 'current', 'overflow');
    update(age, 'current', 'severe');
    update(age, 'current', 'susceptible');
    update(age, 'cumulative', 'critical');
    update(age, 'cumulative', 'fatality');
    update(age, 'cumulative', 'hospitalized');
    update(age, 'cumulative', 'recovered');
  } // Move hospitalized patients according to constrained resources
  // TODO(nnoll): The gradients aren't computed subject to this non-linear constraint


  var freeICUBeds = nICUBeds - sum(newPop.current.critical);

  for (var _age = pop.current.critical.length - 1; freeICUBeds < 0 && _age >= 0; _age--) {
    if (newPop.current.critical[_age] > -freeICUBeds) {
      newPop.current.critical[_age] += freeICUBeds;
      newPop.current.overflow[_age] -= freeICUBeds;
      freeICUBeds = 0;
    } else {
      newPop.current.overflow[_age] += newPop.current.critical[_age];
      freeICUBeds += newPop.current.critical[_age];
      newPop.current.critical[_age] = 0;
    }
  }

  for (var _age2 = 0; freeICUBeds > 0 && _age2 < pop.current.critical.length; _age2++) {
    if (newPop.current.overflow[_age2] > freeICUBeds) {
      newPop.current.critical[_age2] += freeICUBeds;
      newPop.current.overflow[_age2] -= freeICUBeds;
      freeICUBeds = 0;
    } else {
      newPop.current.critical[_age2] += newPop.current.overflow[_age2];
      freeICUBeds -= newPop.current.overflow[_age2];
      newPop.current.overflow[_age2] = 0;
    }
  }

  return newPop;
}

function sumDerivatives(grads, scale) {
  var sum = {
    current: {
      susceptible: [],
      exposed: [],
      infectious: [],
      severe: [],
      critical: [],
      overflow: []
    },
    cumulative: {
      hospitalized: [],
      critical: [],
      recovered: [],
      fatality: []
    }
  };

  for (var age = 0; age < grads[0].current.susceptible.length; age++) {
    sum.current.susceptible[age] = 0;
    sum.current.exposed[age] = grads[0].current.exposed[age].map(function () {
      return 0;
    });
    sum.current.infectious[age] = 0;
    sum.current.critical[age] = 0;
    sum.current.overflow[age] = 0;
    sum.current.severe[age] = 0;
    sum.cumulative.critical[age] = 0;
    sum.cumulative.fatality[age] = 0;
    sum.cumulative.recovered[age] = 0;
    sum.cumulative.hospitalized[age] = 0;
  }

  grads.forEach(function (grad, i) {
    var _loop = function _loop(_age3) {
      sum.current.susceptible[_age3] += scale[i] * grad.current.susceptible[_age3];
      sum.current.infectious[_age3] += scale[i] * grad.current.infectious[_age3];

      grad.current.exposed[_age3].forEach(function (e, j) {
        sum.current.exposed[_age3][j] += scale[i] * e;
      });

      sum.current.severe[_age3] += scale[i] * grad.current.severe[_age3];
      sum.current.critical[_age3] += scale[i] * grad.current.critical[_age3];
      sum.current.overflow[_age3] += scale[i] * grad.current.overflow[_age3];
      sum.cumulative.recovered[_age3] += scale[i] * grad.cumulative.recovered[_age3];
      sum.cumulative.fatality[_age3] += scale[i] * grad.cumulative.fatality[_age3];
      sum.cumulative.critical[_age3] += scale[i] * grad.cumulative.critical[_age3];
      sum.cumulative.hospitalized[_age3] += scale[i] * grad.cumulative.hospitalized[_age3];
    };

    for (var _age3 = 0; _age3 < grads[0].current.susceptible.length; _age3++) {
      _loop(_age3);
    }
  });
  return sum;
}

function derivative(flux) {
  var grad = {
    current: {
      susceptible: [],
      exposed: [],
      infectious: [],
      severe: [],
      critical: [],
      overflow: []
    },
    cumulative: {
      recovered: [],
      hospitalized: [],
      critical: [],
      fatality: []
    }
  };

  var _loop2 = function _loop2(age) {
    grad.current.exposed[age] = Array(flux.exposed[age].length);
    grad.current.susceptible[age] = -flux.susceptible[age];
    var fluxIn = flux.susceptible[age];
    flux.exposed[age].forEach(function (fluxOut, i) {
      grad.current.exposed[age][i] = fluxIn - fluxOut;
      fluxIn = fluxOut;
    });
    grad.current.infectious[age] = fluxIn - flux.infectious.severe[age] - flux.infectious.recovered[age];
    grad.current.severe[age] = flux.infectious.severe[age] + flux.critical.severe[age] + flux.overflow.severe[age] - flux.severe.critical[age] - flux.severe.palliative[age] - flux.severe.recovered[age];
    grad.current.critical[age] = flux.severe.critical[age] - flux.critical.severe[age] - flux.critical.fatality[age];
    grad.current.overflow[age] = -(flux.overflow.severe[age] + flux.overflow.fatality[age]); // Cumulative categories

    grad.cumulative.recovered[age] = flux.infectious.recovered[age] + flux.severe.recovered[age];
    grad.cumulative.hospitalized[age] = flux.infectious.severe[age];
    grad.cumulative.critical[age] = flux.severe.critical[age];
    grad.cumulative.fatality[age] = flux.critical.fatality[age] + flux.overflow.fatality[age] + flux.severe.palliative[age];
  };

  for (var age = 0; age < flux.susceptible.length; age++) {
    _loop2(age);
  }

  return grad;
}

function fluxes(time, pop, P) {
  // Convention: flux is labelled by the state
  var flux = {
    susceptible: [],
    exposed: [],
    infectious: {
      severe: [],
      recovered: []
    },
    severe: {
      critical: [],
      recovered: [],
      palliative: []
    },
    critical: {
      severe: [],
      fatality: []
    },
    overflow: {
      severe: [],
      fatality: []
    }
  }; // Compute all fluxes (apart from overflow states) barring no hospital bed constraints

  var fracInfected = sum(pop.current.infectious) / P.populationServed;

  var _loop3 = function _loop3(age) {
    // Initialize all multi-faceted states with internal arrays
    flux.exposed[age] = Array(pop.current.exposed[age].length); // Susceptible -> Exposed

    flux.susceptible[age] = P.importsPerDay[age] + (1 - P.frac.isolated[age]) * P.rate.infection(time) * pop.current.susceptible[age] * fracInfected; // Exposed -> Internal -> Infectious

    pop.current.exposed[age].forEach(function (exposed, i, exposedArray) {
      flux.exposed[age][i] = P.rate.latency * exposed * exposedArray.length;
    }); // Infectious -> Recovered/Critical

    flux.infectious.recovered[age] = pop.current.infectious[age] * P.rate.recovery[age];
    flux.infectious.severe[age] = pop.current.infectious[age] * P.rate.severe[age]; // Severe -> Recovered/Palliative/Critical

    flux.severe.recovered[age] = pop.current.severe[age] * P.rate.discharge[age];
    flux.severe.critical[age] = pop.current.severe[age] * P.rate.critical[age];
    flux.severe.palliative[age] = pop.current.severe[age] * P.rate.palliative[age]; // Critical -> Severe/Fatality

    flux.critical.severe[age] = pop.current.critical[age] * P.rate.stabilize[age];
    flux.critical.fatality[age] = pop.current.critical[age] * P.rate.fatality[age]; // Overflow -> Severe/Fatality

    flux.overflow.severe[age] = pop.current.overflow[age] * P.rate.stabilize[age];
    flux.overflow.fatality[age] = pop.current.overflow[age] * P.rate.overflowFatality[age];
  };

  for (var age = 0; age < pop.current.infectious.length; age++) {
    _loop3(age);
  }

  return flux;
}

function collectTotals(trajectory, ages) {
  var res = [];
  trajectory.forEach(function (d, day) {
    var prevDay = day > 7 ? day - 7 : 0;
    var tp = {
      time: d.time,
      current: {
        susceptible: {},
        severe: {},
        exposed: {},
        overflow: {},
        critical: {},
        infectious: {},
        weeklyFatality: {}
      },
      cumulative: {
        recovered: {},
        hospitalized: {},
        critical: {},
        fatality: {}
      }
    }; // TODO(nnoll): Typescript linting isn't happy here

    Object.keys(tp.current).forEach(function (k) {
      if (k === 'exposed') {
        tp.current.exposed.total = 0;
        Object.values(d.current.exposed).forEach(function (x) {
          x.forEach(function (y) {
            tp.current[k].total += y;
          });
        });
        ages.forEach(function (age, i) {
          tp.current[k][age] = d.current.exposed[i].reduce(function (a, b) {
            return a + b;
          }, 0);
        });
      } else if (k === 'weeklyFatality') {
        ages.forEach(function (age, i) {
          tp.current.weeklyFatality[age] = d.cumulative.fatality[i] - trajectory[prevDay].cumulative.fatality[i];
        });
        tp.current.weeklyFatality.total = d.cumulative.fatality.reduce(function (a, b) {
          return a + b;
        }) - trajectory[prevDay].cumulative.fatality.reduce(function (a, b) {
          return a + b;
        });
      } else {
        ages.forEach(function (age, i) {
          // @ts-ignore
          tp.current[k][age] = d.current[k][i];
        }); // @ts-ignore

        tp.current[k].total = d.current[k].reduce(function (a, b) {
          return a + b;
        });
      }
    });
    Object.keys(tp.cumulative).forEach(function (k, day) {
      ages.forEach(function (age, i) {
        // @ts-ignore
        tp.cumulative[k][age] = d.cumulative[k][i];
      }); // @ts-ignore

      tp.cumulative[k].total = d.cumulative[k].reduce(function (a, b) {
        return a + b;
      }, 0);
    });
    res.push(tp);
  });
  return res;
}

// `Date.now` method
// https://tc39.github.io/ecma262/#sec-date.now
_export({ target: 'Date', stat: true }, {
  now: function now() {
    return new Date().getTime();
  }
});

// -----------------------------------------------------------------------
// Simulation data methods

/* Constructors */
function emptyTimePoint(t) {
  return {
    time: t,
    // Dummy
    current: {
      susceptible: {},
      severe: {},
      critical: {},
      exposed: {},
      infectious: {},
      overflow: {},
      weeklyFatality: {}
    },
    cumulative: {
      recovered: {},
      critical: {},
      hospitalized: {},
      fatality: {}
    }
  };
}

function percentileTPs(tps, prc) {
  var res = emptyTimePoint(tps[0].time);
  var idx = Math.ceil(prc * (tps.length - 1));
  Object.keys(tps[0]).forEach(function (kind) {
    Object.keys(tps[0][kind]).forEach(function (k) {
      Object.keys(tps[0][kind][k]).forEach(function (age) {
        res[kind][k][age] = tps.map(function (d) {
          return d[kind][k][age];
        }).sort(function (x, y) {
          return x - y;
        })[idx];
      });
    });
  });
  return res;
} // -----------------------------------------------------------------------
// Operations on sets of realizations

function percentileTrajectory(trajectories, prc) {
  return trajectories[0].map(function (_0, i) {
    return percentileTPs(trajectories.map(function (traj) {
      return traj[i];
    }), prc);
  });
}

function verifyPositive(x) {
  var xRounded = Math.round(x);
  return xRounded > 0 ? xRounded : undefined;
}
function verifyTuple(x, center) {
  var centerVal = center ? verifyPositive(center) : undefined;

  if (x[0] !== undefined && x[1] !== undefined && centerVal !== undefined) {
    return [x[0] < centerVal ? x[0] : centerVal, x[1] > centerVal ? x[1] : centerVal];
  }

  if (x[0] !== undefined && x[1] !== undefined) {
    return [x[0], x[1]];
  }

  if (x[0] === undefined && x[1] !== undefined && centerVal !== undefined) {
    return [0.0001, x[1] > centerVal ? x[1] : centerVal];
  }

  if (x[0] === undefined && x[1] !== undefined) {
    return [0.0001, x[1]];
  }

  return undefined;
}

function preparePlotData(trajectory) {
  var lower = trajectory.lower,
      middle = trajectory.middle,
      upper = trajectory.upper;
  return middle.map(function (x, day) {
    return {
      time: x.time,
      lines: {
        susceptible: verifyPositive(x.current.susceptible.total),
        infectious: verifyPositive(x.current.infectious.total),
        severe: verifyPositive(x.current.severe.total),
        critical: verifyPositive(x.current.critical.total),
        overflow: verifyPositive(x.current.overflow.total),
        recovered: verifyPositive(x.cumulative.recovered.total),
        fatality: verifyPositive(x.cumulative.fatality.total),
        weeklyFatality: verifyPositive(x.current.weeklyFatality.total)
      },
      // Error bars
      areas: {
        susceptible: verifyTuple([verifyPositive(lower[day].current.susceptible.total), verifyPositive(upper[day].current.susceptible.total)], x.current.susceptible.total),
        infectious: verifyTuple([verifyPositive(lower[day].current.infectious.total), verifyPositive(upper[day].current.infectious.total)], x.current.infectious.total),
        severe: verifyTuple([verifyPositive(lower[day].current.severe.total), verifyPositive(upper[day].current.severe.total)], x.current.severe.total),
        critical: verifyTuple([verifyPositive(lower[day].current.critical.total), verifyPositive(upper[day].current.critical.total)], x.current.critical.total),
        overflow: verifyTuple([verifyPositive(lower[day].current.overflow.total), verifyPositive(upper[day].current.overflow.total)], x.current.overflow.total),
        recovered: verifyTuple([verifyPositive(lower[day].cumulative.recovered.total), verifyPositive(upper[day].cumulative.recovered.total)], x.cumulative.recovered.total),
        fatality: verifyTuple([verifyPositive(lower[day].cumulative.fatality.total), verifyPositive(upper[day].cumulative.fatality.total)], x.cumulative.fatality.total),
        weeklyFatality: verifyTuple([verifyPositive(lower[day].current.weeklyFatality.total), verifyPositive(upper[day].current.weeklyFatality.total)], x.current.weeklyFatality.total)
      }
    };
  });
}

function simulate(initialState, params, tMax, ageGroups, func) {
  var dynamics = [initialState];
  var currState = initialState;

  while (currState.time < tMax) {
    currState = evolve(currState, params, currState.time + 1);
    dynamics.push(currState);
  }

  return collectTotals(dynamics, ageGroups);
}

function run(_x) {
  return _run.apply(this, arguments);
}

function _run() {
  _run = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
    var params, severity, ageDistribution, tMin, tMax, ageGroups, initialCases, stochastic, stochasticTrajectories, stochasticParams, deterministicParams, population, deterministicTrajectory, thresholds, idxs, R0Trajectories, meanR0Trajectory, resultsTrajectory;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            params = _ref.params, severity = _ref.severity, ageDistribution = _ref.ageDistribution;
            tMin = new Date(params.simulationTimeRange.begin).getTime();
            tMax = new Date(params.simulationTimeRange.end).getTime();
            ageGroups = ageDistribution.map(function (d) {
              return d.ageGroup;
            });
            initialCases = params.initialNumberOfCases;
            stochastic = withUncertainty(params);
            stochasticTrajectories = [];
            stochasticParams = [];

            if (stochastic) {
              stochasticParams = getPopulationParams(params, severity, ageDistribution, false);
              stochasticTrajectories = stochasticParams.map(function (modelParams) {
                var tmpPopulation = initializePopulation(modelParams.populationServed, initialCases, tMin, ageDistribution);
                return simulate(tmpPopulation, modelParams, tMax, ageGroups);
              });
            }

            deterministicParams = getPopulationParams(params, severity, ageDistribution, true)[0];
            population = initializePopulation(deterministicParams.populationServed, initialCases, tMin, ageDistribution);
            deterministicTrajectory = simulate(population, deterministicParams, tMax, ageGroups);
            thresholds = [0.2, 0.8];
            idxs = thresholds.map(function (d) {
              return Math.ceil((stochasticTrajectories.length - 1) * d);
            });
            R0Trajectories = stochastic ? deterministicTrajectory.map(function (d) {
              return {
                t: d.time,
                y: stochasticParams.map(function (ModelParams) {
                  return ModelParams.rate.infection(d.time) * params.infectiousPeriodDays;
                }).sort(function (a, b) {
                  return a - b;
                })
              };
            }) : [];
            meanR0Trajectory = deterministicTrajectory.map(function (d) {
              return {
                t: d.time,
                y: deterministicParams.rate.infection(d.time) * params.infectiousPeriodDays
              };
            });
            resultsTrajectory = {
              lower: stochastic ? percentileTrajectory(stochasticTrajectories, 0.2) : deterministicTrajectory,
              middle: deterministicTrajectory,
              upper: stochastic ? percentileTrajectory(stochasticTrajectories, 0.8) : deterministicTrajectory,
              percentile: {}
            };
            return _context.abrupt("return", {
              trajectory: resultsTrajectory,
              R0: {
                mean: meanR0Trajectory,
                lower: stochastic ? R0Trajectories.map(function (d) {
                  return {
                    t: d.t,
                    y: d.y[idxs[0]]
                  };
                }) : meanR0Trajectory,
                upper: stochastic ? R0Trajectories.map(function (d) {
                  return {
                    t: d.t,
                    y: d.y[idxs[1]]
                  };
                }) : meanR0Trajectory
              },
              plotData: preparePlotData(resultsTrajectory)
            });

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _run.apply(this, arguments);
}

function appendDash(str) {
  return " - ".concat(str);
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';

const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991;

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;

var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
  MAX_SAFE_COMPONENT_LENGTH
};

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {};

var debug_1 = debug;

var re_1 = createCommonjsModule(function (module, exports) {
const { MAX_SAFE_COMPONENT_LENGTH } = constants;

exports = module.exports = {};

// The actual regexps go on exports.re
const re = exports.re = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;

const createToken = (name, value, isGlobal) => {
  const index = R++;
  debug_1(index, value);
  t[name] = index;
  src[index] = value;
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
};

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`);

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`);

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`);

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`);

createToken('FULL', `^${src[t.FULLPLAIN]}$`);

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`);

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

createToken('GTLT', '((?:<|>)?=?)');

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`);

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`);

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`);

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`);

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
});

const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
};

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

var identifiers = {
  compareIdentifiers,
  rcompareIdentifiers
};

const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$4 } = constants;
const { re, t } = re_1;

const { compareIdentifiers: compareIdentifiers$1 } = identifiers;
class SemVer {
  constructor (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH$1} characters`
      )
    }

    debug_1('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER$4 || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER$4 || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER$4 || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER$4) {
            return num
          }
        }
        return id
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug_1('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options);
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return (
      compareIdentifiers$1(this.major, other.major) ||
      compareIdentifiers$1(this.minor, other.minor) ||
      compareIdentifiers$1(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug_1('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers$1(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug_1('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers$1(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }
        this.inc('pre', identifier);
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format();
    this.raw = this.version;
    return this
  }
}

var semver = SemVer;

const {MAX_LENGTH: MAX_LENGTH$2} = constants;
const { re: re$1, t: t$1 } = re_1;


const parse = (version, options) => {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof semver) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH$2) {
    return null
  }

  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];
  if (!r.test(version)) {
    return null
  }

  try {
    return new semver(version, options)
  } catch (er) {
    return null
  }
};

var parse_1 = parse;

const valid = (version, options) => {
  const v = parse_1(version, options);
  return v ? v.version : null
};
var valid_1 = valid;

const clean = (version, options) => {
  const s = parse_1(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null
};
var clean_1 = clean;

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options;
    options = undefined;
  }

  try {
    return new semver(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
};
var inc_1 = inc;

const compare = (a, b, loose) =>
  new semver(a, loose).compare(new semver(b, loose));

var compare_1 = compare;

const eq$1 = (a, b, loose) => compare_1(a, b, loose) === 0;
var eq_1$1 = eq$1;

const diff = (version1, version2) => {
  if (eq_1$1(version1, version2)) {
    return null
  } else {
    const v1 = parse_1(version1);
    const v2 = parse_1(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? 'pre' : '';
    const defaultResult = hasPre ? 'prerelease' : '';
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
};
var diff_1 = diff;

const major = (a, loose) => new semver(a, loose).major;
var major_1 = major;

const minor = (a, loose) => new semver(a, loose).minor;
var minor_1 = minor;

const patch$1 = (a, loose) => new semver(a, loose).patch;
var patch_1 = patch$1;

const prerelease = (version, options) => {
  const parsed = parse_1(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
};
var prerelease_1 = prerelease;

const rcompare = (a, b, loose) => compare_1(b, a, loose);
var rcompare_1 = rcompare;

const compareLoose = (a, b) => compare_1(a, b, true);
var compareLoose_1 = compareLoose;

const compareBuild = (a, b, loose) => {
  const versionA = new semver(a, loose);
  const versionB = new semver(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
};
var compareBuild_1 = compareBuild;

const sort = (list, loose) => list.sort((a, b) => compareBuild_1(a, b, loose));
var sort_1 = sort;

const rsort = (list, loose) => list.sort((a, b) => compareBuild_1(b, a, loose));
var rsort_1 = rsort;

const gt = (a, b, loose) => compare_1(a, b, loose) > 0;
var gt_1 = gt;

const lt = (a, b, loose) => compare_1(a, b, loose) < 0;
var lt_1 = lt;

const neq = (a, b, loose) => compare_1(a, b, loose) !== 0;
var neq_1 = neq;

const gte = (a, b, loose) => compare_1(a, b, loose) >= 0;
var gte_1 = gte;

const lte = (a, b, loose) => compare_1(a, b, loose) <= 0;
var lte_1 = lte;

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a !== b

    case '':
    case '=':
    case '==':
      return eq_1$1(a, b, loose)

    case '!=':
      return neq_1(a, b, loose)

    case '>':
      return gt_1(a, b, loose)

    case '>=':
      return gte_1(a, b, loose)

    case '<':
      return lt_1(a, b, loose)

    case '<=':
      return lte_1(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
};
var cmp_1 = cmp;

const {re: re$2, t: t$2} = re_1;

const coerce = (version, options) => {
  if (version instanceof semver) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {};

  let match = null;
  if (!options.rtl) {
    match = version.match(re$2[t$2.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next;
    while ((next = re$2[t$2.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    // leave it in a clean state
    re$2[t$2.COERCERTL].lastIndex = -1;
  }

  if (match === null)
    return null

  return parse_1(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
};
var coerce_1 = coerce;

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof comparator) {
      // just put it in the set and return
      this.raw = range.value;
      this.set = [[range]];
      this.format();
      return this
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;

    // First, split based on boolean or ||
    this.raw = range;
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length);

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    this.format();
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim();
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    const loose = this.options.loose;
    range = range.trim();
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re$3[t$3.HYPHENRANGELOOSE] : re$3[t$3.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
    debug_1('hyphen replace', range);
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re$3[t$3.COMPARATORTRIM], comparatorTrimReplace);
    debug_1('comparator trim', range, re$3[t$3.COMPARATORTRIM]);

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re$3[t$3.TILDETRIM], tildeTrimReplace);

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re$3[t$3.CARETTRIM], caretTrimReplace);

    // normalize spaces
    range = range.split(/\s+/).join(' ');

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re$3[t$3.COMPARATORLOOSE] : re$3[t$3.COMPARATOR];
    return range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      .map(comp => replaceGTE0(comp, this.options))
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new comparator(comp, this.options))
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new semver(version, this.options);
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
var range = Range;




const {
  re: re$3,
  t: t$3,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = re_1;

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    });

    testComparator = remainingComparators.pop();
  }

  return result
};

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug_1('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug_1('caret', comp);
  comp = replaceTildes(comp, options);
  debug_1('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug_1('xrange', comp);
  comp = replaceStars(comp, options);
  debug_1('stars', comp);
  return comp
};

const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ');

const replaceTilde = (comp, options) => {
  const r = options.loose ? re$3[t$3.TILDELOOSE] : re$3[t$3.TILDE];
  return comp.replace(r, (_, M, m, p, pr) => {
    debug_1('tilde', comp, _, M, m, p, pr);
    let ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
    } else if (pr) {
      debug_1('replaceTilde pr', pr);
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`;
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`;
    }

    debug_1('tilde return', ret);
    return ret
  })
};

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ');

const replaceCaret = (comp, options) => {
  debug_1('caret', comp, options);
  const r = options.loose ? re$3[t$3.CARETLOOSE] : re$3[t$3.CARET];
  const z = options.includePrerelease ? '-0' : '';
  return comp.replace(r, (_, M, m, p, pr) => {
    debug_1('caret', comp, _, M, m, p, pr);
    let ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug_1('replaceCaret pr', pr);
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`;
      }
    } else {
      debug_1('no pr');
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`;
      }
    }

    debug_1('caret return', ret);
    return ret
  })
};

const replaceXRanges = (comp, options) => {
  debug_1('replaceXRanges', comp, options);
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
};

const replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$3[t$3.XRANGELOOSE] : re$3[t$3.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug_1('xRange', comp, ret, gtlt, M, m, p, pr);
    const xM = isX(M);
    const xm = xM || isX(m);
    const xp = xm || isX(p);
    const anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }
      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      if (gtlt === '<')
        pr = '-0';

      ret = `${gtlt + M}.${m}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`;
    }

    debug_1('xRange return', ret);

    return ret
  })
};

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug_1('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re$3[t$3.STAR], '')
};

const replaceGTE0 = (comp, options) => {
  debug_1('replaceGTE0', comp, options);
  return comp.trim()
    .replace(re$3[options.includePrerelease ? t$3.GTE0PRE : t$3.GTE0], '')
};

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }

  return (`${from} ${to}`).trim()
};

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug_1(set[i].semver);
      if (set[i].semver === comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
};

const ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value;
      }
    }

    debug_1('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug_1('comp', this);
  }

  parse (comp) {
    const r = this.options.loose ? re$4[t$4.COMPARATORLOOSE] : re$4[t$4.COMPARATOR];
    const m = comp.match(r);

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : '';
    if (this.operator === '=') {
      this.operator = '';
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new semver(m[2], this.options.loose);
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug_1('Comparator.test', version, this.options.loose);

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new semver(version, this.options);
      } catch (er) {
        return false
      }
    }

    return cmp_1(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>');
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<');
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=');
    const oppositeDirectionsLessThan =
      cmp_1(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<');
    const oppositeDirectionsGreaterThan =
      cmp_1(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>');

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

var comparator = Comparator;

const {re: re$4, t: t$4} = re_1;

const satisfies = (version, range$1, options) => {
  try {
    range$1 = new range(range$1, options);
  } catch (er) {
    return false
  }
  return range$1.test(version)
};
var satisfies_1 = satisfies;

// Mostly just for testing and legacy API reasons
const toComparators = (range$1, options) =>
  new range(range$1, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

var toComparators_1 = toComparators;

const maxSatisfying = (versions, range$1, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new range(range$1, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new semver(max, options);
      }
    }
  });
  return max
};
var maxSatisfying_1 = maxSatisfying;

const minSatisfying = (versions, range$1, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new range(range$1, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new semver(min, options);
      }
    }
  });
  return min
};
var minSatisfying_1 = minSatisfying;

const minVersion = (range$1, loose) => {
  range$1 = new range(range$1, loose);

  let minver = new semver('0.0.0');
  if (range$1.test(minver)) {
    return minver
  }

  minver = new semver('0.0.0-0');
  if (range$1.test(minver)) {
    return minver
  }

  minver = null;
  for (let i = 0; i < range$1.set.length; ++i) {
    const comparators = range$1.set[i];

    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new semver(comparator.semver.version);
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt_1(minver, compver)) {
            minver = compver;
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    });
  }

  if (minver && range$1.test(minver)) {
    return minver
  }

  return null
};
var minVersion_1 = minVersion;

const validRange = (range$1, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new range(range$1, options).range || '*'
  } catch (er) {
    return null
  }
};
var valid$1 = validRange;

const {ANY: ANY$1} = comparator;







const outside = (version, range$1, hilo, options) => {
  version = new semver(version, options);
  range$1 = new range(range$1, options);

  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt_1;
      ltefn = lte_1;
      ltfn = lt_1;
      comp = '>';
      ecomp = '>=';
      break
    case '<':
      gtfn = lt_1;
      ltefn = gte_1;
      ltfn = gt_1;
      comp = '<';
      ecomp = '<=';
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies_1(version, range$1, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range$1.set.length; ++i) {
    const comparators = range$1.set[i];

    let high = null;
    let low = null;

    comparators.forEach((comparator$1) => {
      if (comparator$1.semver === ANY$1) {
        comparator$1 = new comparator('>=0.0.0');
      }
      high = high || comparator$1;
      low = low || comparator$1;
      if (gtfn(comparator$1.semver, high.semver, options)) {
        high = comparator$1;
      } else if (ltfn(comparator$1.semver, low.semver, options)) {
        low = comparator$1;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
};

var outside_1 = outside;

// Determine if version is greater than all the versions possible in the range.

const gtr = (version, range, options) => outside_1(version, range, '>', options);
var gtr_1 = gtr;

// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside_1(version, range, '<', options);
var ltr_1 = ltr;

const intersects = (r1, r2, options) => {
  r1 = new range(r1, options);
  r2 = new range(r2, options);
  return r1.intersects(r2)
};
var intersects_1 = intersects;

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.


var simplify = (versions, range, options) => {
  const set = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare_1(a, b, options));
  for (const version of v) {
    const included = satisfies_1(version, range, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set.push([min, null]);

  const ranges = [];
  for (const [min, max] of set) {
    if (min === max)
      ranges.push(min);
    else if (!max && min === v[0])
      ranges.push('*');
    else if (!max)
      ranges.push(`>=${min}`);
    else if (min === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min} - ${max}`);
  }
  const simplified = ranges.join(' || ');
  const original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range
};

const { ANY: ANY$2 } = comparator;



// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else return false
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
// - If LT
//   - If LT.semver is greater than that of any > comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
// - If any C is a = range, and GT or LT are set, return false
// - Else return true

const subset = (sub, dom, options) => {
  sub = new range(sub, options);
  dom = new range(dom, options);
  let sawNonNull = false;

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
};

const simpleSubset = (sub, dom, options) => {
  if (sub.length === 1 && sub[0].semver === ANY$2)
    return dom.length === 1 && dom[0].semver === ANY$2

  const eqSet = new Set();
  let gt, lt;
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options);
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options);
    else
      eqSet.add(c.semver);
  }

  if (eqSet.size > 1)
    return null

  let gtltComp;
  if (gt && lt) {
    gtltComp = compare_1(gt.semver, lt.semver, options);
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies_1(eq, String(gt), options))
      return null

    if (lt && !satisfies_1(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies_1(eq, String(c), options))
        return false
    }
    return true
  }

  let higher, lower;
  let hasDomLT, hasDomGT;
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
    if (gt) {
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options);
        if (higher === c)
          return false
      } else if (gt.operator === '>=' && !satisfies_1(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options);
        if (lower === c)
          return false
      } else if (lt.operator === '<=' && !satisfies_1(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  return true
};

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare_1(a.semver, b.semver, options);
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
};

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare_1(a.semver, b.semver, options);
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
};

var subset_1 = subset;

// just pre-load all the stuff that index.js lazily exports

var semver$1 = {
  re: re_1.re,
  src: re_1.src,
  tokens: re_1.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1$1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: comparator,
  Range: range,
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid$1,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1,
};

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
var test$1 = {};

test$1[TO_STRING_TAG$1] = 'z';

var toStringTagSupport = String(test$1) === '[object z]';

var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof = toStringTagSupport ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
var objectToString$1 = toStringTagSupport ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (!toStringTagSupport) {
  redefine(Object.prototype, 'toString', objectToString$1, { unsafe: true });
}

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
var functionBind = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction$1(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.github.io/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED$3 = NEW_TARGET_BUG || ARGS_BUG;

_export({ target: 'Reflect', stat: true, forced: FORCED$3, sham: FORCED$3 }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction$1(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (functionBind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

var TO_STRING$1 = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING$1];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING$1;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING$1, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var ErrorArray = /*#__PURE__*/function (_Error) {
  _inherits(ErrorArray, _Error);

  var _super = _createSuper(ErrorArray);

  function ErrorArray() {
    var _this;

    _classCallCheck(this, ErrorArray);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.errors = void 0;
    return _this;
  }

  return ErrorArray;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
var DeserializationError = /*#__PURE__*/function (_ErrorArray) {
  _inherits(DeserializationError, _ErrorArray);

  var _super = _createSuper$1(DeserializationError);

  function DeserializationError() {
    var _this;

    _classCallCheck(this, DeserializationError);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.errors = void 0;
    return _this;
  }

  return DeserializationError;
}(ErrorArray);
var DeserializationErrorJsonSyntaxInvalid = /*#__PURE__*/function (_DeserializationError) {
  _inherits(DeserializationErrorJsonSyntaxInvalid, _DeserializationError);

  var _super2 = _createSuper$1(DeserializationErrorJsonSyntaxInvalid);

  function DeserializationErrorJsonSyntaxInvalid(syntaxErrorMessage) {
    var _this2;

    _classCallCheck(this, DeserializationErrorJsonSyntaxInvalid);

    var error = "invalid JSON syntax: '".concat(syntaxErrorMessage, "'");
    _this2 = _super2.call(this, "when deserializing: ".concat(error));
    _this2.errors = void 0;
    _this2.errors = [error];
    return _this2;
  }

  return DeserializationErrorJsonSyntaxInvalid;
}(DeserializationError);
var DeserializationErrorSchemaVersionMissing = /*#__PURE__*/function (_DeserializationError2) {
  _inherits(DeserializationErrorSchemaVersionMissing, _DeserializationError2);

  var _super3 = _createSuper$1(DeserializationErrorSchemaVersionMissing);

  function DeserializationErrorSchemaVersionMissing() {
    var _this3;

    _classCallCheck(this, DeserializationErrorSchemaVersionMissing);

    var error = "`schemaVer` is missing";
    _this3 = _super3.call(this, "when deserializing: ".concat(error));
    _this3.errors = void 0;
    _this3.errors = [error];
    return _this3;
  }

  return DeserializationErrorSchemaVersionMissing;
}(DeserializationError);
var DeserializationErrorSchemaVersionInvalid = /*#__PURE__*/function (_DeserializationError3) {
  _inherits(DeserializationErrorSchemaVersionInvalid, _DeserializationError3);

  var _super4 = _createSuper$1(DeserializationErrorSchemaVersionInvalid);

  function DeserializationErrorSchemaVersionInvalid(schemaVer, schemaVersions) {
    var _this4;

    _classCallCheck(this, DeserializationErrorSchemaVersionInvalid);

    var error = "expected `schemaVer` to be one of `[".concat(schemaVersions === null || schemaVersions === void 0 ? void 0 : schemaVersions.join(', '), "]`, but received: ").concat(schemaVer);
    _this4 = _super4.call(this, "when deserializing: ".concat(error));
    _this4.schemaVer = void 0;
    _this4.errors = void 0;
    _this4.schemaVer = schemaVer;
    _this4.errors = [error];
    return _this4;
  }

  return DeserializationErrorSchemaVersionInvalid;
}(DeserializationError);
var DeserializationErrorValidationFailed = /*#__PURE__*/function (_DeserializationError4) {
  _inherits(DeserializationErrorValidationFailed, _DeserializationError4);

  var _super5 = _createSuper$1(DeserializationErrorValidationFailed);

  function DeserializationErrorValidationFailed(errors) {
    var _this5;

    _classCallCheck(this, DeserializationErrorValidationFailed);

    _this5 = _super5.call(this, "when deserializing: validation failed:\n".concat(errors.map(appendDash).join('\n')));
    _this5.errors = void 0;
    _this5.errors = errors;
    return _this5;
  }

  return DeserializationErrorValidationFailed;
}(DeserializationError);
var DeserializationErrorConversionFailed = /*#__PURE__*/function (_DeserializationError5) {
  _inherits(DeserializationErrorConversionFailed, _DeserializationError5);

  var _super6 = _createSuper$1(DeserializationErrorConversionFailed);

  function DeserializationErrorConversionFailed(conversionError) {
    var _this6;

    _classCallCheck(this, DeserializationErrorConversionFailed);

    var error = "conversion failed";

    if (conversionError) {
      error = "".concat(error, ": ").concat(conversionError);
    }

    _this6 = _super6.call(this, "when deserializing: ".concat(error));
    _this6.errors = void 0;
    _this6.errors = [error];
    return _this6;
  }

  return DeserializationErrorConversionFailed;
}(DeserializationError);

// call something on iterator step with safe closing on error
var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

var iterators = {};

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype$1 = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod = function (it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR] === it);
};

var ITERATOR$1 = wellKnownSymbol('iterator');

var getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$1]
    || it['@@iterator']
    || iterators[classof(it)];
};

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};

var ITERATOR$2 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$2] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$2] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: arrayFrom
});

var correctPrototypeGetter = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

var IE_PROTO$1 = sharedKey('IE_PROTO');
var ObjectPrototype$1 = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype$1 : null;
};

var ITERATOR$3 = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ( !has(IteratorPrototype, ITERATOR$3)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR$3, returnThis);
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





var returnThis$1 = function () { return this; };

var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
  iterators[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$4 = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis$2 = function () { return this; };

var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$4]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
        } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ( IterablePrototype[ITERATOR$4] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
  }
  iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$1 = internalState.set;
var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState$1(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
iterators.Arguments = iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

var freezing = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});

var internalMetadata = createCommonjsModule(function (module) {
var defineProperty = objectDefineProperty.f;



var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;
});

var iterate_1 = createCommonjsModule(function (module) {
var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES
          ? boundFunction(anObject(step = iterable[index])[0], step[1])
          : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};
});

var anInstance = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};

var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  // eslint-disable-next-line max-len
  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    internalMetadata.REQUIRED = true;
  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  _export({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};

var redefineAll = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};

var SPECIES$3 = wellKnownSymbol('species');

var setSpecies = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
    defineProperty(Constructor, SPECIES$3, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

var defineProperty$6 = objectDefineProperty.f;








var fastKey = internalMetadata.fastKey;


var setInternalState$2 = internalState.set;
var internalStateGetterFor = internalState.getterFor;

var collectionStrong = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState$2(that, {
        type: CONSTRUCTOR_NAME,
        index: objectCreate(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!descriptors) that.size = 0;
      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (descriptors) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (descriptors) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (descriptors) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (descriptors) defineProperty$6(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$2(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};

// `Map` constructor
// https://tc39.github.io/ecma262/#sec-map-objects
var es_map = collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod$6 = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$6(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$6(true)
};

var charAt = stringMultibyte.charAt;



var STRING_ITERATOR = 'String Iterator';
var setInternalState$3 = internalState.set;
var getInternalState$2 = internalState.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});

var ITERATOR$5 = wellKnownSymbol('iterator');
var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
var ArrayValues = es_array_iterator.values;

for (var COLLECTION_NAME$1 in domIterables) {
  var Collection$1 = global_1[COLLECTION_NAME$1];
  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
  if (CollectionPrototype$1) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype$1[ITERATOR$5] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$5, ArrayValues);
    } catch (error) {
      CollectionPrototype$1[ITERATOR$5] = ArrayValues;
    }
    if (!CollectionPrototype$1[TO_STRING_TAG$3]) {
      createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$3, COLLECTION_NAME$1);
    }
    if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
      }
    }
  }
}

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

var last_1 = last;

function getOrThrow(map, key) {
  var value = map.get(key);

  if (!value) {
    throw new Error("Value under key `".concat(key, "` was expected, but not found in the Map"));
  }

  return value;
}

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

var UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

var BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

var regexpStickyHelpers = {
	UNSUPPORTED_Y: UNSUPPORTED_Y,
	BROKEN_CARET: BROKEN_CARET
};

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y$1 && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var regexpExec = patchedExec;

_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
  exec: regexpExec
});

// TODO: Remove from `core-js@4` since it's moved to entry points







var SPECIES$4 = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES$4] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
var isRegexp = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
};

var SPECIES$5 = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
var speciesConstructor = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$5]) == undefined ? defaultConstructor : aFunction$1(S);
};

var charAt$1 = stringMultibyte.charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
var advanceStringIndex = function (S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
};

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
var regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classofRaw(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

var arrayPush$1 = [].push;
var min$2 = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegexp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush$1.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min$2(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

var _baseSlice = baseSlice;

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : _baseSlice(array, start, end);
}

var _castSlice = castSlice;

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

var _baseFindIndex = baseFindIndex;

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

var _baseIsNaN = baseIsNaN;

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

var _strictIndexOf = strictIndexOf;

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? _strictIndexOf(array, value, fromIndex)
    : _baseFindIndex(array, _baseIsNaN, fromIndex);
}

var _baseIndexOf = baseIndexOf;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && _baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

var _charsEndIndex = charsEndIndex;

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && _baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

var _charsStartIndex = charsStartIndex;

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

var _asciiToArray = asciiToArray;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

var _hasUnicode = hasUnicode;

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff',
    rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
    rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo = '[' + rsComboRange$1 + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange$1 + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange$1 + ']?',
    rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

var _unicodeToArray = unicodeToArray;

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return _hasUnicode(string)
    ? _unicodeToArray(string)
    : _asciiToArray(string);
}

var _stringToArray = stringToArray;

/** Used to match leading and trailing whitespace. */
var reTrim$1 = /^\s+|\s+$/g;

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim$1(string, chars, guard) {
  string = toString_1(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrim$1, '');
  }
  if (!string || !(chars = _baseToString(chars))) {
    return string;
  }
  var strSymbols = _stringToArray(string),
      chrSymbols = _stringToArray(chars),
      start = _charsStartIndex(strSymbols, chrSymbols),
      end = _charsEndIndex(strSymbols, chrSymbols) + 1;

  return _castSlice(strSymbols, start, end).join('');
}

var trim_1 = trim$1;

var uri_all = createCommonjsModule(function (module, exports) {
/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 factory(exports) ;
}(commonjsGlobal, (function (exports) {
function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        DIGIT$$ = "[0-9]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) ;
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ( "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

});

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
var ucs2length = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

var util = {
  copy: copy$3,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: fastDeepEqual,
  ucs2length: ucs2length,
  varOccurences: varOccurences,
  varReplace: varReplace,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy$3(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, strictNumbers, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data +
                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
    case 'number': return '(typeof ' + data + EQUAL + '"' + dataType + '"' +
                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data, strictNumbers) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

var schema_obj = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

var jsonSchemaTraverse = createCommonjsModule(function (module) {

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
});

var resolve_1 = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof schema_obj) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof schema_obj) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = uri_all.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof schema_obj) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof schema_obj) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = uri_all.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return uri_all.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return uri_all.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  jsonSchemaTraverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? uri_all.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!fastDeepEqual(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !fastDeepEqual(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}

var error_classes = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve_1.url(baseId, ref);
  this.missingSchema = resolve_1.normalizeId(resolve_1.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

var fastJsonStableStringify = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

var validate = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
};

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length$1 = util.ucs2length;


// this error is thrown by async schemas to return validation errors via exception
var ValidationError$1 = error_classes.Validation;

var compile_1 = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validate({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: error_classes.MissingRef,
      RULES: RULES,
      validate: validate,
      util: util,
      resolve: resolve_1,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate$1;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate$1 = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        fastDeepEqual,
        ucs2length$1,
        ValidationError$1
      );

      refVal[0] = validate$1;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate$1.schema = _schema;
    validate$1.errors = null;
    validate$1.refs = refs;
    validate$1.refVal = refVal;
    validate$1.root = isRoot ? validate$1 : _root;
    if ($async) validate$1.$async = true;
    if (opts.sourceCode === true) {
      validate$1.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate$1;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve_1.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve_1.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve_1.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = fastJsonStableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}

var cache$1 = createCommonjsModule(function (module) {


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};
});

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER$1 = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER$1 = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


var formats_1 = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER$1,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER$1
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER$1,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER$1
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}

var ref = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
};

var allOf = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  return out;
};

var anyOf = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

var comment = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
};

var _const = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var contains = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

var dependencies = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    if ($property == '__proto__') continue;
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var _enum = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var format = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _if = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

var items = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var _limit = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
    throw new Error($keyword + ' must be number');
  }
  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
    throw new Error($exclusiveKeyword + ' must be number or boolean');
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var not = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
};

var oneOf = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

var pattern = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var properties = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties).filter(notProto),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }

  function notProto(p) {
    return p !== '__proto__';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var required = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
};

var uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

//all requires must be explicit because browserify won't work with dynamic requires
var dotjs = {
  '$ref': ref,
  allOf: allOf,
  anyOf: anyOf,
  '$comment': comment,
  const: _const,
  contains: contains,
  dependencies: dependencies,
  'enum': _enum,
  format: format,
  'if': _if,
  items: items,
  maximum: _limit,
  minimum: _limit,
  maxItems: _limitItems,
  minItems: _limitItems,
  maxLength: _limitLength,
  minLength: _limitLength,
  maxProperties: _limitProperties,
  minProperties: _limitProperties,
  multipleOf: multipleOf,
  not: not,
  oneOf: oneOf,
  pattern: pattern,
  properties: properties,
  propertyNames: propertyNames,
  required: required,
  uniqueItems: uniqueItems,
  validate: validate
};

var toHash$1 = util.toHash;

var rules = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash$1(ALL);
  RULES.types = toHash$1(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: dotjs[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: dotjs.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash$1(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

var data$1 = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};

var MissingRefError$1 = error_classes.MissingRef;

var async = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError$1) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

var custom = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
};

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties$1 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$2 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties$1,
	"default": true
};

var definition_schema = {
  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: require$$2.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: require$$2.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};

var IDENTIFIER$1 = /^[a-z_$][a-z0-9_$-]*$/i;



var keyword = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER$1.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: custom,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definition_schema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON Schema extension proposal)";
var type$1 = "object";
var required$1 = [
	"$data"
];
var properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties = false;
var require$$1 = {
	$schema: $schema$1,
	$id: $id$1,
	description: description,
	type: type$1,
	required: required$1,
	properties: properties$2,
	additionalProperties: additionalProperties
};

var ajv = Ajv;

Ajv.prototype.validate = validate$1;
Ajv.prototype.compile = compile$1;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = async;

Ajv.prototype.addKeyword = keyword.add;
Ajv.prototype.getKeyword = keyword.get;
Ajv.prototype.removeKeyword = keyword.remove;
Ajv.prototype.validateKeyword = keyword.validate;


Ajv.ValidationError = error_classes.Validation;
Ajv.MissingRefError = error_classes.MissingRef;
Ajv.$dataMetaSchema = data$1;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats_1(opts.format);

  this._cache = opts.cache || new cache$1;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = fastJsonStableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate$1(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile$1(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve_1.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve_1.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compile_1.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new schema_obj({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve_1.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve_1.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve_1.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve_1.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve_1.ids.call(this, schema);

  var schemaObj = new schema_obj({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compile_1.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = require$$1;
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = require$$2;
  if (self._opts.$data) metaSchema = data$1(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}

var en = function localize_en(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'can\\\'t resolve reference ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'should not have more than ' + (n) + ' item';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'additionalProperties':
        out = 'should not have additional properties';
        break;
      case 'anyOf':
        out = 'should match some schema in "anyOf"';
        break;
      case 'const':
        out = 'should be equal to constant';
        break;
      case 'contains':
        out = 'should contain a valid item';
        break;
      case 'custom':
        out = 'should pass "' + (e.keyword) + '" keyword validation';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'should have propert';
        if (n == 1) {
          out += 'y';
        } else {
          out += 'ies';
        }
        out += ' ' + (e.params.deps) + ' when property ' + (e.params.property) + ' is present';
        break;
      case 'enum':
        out = 'should be equal to one of predefined values';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'false schema':
        out = 'boolean schema is false';
        break;
      case 'format':
        out = 'should match format "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum should be boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum should be boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'should not have more than ' + (n) + ' item';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'should not be longer than ' + (n) + ' character';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'should not have more than ' + (n) + ' propert';
        if (n == 1) {
          out += 'y';
        } else {
          out += 'ies';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'should not have less than ' + (n) + ' item';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'should not be shorter than ' + (n) + ' character';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'should not have less than ' + (n) + ' propert';
        if (n == 1) {
          out += 'y';
        } else {
          out += 'ies';
        }
        break;
      case 'multipleOf':
        out = 'should be a multiple of ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'should not be valid according to schema in "not"';
        break;
      case 'oneOf':
        out = 'should match exactly one schema in "oneOf"';
        break;
      case 'pattern':
        out = 'should match pattern "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'should have property matching pattern "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'property name \'' + (e.params.propertyName) + '\' is invalid';
        break;
      case 'required':
        out = 'should have required property ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'should pass "switch" keyword validation, case ' + (e.params.caseIndex) + ' fails';
        break;
      case 'type':
        out = 'should be ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'should not have duplicate items (items ## ' + (e.params.j) + ' and ' + (e.params.i) + ' are identical)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var ar = function localize_ar(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'ÙØ§ ÙÙÙÙ Ø§ÙØ¹Ø«ÙØ± Ø¹ÙÙ Ø§ÙÙØ±Ø¬Ø¹ ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø£ÙØ«Ø± ÙÙ ' + (n) + ' Ø¹ÙØµØ±';
        break;
      case 'additionalProperties':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø®ØµØ§Ø¦Øµ Ø¥Ø¶Ø§ÙÙØ©';
        break;
      case 'anyOf':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙÙØ§ÙÙ Ø£Ø­Ø¯ Ø§ÙÙØ®Ø·Ø·Ø§Øª Ø§ÙÙÙØ¬ÙØ¯Ø© ÙÙ "anyOf"';
        break;
      case 'const':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ Ø«Ø§Ø¨ØªØ§Ù';
        break;
      case 'contains':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙØ­ÙÙ Ø¹ÙØµØ±Ø§ ØµØ­ÙØ­';
        break;
      case 'custom':
        out = 'ÙØ¬Ø¨ Ø£Ù ØªÙØ±Ø± ÙÙÙØ© Ø§ÙØªØ­ÙÙ Ø§ÙÙÙØªØ§Ø­ÙØ© "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ­ÙÙ Ø§ÙØ®ØµØ§Ø¦Øµ ' + (e.params.deps) + ' Ø¹ÙØ¯ÙØ§ ØªÙÙÙ Ø§ÙØ®Ø§ØµÙØ© ' + (e.params.property) + ' ÙÙØ¬ÙØ¯Ø©';
        break;
      case 'enum':
        out = 'ÙÙÙØ© ÙØ°Ø§ Ø§ÙØ­ÙÙ ÙØ¬Ø¨ Ø£Ù ØªÙÙÙ ÙØ³Ø§ÙÙØ© ÙØ£Ø­Ø¯ Ø§ÙÙÙÙ Ø§ÙÙØ¹Ø±ÙØ© ÙØ³Ø¨ÙØ§Ù';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ' + (cond);
        break;
      case 'false schema':
        out = 'Ø§ÙÙØ®Ø·Ø· Ø§ÙÙÙØ·ÙÙ ØºÙØ± ØµØ­ÙØ­';
        break;
      case 'format':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙÙØ§ÙÙ Ø§ÙØµÙØºØ© "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ÙÙØ·ÙÙØ§Ù';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ÙÙØ·ÙÙØ§Ù';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ' + (cond);
        break;
      case 'if':
        out = 'ÙØ¬Ø¨ Ø£Ù ØªÙØ§ÙÙ Ø§ÙÙØ®Ø·Ø· "' + (e.params.failingKeyword) + '"';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø£ÙØ«Ø± ÙÙ ' + (n) + ' Ø¹ÙØµØ±';
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø£ÙØ«Ø± ÙÙ ' + (n) + ' ÙØ­Ø±Ù';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø£ÙØ«Ø± ÙÙ ' + (n) + ' Ø®ØµØ§Ø¦Øµ';
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø£ÙÙ ÙÙ ' + (n) + ' Ø¹ÙØµØ±';
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø£ÙÙ ÙÙ ' + (n) + ' ÙØ­Ø±Ù';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += ' ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø£ÙÙ ÙÙ ' + (n) + ' Ø®ØµØ§Ø¦Øµ';
        break;
      case 'multipleOf':
        out = ' ÙØ¬Ø¨ Ø£Ù ÙØ­ÙÙ Ø£ÙØ«Ø± ÙÙ ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙÙÙÙ ØºÙØ± ØµØ­ÙØ­ ÙÙÙØ§Ù ÙÙÙØ®Ø·Ø· "not"';
        break;
      case 'oneOf':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙÙØ§ÙÙ ÙØ®Ø·Ø· ÙØ§Ø­Ø¯ ÙÙØ· ÙÙØ¬ÙØ¯ ÙÙ "oneOf"';
        break;
      case 'pattern':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙÙØ§ÙÙ Ø§ÙÙÙØ· "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙØ­ÙÙ Ø®Ø§ØµÙØ© ØªÙØ§ÙÙ Ø§ÙÙÙØ· "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'Ø§Ø³Ù Ø§ÙØ®Ø§ØµÙØ© \'' + (e.params.propertyName) + '\' ØºÙØ± ØµØ§ÙØ­';
        break;
      case 'required':
        out = 'ÙØ°Ø§ Ø§ÙØ­ÙÙ Ø¥ÙØ²Ø§ÙÙ';
        break;
      case 'switch':
        out = 'ÙØ¬Ø¨ Ø£Ù ØªÙØ±Ø± ÙÙÙØ© Ø§ÙØªØ­ÙÙ Ø§ÙÙÙØªØ§Ø­ÙØ© "switch"Ø Ø§ÙØ­Ø§ÙØ© ' + (e.params.caseIndex) + '  Ø®Ø§Ø·Ø¦Ø©';
        break;
      case 'type':
        out = 'ÙÙÙØ© ÙØ°Ø§ Ø§ÙØ­ÙÙ ØºÙØ± ØµØ§ÙØ­Ø©';
        break;
      case 'uniqueItems':
        out = 'ÙØ¬Ø¨ Ø£Ù ÙØ§ ÙØ­ÙÙ Ø¹ÙØ§ØµØ± ÙÙØ±Ø±Ø© (Ø§ÙØ¹ÙØµØ± ## ' + (e.params.j) + ' Ù ' + (e.params.i) + ' ÙØªØ·Ø§Ø¨ÙØ©)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var cz = function localize_cz(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'reference ' + (e.params.ref) + ' nenalezena';
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'nemÅ¯Å¾e mÃ­t vÃ­c, neÅ¾ ' + (n) + ' prv';
        if (n == 1) {
          out += 'ek';
        } else {
          out += 'kÅ¯';
        }
        break;
      case 'additionalProperties':
        out = 'nemÅ¯Å¾e mÃ­t dalÅ¡Ã­ poloÅ¾ky';
        break;
      case 'anyOf':
        out = 'musÃ­ vyhovÄt alespoÅ jednomu schÃ©matu v "anyOf"';
        break;
      case 'const':
        out = 'musÃ­ bÃ½t konstantnÃ­';
        break;
      case 'contains':
        out = 'musÃ­ obsahovat prvek odpovÃ­dajÃ­cÃ­ schÃ©matu';
        break;
      case 'custom':
        out = 'musÃ­ vyhovÄt "' + (e.keyword) + '" validaci';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += ' musÃ­ mÃ­t poloÅ¾';
        if (n >= 2 && n <= 4) {
          out += 'ky';
        } else if (n != 1) {
          out += 'ek';
        } else {
          out += 'ka';
        }
        out += ': ' + (e.params.deps) + ', pokud obsahuje ' + (e.params.property);
        break;
      case 'enum':
        out = 'musÃ­ bÃ½t rovna jednÃ© hodnotÄ z vÃ½Ätu';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ bÃ½t ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ bÃ½t ' + (cond);
        break;
      case 'false schema':
        out = 'schÃ©ma je false';
        break;
      case 'format':
        out = 'musÃ­ bÃ½t ve formÃ¡tu "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum musÃ­ bÃ½t boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum musÃ­ bÃ½t boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ bÃ½t ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ bÃ½t ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ bÃ½t ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'nesmÃ­ obsahovat vÃ­c neÅ¾ ' + (n) + ' prv';
        if (n == 1) {
          out += 'ek';
        } else {
          out += 'kÅ¯';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'nesmÃ­ bÃ½t delÅ¡Ã­ neÅ¾ ' + (n) + ' znak';
        if (n != 1) {
          out += 'Å¯';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'nesmÃ­ mÃ­t vÃ­c neÅ¾ ' + (n) + ' poloÅ¾';
        if (n >= 2 && n <= 4) {
          out += 'ky';
        } else if (n != 1) {
          out += 'ek';
        } else {
          out += 'ka';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ bÃ½t ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'nesmÃ­ obsahovat mÃ©nÄ neÅ¾ ' + (n) + ' prv';
        if (n == 1) {
          out += 'ek';
        } else {
          out += 'kÅ¯';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'nesmÃ­ bÃ½t kratÅ¡Ã­ neÅ¾ ' + (n) + ' znak';
        if (n != 1) {
          out += 'Å¯';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'nesmÃ­ mÃ­t mÃ©nÄ neÅ¾ ' + (n) + ' poloÅ¾';
        if (n >= 2 && n <= 4) {
          out += 'ky';
        } else if (n != 1) {
          out += 'ek';
        } else {
          out += 'ka';
        }
        break;
      case 'multipleOf':
        out = 'musÃ­ bÃ½t nÃ¡sobkem ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'nesmÃ­ vyhovÄt schÃ©matu v "not"';
        break;
      case 'oneOf':
        out = 'musÃ­ vyhovÄt prÃ¡vÄ jednomu schÃ©matu v "oneOf"';
        break;
      case 'pattern':
        out = 'musÃ­ vyhovÄt regulÃ¡rnÃ­mu vÃ½razu "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'musÃ­ obsahovat poloÅ¾ku vyhovujÃ­cÃ­ regulÃ¡rnÃ­mu vÃ½razu "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'nÃ¡zev poloÅ¾ky \'' + (e.params.propertyName) + '\' neodpovÃ­dÃ¡ schÃ©matu';
        break;
      case 'required':
        out = 'musÃ­ obsahovat poÅ¾adovanou poloÅ¾ku ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'musÃ­ projÃ­t validÃ¡cÃ­ "switch", pÅÃ­pad ' + (e.params.caseIndex) + ' je neÃºspÄÅ¡nÃ½';
        break;
      case 'type':
        out = 'musÃ­ bÃ½t ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'nesmÃ­ obsahovat duplicitnÃ­ prvky (prvky ## ' + (e.params.j) + ' a ' + (e.params.i) + ' jsou stejnÃ©)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var de = function localize_de(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'kann die Referenz ' + (e.params.ref) + ' nicht auflÃ¶sen';
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'darf nicht mehr als ' + (n) + ' Element';
        if (n != 1) {
          out += 'e';
        }
        out += ' enthalten';
        break;
      case 'additionalProperties':
        out = 'darf keine zusÃ¤tzlichen Attribute haben';
        break;
      case 'anyOf':
        out = 'muss einem der Schemata in "anyOf" entsprechen';
        break;
      case 'const':
        out = 'muss gleich der Konstanten sein';
        break;
      case 'contains':
        out = 'muss ein valides Element enthalten';
        break;
      case 'custom':
        out = 'muss die Validierung "' + (e.keyword) + '" bestehen';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'muss Attribut';
        if (n != 1) {
          out += 'e';
        }
        out += ' ' + (e.params.deps) + ' aufweisen, wenn Attribut ' + (e.params.property) + ' gesetzt ist';
        break;
      case 'enum':
        out = 'muss einem der vorgegebenen Werte entsprechen';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'muss ' + (cond) + ' sein';
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'muss ' + (cond) + ' sein';
        break;
      case 'false schema':
        out = 'boolesches Schema ist falsch';
        break;
      case 'format':
        out = 'muss diesem Format entsprechen: "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum muss ein boolescher Wert sein';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum muss ein boolescher Wert sein';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'muss ' + (cond) + ' sein';
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'muss ' + (cond) + ' sein';
        break;
      case 'if':
        out = 'muss dem Schema "' + (e.params.failingKeyword) + '" entsprechen';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'muss ' + (cond) + ' sein';
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'darf nicht mehr als ' + (n) + ' Element';
        if (n != 1) {
          out += 'e';
        }
        out += ' haben';
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'darf nicht lÃ¤nger als ' + (n) + ' Zeichen sein';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'darf nicht mehr als ' + (n) + ' Attribut';
        if (n != 1) {
          out += 'e';
        }
        out += ' haben';
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'muss ' + (cond) + ' sein';
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'darf nicht weniger als ' + (n) + ' Element';
        if (n != 1) {
          out += 'e';
        }
        out += ' haben';
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'darf nicht kÃ¼rzer als ' + (n) + ' Zeichen sein';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'darf nicht weniger als ' + (n) + ' Attribut';
        if (n != 1) {
          out += 'e';
        }
        out += ' haben';
        break;
      case 'multipleOf':
        out = 'muss ein Vielfaches von ' + (e.params.multipleOf) + ' sein';
        break;
      case 'not':
        out = 'muss dem in "not" angegebenen Schema widersprechen';
        break;
      case 'oneOf':
        out = 'muss genau einem der Schemata in "oneOf" entsprechen';
        break;
      case 'pattern':
        out = 'muss diesem Muster entsprechen: "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'muss ein Attribut nach folgendem Muster haben "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'Attributname \'' + (e.params.propertyName) + '\' ist ungÃ¼ltig';
        break;
      case 'required':
        out = 'muss das erforderliche Attribut ' + (e.params.missingProperty) + ' enthalten';
        break;
      case 'switch':
        out = 'muss der "switch"-Validierung entsprechen, der Fall ' + (e.params.caseIndex) + ' schlÃ¤gt fehl';
        break;
      case 'type':
        out = 'muss sein: ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'darf keine Duplikate enthalten (Elemente #' + (e.params.j) + ' und #' + (e.params.i) + ' sind gleich)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var es = function localize_es(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'no se puede resolver la referencia ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'no debe tener mÃ¡s de ' + (n) + ' elemento';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'additionalProperties':
        out = 'no debe tener propiedades adicionales';
        break;
      case 'anyOf':
        out = 'debe coincidir con algÃºn esquema en "anyOf"';
        break;
      case 'const':
        out = 'debe ser igual a la constante';
        break;
      case 'contains':
        out = 'should contain a valid item';
        break;
      case 'custom':
        out = 'debe pasar la validaciÃ³n de palabra clave "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'debe contener la';
        if (n != 1) {
          out += 's';
        }
        out += ' propiedad';
        if (n != 1) {
          out += 'es';
        }
        out += ' ' + (e.params.deps) + ' cuando la propiedad ' + (e.params.property) + ' se encuentra presente';
        break;
      case 'enum':
        out = 'deber ser igual a uno de los valores predefinidos';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'debe ser ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'debe ser ' + (cond);
        break;
      case 'false schema':
        out = 'boolean schema is false';
        break;
      case 'format':
        out = 'debe coincidir con el formato "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum debe ser booleano';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum debe ser booleano';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'debe ser ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'debe ser ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'debe ser ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'no debe contener mÃ¡s de ' + (n) + ' elemento';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'no debe contener mÃ¡s de ' + (n) + ' caracter';
        if (n != 1) {
          out += 'es';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'no debe contener mÃ¡s de ' + (n) + ' propiedad';
        if (n != 1) {
          out += 'es';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'debe ser ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'no debe contener menos de ' + (n) + ' elemento';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'no debe contener menos de ' + (n) + ' caracter';
        if (n != 1) {
          out += 'es';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'no debe contener menos de ' + (n) + ' propiedad';
        if (n != 1) {
          out += 'es';
        }
        break;
      case 'multipleOf':
        out = 'debe ser mÃºltiplo de ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'no debe ser vÃ¡lido segÃºn el esquema en "not"';
        break;
      case 'oneOf':
        out = 'debe coincidir con un solo esquema en "oneOf"';
        break;
      case 'pattern':
        out = 'debe coincidir con el patron "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'la propiedad debe coincidir con el patrÃ³n "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'property name \'' + (e.params.propertyName) + '\' is invalid';
        break;
      case 'required':
        out = 'debe tener la propiedad requerida ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'debe pasar la validaciÃ³n "switch" de palabra clave, el caso ' + (e.params.caseIndex) + ' fallÃ³';
        break;
      case 'type':
        out = 'debe ser ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'no debe contener elementos duplicados, (los elementos ## ' + (e.params.j) + ' y ' + (e.params.i) + ' son idÃ©nticos)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var fr = function localize_fr(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'impossible d\\\'accÃ©der Ã  la rÃ©fÃ©rÃ©nce ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'ne doit pas contenir plus de ' + (n) + ' Ã©lÃ©mÃ©nt';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'additionalProperties':
        out = 'ne doit pas contenir de propriÃ©tÃ©s additionnelles';
        break;
      case 'anyOf':
        out = 'doit correspondre Ã  un schÃ©ma de "anyOf"';
        break;
      case 'const':
        out = 'doit Ãªtre Ã©gal Ã  la constante';
        break;
      case 'contains':
        out = 'doit contenir un Ã©lÃ©ment valide';
        break;
      case 'custom':
        out = 'doit Ãªtre valide selon le critÃ¨re "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'doit avoir la propriÃ©tÃ© ' + (e.params.deps) + ' quand la propriÃ©tÃ© ' + (e.params.property) + ' est prÃ©sente';
        break;
      case 'enum':
        out = 'doit Ãªtre Ã©gal Ã  une des valeurs prÃ©dÃ©finies';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'doit Ãªtre ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'doit Ãªtre ' + (cond);
        break;
      case 'false schema':
        out = 'le schema est "false"';
        break;
      case 'format':
        out = 'doit correspondre au format "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum doit Ãªtre un boolÃ©en';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum doit Ãªtre un boolÃ©en';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'doit Ãªtre ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'doit Ãªtre ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'doit Ãªtre ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'ne doit pas contenir plus de ' + (n) + ' Ã©lÃ©ment';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'ne doit pas dÃ©passer ' + (n) + ' caractÃ¨re';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'ne doit pas contenir plus de ' + (n) + ' propriÃ©tÃ©';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'doit Ãªtre ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'ne doit pas contenir moins de ' + (n) + ' Ã©lÃ©ment';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'ne doit pas faire moins de ' + (n) + ' caractÃ¨re';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'ne doit pas contenir moins de ' + (n) + ' propriÃ©tÃ©';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'multipleOf':
        out = 'doit Ãªtre un multiple de ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'est invalide selon le schÃ©ma "not"';
        break;
      case 'oneOf':
        out = 'doit correspondre Ã  exactement un schÃ©ma de "oneOf"';
        break;
      case 'pattern':
        out = 'doit correspondre au format "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'la propriÃ©tÃ© doit correspondre au format "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'le nom de propriÃ©tÃ© \'' + (e.params.propertyName) + '\' est invalide';
        break;
      case 'required':
        out = 'requiert la propriÃ©tÃ© ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'doit Ãªtre valide selon le critÃ¨re "switch":validation par mot-clÃ©, le cas ' + (e.params.caseIndex) + ' est invalide';
        break;
      case 'type':
        out = 'doit Ãªtre de type ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'ne doit pas contenir de doublons (les Ã©lÃ©ments ## ' + (e.params.j) + ' et ' + (e.params.i) + ' sont identiques)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var hu = function localize_hu(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'nem sikerÃ¼lt feloldani a hivatkozÃ¡st ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'nem lehet tÃ¶bb, mint ' + (n) + ' eleme';
        break;
      case 'additionalProperties':
        out = 'nem lehetnek tovÃ¡bbi elemei';
        break;
      case 'anyOf':
        out = 'meg kell feleljen legalÃ¡bb egy "anyOf" alaknak';
        break;
      case 'const':
        out = 'should be equal to constant';
        break;
      case 'contains':
        out = 'should contain a valid item';
        break;
      case 'custom':
        out = 'should pass "' + (e.keyword) + '" keyword validation';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += '-nak kell legyen';
        if (n > 1) {
          out += 'ek';
        }
        out += ' a kÃ¶vetkezÅ tulajdonsÃ¡ga';
        if (n != 1) {
          out += 'i';
        }
        out += ': ' + (e.params.deps) + ', ha van ' + (e.params.property) + ' tulajdonsÃ¡ga';
        break;
      case 'enum':
        out = 'egyenlÅ kell legyen valamely elÅre meghatÃ¡rozott Ã©rtÃ©kkel';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'kell legyen ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'kell legyen ' + (cond);
        break;
      case 'false schema':
        out = 'boolean schema is false';
        break;
      case 'format':
        out = 'meg kell feleljen a kÃ¶vetkezÅ formÃ¡tumnak: "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum should be boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum should be boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'kell legyen ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'nem lehet tÃ¶bb, mint ' + (n) + ' eleme';
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'nem lehet hosszabb, mint ' + (n) + ' szimbÃ³lum';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'nem lehet tÃ¶bb, mint ' + (n) + ' tulajdonsÃ¡ga';
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'kell legyen ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'nem lehet kevesebb, mint ' + (n) + ' eleme';
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'nem lehet rÃ¶videbb, mint ' + (n) + ' szimbÃ³lum';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'nem lehet kevesebb, mint ' + (n) + ' tulajdonsÃ¡ga';
        break;
      case 'multipleOf':
        out = 'a tÃ¶bbszÃ¶rÃ¶se kell legyen a kÃ¶vetkezÅ szÃ¡mnak: ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'nem lehet Ã©rvÃ©nyes a "not" alaknak megfelelÅen';
        break;
      case 'oneOf':
        out = 'meg kell feleljen pontosan egy "anyOf" alaknak';
        break;
      case 'pattern':
        out = 'meg kell feleljen a kÃ¶vetkezÅ mintÃ¡nak: "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'should have property matching pattern "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'property name \'' + (e.params.propertyName) + '\' is invalid';
        break;
      case 'required':
        out = 'kell legyen ' + (e.params.missingProperty) + ' tulajdonsÃ¡ga';
        break;
      case 'switch':
        out = 'should pass "switch" keyword validation, case ' + (e.params.caseIndex) + ' fails';
        break;
      case 'type':
        out = '' + (e.params.type) + ' kell legyen';
        break;
      case 'uniqueItems':
        out = 'nem lehetnek azonos elemei (' + (e.params.j) + ' Ã©s ' + (e.params.i) + ' elemek azonosak)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var it = function localize_it(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'non Ã¨ possibile risolvere il riferimento ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'non dovrebbe avere piÃ¹ di ' + (n) + ' element';
        if (n == 1) {
          out += 'o';
        } else {
          out += 'i';
        }
        break;
      case 'additionalProperties':
        out = 'non deve avere attributi aggiuntivi';
        break;
      case 'anyOf':
        out = 'deve corrispondere ad uno schema in "anyOf"';
        break;
      case 'const':
        out = 'deve essere uguale alla costante';
        break;
      case 'contains':
        out = 'deve contentere un elemento valido';
        break;
      case 'custom':
        out = 'deve essere valido secondo il criterio "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'dovrebbe avere ';
        if (n == 1) {
          out += 'l\'';
        } else {
          out += 'gli ';
        }
        out += 'attribut';
        if (n == 1) {
          out += 'o';
        } else {
          out += 'i';
        }
        out += ' ' + (e.params.deps) + ' quando l\'attributo ' + (e.params.property) + ' Ã¨ presente';
        break;
      case 'enum':
        out = 'dovrebbe essere uguale ad uno dei valori predefiniti';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve essere ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve essere ' + (cond);
        break;
      case 'false schema':
        out = 'lo schema booleano Ã¨ falso';
        break;
      case 'format':
        out = 'deve corrispondere al formato "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum deve essere booleano';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum deve essere booleano';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve essere ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve essere ' + (cond);
        break;
      case 'if':
        out = 'deve corrispondere allo schema "' + (e.params.failingKeyword) + '"';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve essere ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'non deve avere piÃ¹ di ' + (n) + ' element';
        if (n == 1) {
          out += 'o';
        } else {
          out += 'i';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'non deve essere piÃ¹ lungo di ' + (n) + ' caratter';
        if (n == 1) {
          out += 'e';
        } else {
          out += 'i';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'non deve avere piÃ¹ di ' + (n) + ' attribut';
        if (n == 1) {
          out += 'o';
        } else {
          out += 'i';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve essere ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'non deve avere meno di ' + (n) + ' element';
        if (n == 1) {
          out += 'o';
        } else {
          out += 'i';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'non deve essere meno lungo di ' + (n) + ' caratter';
        if (n == 1) {
          out += 'e';
        } else {
          out += 'i';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'non deve avere meno di ' + (n) + ' attribut';
        if (n == 1) {
          out += 'o';
        } else {
          out += 'i';
        }
        break;
      case 'multipleOf':
        out = 'deve essere un multiplo di ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'non deve essere valido in base allo schema di "non"';
        break;
      case 'oneOf':
        out = 'deve corrispondere esattamente ad uno schema in "oneOf"';
        break;
      case 'pattern':
        out = 'deve corrispondere al formato "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'deve avere un attributo che corrisponda al formato "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'il nome dell\'attritbuto \'' + (e.params.propertyName) + '\' non Ã¨ valido';
        break;
      case 'required':
        out = 'deve avere l\'attributo obbligatorio ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'deve passare la validazione del criterio "switch", il caso ' + (e.params.caseIndex) + ' fallisce';
        break;
      case 'type':
        out = 'deve essere di tipo ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'non deve avere duplicati (gli elementi ## ' + (e.params.j) + ' e ' + (e.params.i) + ' sono uguali)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var ja = function localize_ja(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = '' + (e.params.ref) + 'ã®ã¹ã­ã¼ããè¦ã¤ãããã¨ãã§ããªã';
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'ã¯' + (n) + 'ä»¥ä¸ãã£ã¦ã¯ãããªã';
        break;
      case 'additionalProperties':
        out = 'è¿½å ãã¦ã¯ãããªã';
        break;
      case 'anyOf':
        out = '"anyOf"ã®ã¹ã­ã¼ãã¨ãããããªãã¦ã¯ãããªã';
        break;
      case 'const':
        out = 'should be equal to constant';
        break;
      case 'contains':
        out = 'should contain a valid item';
        break;
      case 'custom':
        out = 'should pass "' + (e.keyword) + '" keyword validation';
        break;
      case 'dependencies':
        out = '' + (e.params.property) + 'ãããå ´åã';
        var n = e.params.depsCount;
        out += 'ã¯' + (e.params.deps) + 'ãã¤ããªããã°ãããªã';
        break;
      case 'enum':
        out = 'äºåã«å®ç¾©ãããå¤ã®ããããã«ç­ãããªããã°ãããªã';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += (cond) + 'ã§ãªããã°ãããªã';
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += (cond) + 'ã§ãªããã°ãããªã';
        break;
      case 'false schema':
        out = 'boolean schema is false';
        break;
      case 'format':
        out = '"' + (e.params.format) + '"å½¢å¼ã«æããªããã°ãããªã';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum should be boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum should be boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'should be ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += (cond) + 'ã§ãªããã°ãããªã';
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'ã¯' + (n) + 'åä»¥ä¸ã§ãã£ã¦ã¯ãããªã';
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'ã¯' + (n) + 'æå­ä»¥ä¸ã§ãã£ã¦ã¯ãããªã';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'ã¯' + (n) + 'åä»¥ä¸ã®ãã­ããã£ãæãã¦ã¯ãããªã';
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += (cond) + 'ã§ãªããã°ãããªã';
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'ã¯' + (n) + 'åä»¥ä¸ã§ãã£ã¦ã¯ãããªã';
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'ã¯' + (n) + 'æå­ä»¥ä¸ã§ãã£ã¦ã¯ãããªã';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'ã¯' + (n) + 'åä»¥ä¸ã®ãã­ããã£ãæãã¦ã¯ãããªã';
        break;
      case 'multipleOf':
        out = '' + (e.params.multipleOf) + 'ã®åæ°ã§ãªããã°ãããªã';
        break;
      case 'not':
        out = '"not"ã®ã¹ã­ã¼ãã«å¾ã£ã¦æå¹ã¨ãã¦ã¯ãããªã';
        break;
      case 'oneOf':
        out = '"oneOf"ã®ã¹ã­ã¼ãã¨å®å¨ã«ä¸è´ããªãã¦ã¯ãããªã';
        break;
      case 'pattern':
        out = '"' + (e.params.pattern) + '"ã®ãã¿ã¼ã³ã¨ä¸è´ããªããã°ãããªã';
        break;
      case 'patternRequired':
        out = 'should have property matching pattern "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'property name \'' + (e.params.propertyName) + '\' is invalid';
        break;
      case 'required':
        out = 'å¿è¦ãªãã­ããã£' + (e.params.missingProperty) + 'ããªããã°ãããªã';
        break;
      case 'switch':
        out = 'should pass "switch" keyword validation, case ' + (e.params.caseIndex) + ' fails';
        break;
      case 'type':
        out = '' + (e.params.type) + 'ã§ãªããã°ãããªã';
        break;
      case 'uniqueItems':
        out = 'éè¤ããã¢ã¤ãã ããã£ã¦ã¯ãããªãï¼' + (e.params.j) + 'ã¨' + (e.params.i) + 'ã¯åãã§ããï¼';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var nb = function localize_nb(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'kan ikke finne referansen ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'kan ikke ha mer enn ' + (n) + ' element';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'additionalProperties':
        out = 'kan ikke ha flere egenskaper';
        break;
      case 'anyOf':
        out = 'mÃ¥ samsvare med et schema i "anyOf"';
        break;
      case 'const':
        out = 'mÃ¥ vÃ¦re lik konstanten';
        break;
      case 'contains':
        out = 'mÃ¥ inneholde et gyldig element';
        break;
      case 'custom':
        out = 'mÃ¥ samsvare med valideringen for ' + (e.keyword);
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'mÃ¥ ha egenskapen';
        if (n != 1) {
          out += 'e';
        }
        out += ' ' + (e.params.deps) + ' nÃ¥r egenskapen ' + (e.params.property) + ' er angitt';
        break;
      case 'enum':
        out = 'mÃ¥ vÃ¦re lik en av de forhÃ¥ndsdefinerte verdiene';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'mÃ¥ vÃ¦re ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'mÃ¥ vÃ¦re ' + (cond);
        break;
      case 'false schema':
        out = 'boolsk schema er usannt';
        break;
      case 'format':
        out = 'mÃ¥ stemme overens med formatet "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum mÃ¥ vÃ¦re en boolsk verdi';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum mÃ¥ vÃ¦re en boolsk verdi';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'mÃ¥ vÃ¦re ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'mÃ¥ vÃ¦re ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'mÃ¥ vÃ¦re ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'kan ikke ha fler enn ' + (n) + ' element';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'kan ikke vÃ¦re lengre enn ' + (n) + ' tegn';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'kan ikke ha mer enn ' + (n) + ' egenskap';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'mÃ¥ vÃ¦re ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'kan ikke ha fÃ¦rre enn ' + (n) + ' element';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'kan ikke vÃ¦re kortere enn ' + (n) + ' tegn';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'kan ikke ha mindre enn ' + (n) + ' egenskap';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'multipleOf':
        out = 'mÃ¥ vÃ¦re et multiplum av ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'kan ikke samsvare med schema i "not"';
        break;
      case 'oneOf':
        out = 'mÃ¥ samsvare med nÃ¸yaktig ett schema i "oneOf"';
        break;
      case 'pattern':
        out = 'mÃ¥ samsvare med mÃ¸nsteret "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'mÃ¥ ha en egenskap som samsvarer med mÃ¸nsteret "' + (e.params.missingPattern);
        break;
      case 'propertyNames':
        out = 'egenskapen med navnet \'';
        e.params.propertyNameout += '\' er ugyldig';
        break;
      case 'required':
        out = 'mÃ¥ ha den pÃ¥krevde egenskapen ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'mÃ¥ passere "switch" validering, tilfellet ' + (e.params.caseIndex) + ' misslykkes';
        break;
      case 'type':
        out = '';
        var t = e.params.type;
        out += 'mÃ¥ vÃ¦re ';
        if (t == "number") {
          out += 'et tall';
        } else if (t == "integer") {
          out += 'et heltall';
        } else if (t == "string") {
          out += 'en streng';
        } else if (t == "boolean") {
          out += 'ja eller nei';
        } else {
          out += (t);
        }
        break;
      case 'uniqueItems':
        out = 'kan ikke ha duplikate elemeneter (elementene ## ' + (e.params.j) + ' og ' + (e.params.i) + ' er identiske)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var nl = function localize_nl(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'referentie ' + (e.params.ref) + ' niet gevonden';
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'mag niet meer dan ' + (n) + ' item';
        if (n != 1) {
          out += 's';
        }
        out += ' hebben';
        break;
      case 'additionalProperties':
        out = 'mag geen extra eigenschappen hebben';
        break;
      case 'anyOf':
        out = 'moet overeenkomen met een schema in "anyOf"';
        break;
      case 'const':
        out = 'moet gelijk zijn aan constante';
        break;
      case 'contains':
        out = 'moet een geldig item bevatten';
        break;
      case 'custom':
        out = 'moet sleutelwoord validatie "' + (e.keyword) + '" doorstaan';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'moet eigenschap';
        if (n != 1) {
          out += 'pen';
        }
        out += ' ' + (e.params.deps) + ' hebben als eigenschap ' + (e.params.property) + ' aanwezig is';
        break;
      case 'enum':
        out = 'moet gelijk zijn aan Ã©Ã©n van de voorgedefinieerde waardes';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'moet ' + (cond) + ' zijn';
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'moet ' + (cond) + ' zijn';
        break;
      case 'false schema':
        out = 'boolean schema is fout';
        break;
      case 'format':
        out = 'moet overeenkomen met dit formaat: "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum moet een boolean zijn';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum moet een boolean zijn';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'moet ' + (cond) + ' zijn';
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'moet ' + (cond) + ' zijn';
        break;
      case 'if':
        out = 'moet overeenkomen met "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'moet ' + (cond) + ' zijn';
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'mag niet meer dan ' + (n) + ' item';
        if (n != 1) {
          out += 's';
        }
        out += ' hebben';
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'mag niet langer dan ' + (n) + ' karakter';
        if (n != 1) {
          out += 's';
        }
        out += ' zijn';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'mag niet meer dan ' + (n) + ' eigenschap';
        if (n != 1) {
          out += 'pen';
        }
        out += ' hebben';
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'moet ' + (cond) + ' zijn';
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'mag niet minder dan ' + (n) + ' item';
        if (n != 1) {
          out += 's';
        }
        out += ' hebben';
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'mag niet korter dan ' + (n) + ' karakter';
        if (n != 1) {
          out += 's';
        }
        out += ' zijn';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'mag niet minder dan ' + (n) + ' eigenschap';
        if (n != 1) {
          out += 'pen';
        }
        out += ' hebben';
        break;
      case 'multipleOf':
        out = 'moet een veelvoud van ' + (e.params.multipleOf) + ' zijn';
        break;
      case 'not':
        out = 'mag niet overeenkomen met een schema in "not"';
        break;
      case 'oneOf':
        out = 'mag maar met Ã©Ã©n schema in "oneOf" overeenkomen';
        break;
      case 'pattern':
        out = 'moet aan dit patroon voldoen "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'moet een eigenschap hebben met het volgende patroon "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'eigenschapnaam \'' + (e.params.propertyName) + '\' is ongeldig';
        break;
      case 'required':
        out = 'moet de verplichte eigenschap ' + (e.params.missingProperty) + ' hebben';
        break;
      case 'switch':
        out = 'moet "switch" sleutelwoord validatie doorstaan, geval ' + (e.params.caseIndex) + ' gaat verkeerd';
        break;
      case 'type':
        out = '';
        var t = e.params.type;
        out += 'moet een ';
        if (t == "number") {
          out += 'nummer';
        } else if (t == "integer") {
          out += 'geheel getal';
        } else if (t == "string") {
          out += 'tekenreeks';
        } else if (t == "boolean") {
          out += 'ja of nee waarde';
        }
        out += ' (' + (t) + ') zijn';
        break;
      case 'uniqueItems':
        out = 'mag geen dubbele items bevatten (items ## ' + (e.params.j) + ' en ' + (e.params.i) + ' zijn gelijk)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var pl = function localize_pl(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'nie moÅ¼na znaleÅÄ schematu ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'nie powinien mieÄ wiÄcej niÅ¼ ' + (n) + ' element';
        if (n == 1) {
          out += 'u';
        } else {
          out += 'Ã³w';
        }
        break;
      case 'additionalProperties':
        out = 'nie powinien zawieraÄ dodatkowych pÃ³l';
        break;
      case 'anyOf':
        out = 'powinien pasowaÄ do wzoru z sekcji "anyOf"';
        break;
      case 'const':
        out = 'powinien byÄ rÃ³wny staÅej';
        break;
      case 'contains':
        out = 'should contain a valid item';
        break;
      case 'custom':
        out = 'powinien przejÅÄ walidacjÄ "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'powinien zawieraÄ pol';
        if (n == 1) {
          out += 'e';
        } else {
          out += 'a';
        }
        out += ' ' + (e.params.deps) + ' kiedy pole ' + (e.params.property) + ' jest obecne';
        break;
      case 'enum':
        out = 'powinien byÄ rÃ³wny jednej z predefiniowanych wartoÅci';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'powinien byÄ ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'powinien byÄ ' + (cond);
        break;
      case 'false schema':
        out = 'boolean schema is false';
        break;
      case 'format':
        out = 'powinien zgadzaÄ siÄ z formatem "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum powinien byÄ boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum powinieÅ byÄ boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'powinien byÄ ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'powinien byÄ ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'powinien byÄ ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'nie powinien mieÄ wiÄcej niÅ¼ ' + (n) + ' element';
        if (n == 1) {
          out += 'u';
        } else {
          out += 'Ã³w';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'nie powinien byÄ dÅuÅ¼szy niÅ¼ ' + (n) + ' znak';
        if (n != 1) {
          out += 'Ã³w';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'nie powinien zawieraÄ wiÄcej niÅ¼ ' + (n) + ' ';
        if (n == 1) {
          out += 'pole';
        } else {
          out += 'pÃ³l';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'powinien byÄ ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'nie powinien mieÄ mniej niÅ¼ ' + (n) + ' element';
        if (n == 1) {
          out += 'u';
        } else {
          out += 'Ã³w';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'nie powinien byÄ krÃ³tszy niÅ¼ ' + (n) + ' znak';
        if (n != 1) {
          out += 'Ã³w';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'nie powinien zawieraÄ mniej niÅ¼ ' + (n) + ' ';
        if (n == 1) {
          out += 'pole';
        } else {
          out += 'pÃ³l';
        }
        break;
      case 'multipleOf':
        out = 'powinien byÄ wielokrotnoÅciÄ ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'nie powinien pasowaÄ do wzoru z sekcji "not"';
        break;
      case 'oneOf':
        out = 'powinien pasowaÄ do jednego wzoru z sekcji "oneOf"';
        break;
      case 'pattern':
        out = 'powinien zgadzaÄ siÄ ze wzorem "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'powinien mieÄ pole pasujÄce do wzorca "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'property name \'' + (e.params.propertyName) + '\' is invalid';
        break;
      case 'required':
        out = 'powinien zawieraÄ wymagane pole ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'powinien przejÅÄ walidacje pola "switch", przypadek ' + (e.params.caseIndex) + ' zawiÃ³dÅ';
        break;
      case 'type':
        out = 'powinien byÄ ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'nie powinien zawieraÄ elementÃ³w ktÃ³re siÄ powtarzajÄ (elementy ' + (e.params.j) + ' i ' + (e.params.i) + ' sÄ identyczne)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var ptBR = function localize_pt_BR(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'NÃ£o Ã© possÃ­vel resolver a referÃªncia ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = 'NÃ£o sÃ£o permitidos itens adicionais';
        break;
      case 'additionalProperties':
        out = 'NÃ£o sÃ£o permitidas propriedades adicionais';
        break;
      case 'anyOf':
        out = 'Os dados nÃ£o correspondem a nenhum esquema de "anyOf"';
        break;
      case 'const':
        out = 'Deve ser igual Ã  constante';
        break;
      case 'contains':
        out = 'deve conter um item vÃ¡lido';
        break;
      case 'custom':
        out = 'deve passar a validaÃ§Ã£o de palavras-chave "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += ' deve ter propriedade';
        if (n != 1) {
          out += 's';
        }
        out += ' ' + (e.params.deps) + ' quando a propriedade ' + (e.params.property) + ' estiver presente';
        break;
      case 'enum':
        out = 'Deve ser igual a um dos valores predefinidos';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve ser ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve ser ' + (cond);
        break;
      case 'false schema':
        out = 'O schema booleano Ã© "false"';
        break;
      case 'format':
        out = 'A validaÃ§Ã£o do formato falhou "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum deve ser um booleano';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum deve ser um booleano';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve ser ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve ser ' + (cond);
        break;
      case 'if':
        out = 'Deve corresponder ao schema "' + (e.params.failingKeyword) + '"';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve ser ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'nÃ£o deve ter mais que ' + (n) + ' elemento';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'nÃ£o deve ter mais que ' + (n) + ' caracter';
        if (n != 1) {
          out += 'es';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'nÃ£o deve ter mais que ' + (n) + ' propriedade';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'deve ser ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'nÃ£o deve ter menos que ' + (n) + ' elemento';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'nÃ£o deve ter menos que ' + (n) + ' caracter';
        if (n != 1) {
          out += 'es';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'nÃ£o deve ter menos que ' + (n) + ' propriedade';
        if (n != 1) {
          out += 's';
        }
        break;
      case 'multipleOf':
        out = 'deve ser mÃºltiplo de ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'nÃ£o deve ser valido segundo o esquema em "not"';
        break;
      case 'oneOf':
        out = 'deve corresponder exatamente com um esquema em "oneOf"';
        break;
      case 'pattern':
        out = 'deve corresponder ao padrÃ£o "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'deve ter a propriedade de padrÃ£o de correspondÃªncia "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'O nome da propriedade \'' + (e.params.propertyName) + '\' Ã© invÃ¡lido';
        break;
      case 'required':
        out = 'deve ter a propriedade requerida ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'deve passar a validaÃ§Ã£o "switch" de palavra-chave, o caso ' + (e.params.caseIndex) + ' falha';
        break;
      case 'type':
        out = 'deve ser ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'nÃ£o deve ter itens duplicados (os itens ## ' + (e.params.j) + ' e ' + (e.params.i) + ' sÃ£o idÃªnticos)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var ru = function localize_ru(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð° ÑÑÐµÐ¼Ð° ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð½Ðµ Ð±Ð¾Ð»ÐµÐµ, ÑÐµÐ¼ ' + (n) + ' ÑÐ»ÐµÐ¼ÐµÐ½Ñ';
        if (n >= 2 && n <= 4) {
          out += 'Ð°';
        } else if (n != 1) {
          out += 'Ð¾Ð²';
        }
        break;
      case 'additionalProperties':
        out = 'Ð½Ðµ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐµ Ð¿Ð¾Ð»Ñ';
        break;
      case 'anyOf':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ Ð¾Ð´Ð½Ð¾Ð¹ Ð¸Ñ ÑÑÐµÐ¼ Ð² "anyOf"';
        break;
      case 'const':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ÑÐ°Ð²Ð½Ð¾ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð¼Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ';
        break;
      case 'contains':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐµÐµ ÑÑÐµÐ¼Ðµ';
        break;
      case 'custom':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ Ð¿ÑÐ°Ð²Ð¸Ð»Ñ "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð¿Ð¾Ð»';
        if (n == 1) {
          out += 'Ðµ';
        } else {
          out += 'Ñ';
        }
        out += ' ' + (e.params.deps) + ', ÐºÐ¾Ð³Ð´Ð° Ð¿ÑÐ¸ÑÑÑÑÑÐ²ÑÐµÑ Ð¿Ð¾Ð»Ðµ ' + (e.params.property);
        break;
      case 'enum':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ÑÐ°Ð²ÐµÐ½ Ð¾Ð´Ð½Ð¾Ð¼Ñ Ð¸Ð· Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹ Ð² "enum"';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ' + (cond);
        break;
      case 'false schema':
        out = 'ÑÑÐµÐ¼Ð° ÑÐ°Ð²Ð½Ð° false';
        break;
      case 'format':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ ÑÐ¾ÑÐ¼Ð°ÑÑ "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ' + (cond);
        break;
      case 'if':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ ÑÑÐµÐ¼e "' + (e.params.failingKeyword) + '"';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð½Ðµ Ð±Ð¾Ð»ÐµÐµ, ÑÐµÐ¼ ' + (n) + ' ÑÐ»ÐµÐ¼ÐµÐ½Ñ';
        if (n >= 2 && n <= 4) {
          out += 'Ð°';
        } else if (n != 1) {
          out += 'Ð¾Ð²';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð½Ðµ Ð´Ð»Ð¸Ð½Ð½ÐµÐµ, ÑÐµÐ¼ ' + (n) + ' ÑÐ¸Ð¼Ð²Ð¾Ð»';
        if (n >= 2 && n <= 4) {
          out += 'Ð°';
        } else if (n != 1) {
          out += 'Ð¾Ð²';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð½Ðµ Ð±Ð¾Ð»ÐµÐµ, ÑÐµÐ¼ ' + (n) + ' Ð¿Ð¾Ð»';
        if (n == 1) {
          out += 'Ðµ';
        } else if (n >= 2 && n <= 4) {
          out += 'Ñ';
        } else {
          out += 'ÐµÐ¹';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð½Ðµ Ð¼ÐµÐ½ÐµÐµ, ÑÐµÐ¼ ' + (n) + ' ÑÐ»ÐµÐ¼ÐµÐ½Ñ';
        if (n >= 2 && n <= 4) {
          out += 'Ð°';
        } else if (n != 1) {
          out += 'Ð¾Ð²';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð½Ðµ ÐºÐ¾ÑÐ¾ÑÐµ, ÑÐµÐ¼ ' + (n) + ' ÑÐ¸Ð¼Ð²Ð¾Ð»';
        if (n >= 2 && n <= 4) {
          out += 'Ð°';
        } else if (n != 1) {
          out += 'Ð¾Ð²';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð½Ðµ Ð¼ÐµÐ½ÐµÐµ, ÑÐµÐ¼ ' + (n) + ' Ð¿Ð¾Ð»';
        if (n == 1) {
          out += 'Ðµ';
        } else if (n >= 2 && n <= 4) {
          out += 'Ñ';
        } else {
          out += 'ÐµÐ¹';
        }
        break;
      case 'multipleOf':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ÐºÑÐ°ÑÐ½ÑÐ¼ ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð½Ðµ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ ÑÑÐµÐ¼Ðµ Ð² "not"';
        break;
      case 'oneOf':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ Ð² ÑÐ¾ÑÐ½Ð¾ÑÑÐ¸ Ð¾Ð´Ð½Ð¾Ð¹ ÑÑÐµÐ¼e Ð² "oneOf"';
        break;
      case 'pattern':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ Ð¾Ð±ÑÐ°Ð·ÑÑ "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð¿Ð¾Ð»Ðµ, ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐµÐµ Ð¾Ð±ÑÐ°Ð·ÑÑ "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'Ð¸Ð¼Ñ Ð¿Ð¾Ð»Ñ \'' + (e.params.propertyName) + '\' Ð½Ðµ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÐµÑ ÑÑÐµÐ¼Ðµ';
        break;
      case 'required':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð¾Ð±ÑÐ·Ð°ÑÐµÐ»ÑÐ½Ð¾Ðµ Ð¿Ð¾Ð»Ðµ ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¾Ð²Ð°ÑÑ Ð¿ÑÐ°Ð²Ð¸Ð»Ñ ' + (e.params.caseIndex) + ' Ð² "switch"';
        break;
      case 'type':
        out = 'Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'Ð½Ðµ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¸Ð¼ÐµÑÑ Ð¿Ð¾Ð²ÑÐ¾ÑÑÑÑÐ¸ÑÑÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ¾Ð² (ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ ' + (e.params.j) + ' Ð¸ ' + (e.params.i) + ' Ð¸Ð´ÐµÐ½ÑÐ¸ÑÐ½Ñ)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var sk = function localize_sk(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'referenciu ' + (e.params.ref) + ' sa nepodarilo nÃ¡jsÅ¥';
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'nemÃ´Å¾e obsahovaÅ¥ viac, neÅ¾ ' + (n) + ' prv';
        if (n == 1) {
          out += 'ok';
        } else {
          out += 'kov';
        }
        break;
      case 'additionalProperties':
        out = 'nemÃ´Å¾e obsahovaÅ¥ ÄalÅ¡ie poloÅ¾ky';
        break;
      case 'anyOf':
        out = 'musÃ­ splÅovaÅ¥ aspoÅ jednu zo schÃ©m v "anyOf"';
        break;
      case 'const':
        out = 'musÃ­ byÅ¥ konÅ¡tanta';
        break;
      case 'contains':
        out = 'musÃ­ obsahovaÅ¥ prvok zodpovedajÃºci schÃ©me';
        break;
      case 'custom':
        out = 'musÃ­ splniÅ¥ "' + (e.keyword) + '" validÃ¡ciu';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += ' musÃ­ obsahovaÅ¥ poloÅ¾';
        if (n >= 2 && n <= 4) {
          out += 'ky';
        } else if (n != 1) {
          out += 'iek';
        } else {
          out += 'ka';
        }
        out += ': ' + (e.params.deps) + ', ak obsahuje ' + (e.params.property);
        break;
      case 'enum':
        out = 'musÃ­ byÅ¥ jedna z definovanÃ½ch hodnÃ´t';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ byÅ¥ ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ byÅ¥ ' + (cond);
        break;
      case 'false schema':
        out = 'schÃ©ma je false';
        break;
      case 'format':
        out = 'musÃ­ obsahovaÅ¥ formÃ¡t "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum musÃ­ byÅ¥ boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum musÃ­ byÅ¥ boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ byÅ¥ ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ byÅ¥ ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ byÅ¥ ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'nesmie obsahovaÅ¥ viac neÅ¾ ' + (n) + ' prv';
        if (n == 1) {
          out += 'ok';
        } else {
          out += 'kov';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'nesmie byÅ¥ dlhÅ¡Ã­ neÅ¾ ' + (n) + ' znak';
        if (n != 1) {
          out += 'ov';
        }
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'nesmie obsahovaÅ¥ viac neÅ¾ ' + (n) + ' poloÅ¾';
        if (n >= 2 && n <= 4) {
          out += 'ky';
        } else if (n != 1) {
          out += 'iek';
        } else {
          out += 'ka';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'musÃ­ byÅ¥ ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'nesmie obsahovaÅ¥ menej neÅ¾ ' + (n) + ' prv';
        if (n == 1) {
          out += 'ok';
        } else {
          out += 'kov';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'nesmie byÅ¥ kratÅ¡Ã­ neÅ¾ ' + (n) + ' znak';
        if (n != 1) {
          out += 'ov';
        }
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'nesmie obsahovaÅ¥ menej neÅ¾ ' + (n) + ' poloÅ¾';
        if (n >= 2 && n <= 4) {
          out += 'ky';
        } else if (n != 1) {
          out += 'iek';
        } else {
          out += 'ka';
        }
        break;
      case 'multipleOf':
        out = 'musÃ­ byÅ¥ nÃ¡sobkom ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'nesmie splÅovaÅ¥ schÃ©mu v "not"';
        break;
      case 'oneOf':
        out = 'musÃ­ splÅovaÅ¥ prÃ¡ve jednu schÃ©mu v "oneOf"';
        break;
      case 'pattern':
        out = 'musÃ­ splÅovaÅ¥ regulÃ¡rny vÃ½raz "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'musÃ­ obsahovaÅ¥ poloÅ¾ku splÅjÃºcu regulÃ¡rny vÃ½raz "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'nÃ¡zov poloÅ¾ky \'' + (e.params.propertyName) + '\' nezodpovedÃ¡ schÃ©me';
        break;
      case 'required':
        out = 'musÃ­ obsahovaÅ¥ poÅ¾adovanÃº poloÅ¾ku ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'musÃ­ prejsÅ¥ validÃ¡ciou "switch", prÃ­pad ' + (e.params.caseIndex) + ' je neÃºspeÅ¡nÃ½';
        break;
      case 'type':
        out = 'musÃ­ byÅ¥ ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'nesmie obsahovaÅ¥ duplicitnÃ© prvky (prvky ## ' + (e.params.j) + ' a ' + (e.params.i) + ' sÃº rovnakÃ©)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var sv = function localize_sv(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'kan inte lÃ¶sa referens ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'borde ha fler Ã¤n ' + (n) + ' sak';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'additionalProperties':
        out = 'borde inte ha fler egenskaper';
        break;
      case 'anyOf':
        out = 'borde matcha nÃ¥got schema i "anyOf"';
        break;
      case 'const':
        out = 'bÃ¶r vara en konstant';
        break;
      case 'contains':
        out = 'bÃ¶r innehÃ¥lla ett giltigt objekt';
        break;
      case 'custom':
        out = 'bÃ¶r passera "' + (e.keyword) + '" nyckelord validering';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'borde ha egenskap';
        if (n != 1) {
          out += 'er';
        }
        out += ' ' + (e.params.deps) + ' nÃ¤r egenskap ' + (e.params.property) + ' finns tillgÃ¤ngligt';
        break;
      case 'enum':
        out = 'borde vara ekvivalent med en av dess fÃ¶rdefinierade vÃ¤rden';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'borde vara ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'borde vara ' + (cond);
        break;
      case 'false schema':
        out = 'boolean schema Ã¤r falskt';
        break;
      case 'format':
        out = 'borde matcha formatet "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum bÃ¶r vara en boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMaximum bÃ¶r vara en boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'bÃ¶r vara ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'bÃ¶r vara ' + (cond);
        break;
      case 'if':
        out = 'should match "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'borde vara ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'borde inte ha fler Ã¤n ' + (n) + ' sak';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'borde inte vara lÃ¤ngre Ã¤n ' + (n) + ' tecken';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'borde inte ha fler Ã¤n ' + (n) + ' egenskap';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'borde vara ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'borde inte ha fÃ¤rre Ã¤n ' + (n) + ' sak';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'borde inte vara kortare Ã¤n ' + (n) + ' tecken';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'borde inte ha fÃ¤rre Ã¤n ' + (n) + ' egenskap';
        if (n != 1) {
          out += 'er';
        }
        break;
      case 'multipleOf':
        out = 'borde vara en multipel av ' + (e.params.multipleOf);
        break;
      case 'not':
        out = 'borde inte vara giltigt enligt schema i "not"';
        break;
      case 'oneOf':
        out = 'borde matcha exakt ett schema i "oneOf"';
        break;
      case 'pattern':
        out = 'borde matcha mÃ¶nstret "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'bÃ¶r ha en egenskap som matchar mÃ¶nstret "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'egenskap med namnet \'' + (e.params.propertyName) + '\' Ã¤r inte giltig';
        break;
      case 'required':
        out = 'borde ha den nÃ¶dvÃ¤ndiga egenskapen ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'bÃ¶r passera "switch" nyckelord validering, fallet ' + (e.params.caseIndex) + ' misslyckas';
        break;
      case 'type':
        out = 'borde vara ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'borde inte ha duplicerade saker (sakerna ## ' + (e.params.j) + ' och ' + (e.params.i) + ' Ã¤r identiska)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var th = function localize_th(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'à¹à¸¡à¹à¸ªà¸²à¸¡à¸²à¸£à¸à¸«à¸² reference ' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'à¸à¸§à¸£à¸¡à¸µà¸ªà¸¡à¸²à¸à¸´à¸à¹à¸¡à¹à¹à¸à¸´à¸ ' + (n);
        break;
      case 'additionalProperties':
        out = 'à¹à¸¡à¹à¸à¸§à¸£à¸¡à¸µ property à¹à¸à¸´à¸à¸à¸µà¹à¸à¸³à¸«à¸à¸à¹à¸§à¹';
        break;
      case 'anyOf':
        out = 'à¸à¸§à¸£à¸¡à¸µ schema à¸à¸²à¸à¸­à¸¢à¹à¸²à¸à¸à¸£à¸à¸à¸±à¸à¸à¸µà¹à¸à¸³à¸«à¸à¸à¹à¸§à¹à¹à¸ "anyOf"';
        break;
      case 'const':
        out = 'à¸à¸§à¸£à¸¡à¸µà¸à¹à¸²à¹à¸«à¸¡à¸·à¸­à¸à¸à¸±à¸à¸à¹à¸²à¸à¸à¸à¸µà¹';
        break;
      case 'contains':
        out = 'à¸à¸§à¸£à¸¡à¸µà¸ªà¸¡à¸²à¸à¸´à¸à¸à¸µà¹à¸à¸¹à¸à¸à¹à¸­à¸à¸­à¸¢à¸¹à¹';
        break;
      case 'custom':
        out = 'à¸à¸§à¸£à¸à¹à¸²à¸à¸à¸µà¸¢à¹à¹à¸§à¸´à¸£à¹à¸ "' + (e.keyword) + '"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'à¹à¸¡à¸·à¹à¸­à¸¡à¸µ property ' + (e.params.property) + ' à¹à¸¥à¹à¸§à¸à¹à¸à¸§à¸£à¸¡à¸µ property ' + (e.params.deps) + ' à¸à¹à¸§à¸¢';
        break;
      case 'enum':
        out = 'à¸à¸§à¸£à¸à¸£à¸à¸à¸±à¸à¸à¹à¸²à¸à¸µà¹à¸à¸³à¸«à¸à¸à¹à¸§à¹';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'à¸à¸§à¸£ ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'à¸à¸§à¸£ ' + (cond);
        break;
      case 'false schema':
        out = 'schema à¹à¸à¹à¸ false';
        break;
      case 'format':
        out = 'à¸à¸§à¸£à¸¡à¸µà¸£à¸¹à¸à¹à¸à¸à¹à¸à¹à¸ "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum à¸à¸§à¸£à¹à¸à¹à¸ boolean';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum à¸à¸§à¸£à¹à¸à¹à¸ boolean';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'à¸à¸§à¸£ ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'à¸à¸§à¸£ ' + (cond);
        break;
      case 'if':
        out = 'à¸à¸§à¸£à¸à¸£à¸à¸à¸±à¸ schema "' + (e.params.failingKeyword) + '"';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'à¸à¸§à¸£ ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'à¸à¸§à¸£à¸¡à¸µà¸ªà¸¡à¸²à¸à¸´à¸à¹à¸¡à¹à¹à¸à¸´à¸ ' + (n);
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'à¹à¸¡à¹à¸à¸§à¸£à¸¡à¸²à¸à¸à¸§à¹à¸² ' + (n) + ' à¸à¸±à¸§à¸­à¸±à¸à¸©à¸£';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'à¹à¸¡à¹à¸à¸§à¸£à¸¡à¸µ property à¹à¸à¸´à¸ ' + (n);
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'à¸à¸§à¸£ ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'à¸à¸§à¸£à¸¡à¸µà¸ªà¸¡à¸²à¸à¸´à¸à¹à¸¡à¹à¸à¹à¸­à¸¢à¸à¸§à¹à¸² ' + (n);
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'à¹à¸¡à¹à¸à¸§à¸£à¸à¹à¸­à¸¢à¸à¸§à¹à¸² ' + (n) + ' à¸à¸±à¸§à¸­à¸±à¸à¸©à¸£';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'à¹à¸¡à¹à¸à¸§à¸£à¸¡à¸µ property à¸à¹à¸­à¸¢à¸à¸§à¹à¸² ' + (n);
        break;
      case 'multipleOf':
        out = 'à¸à¸§à¸£à¹à¸à¹à¸à¹à¸¥à¸à¸à¸µà¹à¸«à¸²à¸£ ' + (e.params.multipleOf) + ' à¸¥à¸à¸à¸±à¸§';
        break;
      case 'not':
        out = 'à¹à¸¡à¹à¸à¸§à¸£à¸à¸¹à¸à¸à¹à¸­à¸à¸à¸²à¸¡ schema à¸à¸µà¹à¸à¸³à¸«à¸à¸à¹à¸§à¹à¹à¸ "not"';
        break;
      case 'oneOf':
        out = 'à¸à¸§à¸£à¸à¸£à¸à¸à¸±à¸à¹à¸à¸µà¸¢à¸ schema à¹à¸à¸µà¸¢à¸§à¹à¸ "oneOf" à¹à¸à¹à¸²à¸à¸±à¹à¸';
        break;
      case 'pattern':
        out = 'à¸à¸§à¸£à¸à¸£à¸à¸à¸±à¸à¹à¸à¸à¹à¸à¸´à¸£à¹à¸ "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'à¸à¸§à¸£à¸¡à¸µ property à¸à¸µà¹à¸¡à¸µà¸à¸·à¹à¸­à¸à¸£à¸à¸à¸±à¸ pattern "' + (e.params.missingPattern) + '"';
        break;
      case 'propertyNames':
        out = 'property \'' + (e.params.propertyName) + '\' à¹à¸¡à¹à¸à¸¹à¸à¸à¹à¸­à¸';
        break;
      case 'required':
        out = 'à¸à¸§à¸£à¸¡à¸µ property ' + (e.params.missingProperty) + ' à¸à¸µà¹à¸à¸±à¸à¸à¸±à¸à¹à¸§à¹';
        break;
      case 'switch':
        out = 'à¸à¸§à¸£à¸à¹à¸²à¸à¸à¸µà¸¢à¹à¹à¸§à¸´à¸£à¹à¸ "switch", à¸à¸´à¸à¹à¸à¸ªà¸à¸µà¹ ' + (e.params.caseIndex);
        break;
      case 'type':
        out = 'à¸à¸§à¸£à¹à¸à¹à¸ ' + (e.params.type);
        break;
      case 'uniqueItems':
        out = 'à¹à¸¡à¹à¸à¸§à¸£à¸¡à¸µà¸ªà¸¡à¸²à¸à¸´à¸à¸à¹à¸³à¸±à¸à¸±à¸ (à¸¥à¸³à¸à¸±à¸à¸à¸µà¹ ' + (e.params.j) + ' à¹à¸¥à¸° ' + (e.params.i) + ' à¸à¹à¸³)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var zh = function localize_zh(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'æ æ³æ¾å°å¼ç¨' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'ä¸åè®¸è¶è¿' + (n) + 'ä¸ªåç´ ';
        break;
      case 'additionalProperties':
        out = 'ä¸åè®¸æé¢å¤çå±æ§';
        break;
      case 'anyOf':
        out = 'æ°æ®åºä¸º anyOf ææå®çå¶ä¸­ä¸ä¸ª';
        break;
      case 'const':
        out = 'åºå½ç­äºå¸¸é';
        break;
      case 'contains':
        out = 'åºå½åå«ä¸ä¸ªææé¡¹';
        break;
      case 'custom':
        out = 'åºå½éè¿ "' + (e.keyword) + ' å³é®è¯æ ¡éª"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'åºå½æ¥æå±æ§' + (e.params.property) + 'çä¾èµå±æ§' + (e.params.deps);
        break;
      case 'enum':
        out = 'åºå½æ¯é¢è®¾å®çæä¸¾å¼ä¹ä¸';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'åºå½ä¸º ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'åºå½ä¸º ' + (cond);
        break;
      case 'false schema':
        out = 'å¸å°æ¨¡å¼åºé';
        break;
      case 'format':
        out = 'åºå½å¹éæ ¼å¼ "' + (e.params.format) + '"';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum åºå½æ¯å¸å°å¼';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum åºå½æ¯å¸å°å¼';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'åºå½æ¯ ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'åºå½æ¯ ' + (cond);
        break;
      case 'if':
        out = 'åºå½å¹éæ¨¡å¼ "' + (e.params.failingKeyword) + '" ';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'åºå½ä¸º ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'ä¸åºå¤äº ' + (n) + ' ä¸ªé¡¹';
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'ä¸åºå¤äº ' + (n) + ' ä¸ªå­ç¬¦';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'ä¸åºæå¤äº ' + (n) + ' ä¸ªå±æ§';
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'åºå½ä¸º ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'ä¸åºå°äº ' + (n) + ' ä¸ªé¡¹';
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'ä¸åºå°äº ' + (n) + ' ä¸ªå­ç¬¦';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'ä¸åºæå°äº ' + (n) + ' ä¸ªå±æ§';
        break;
      case 'multipleOf':
        out = 'åºå½æ¯ ' + (e.params.multipleOf) + ' çæ´æ°å';
        break;
      case 'not':
        out = 'ä¸åºå½å¹é "not" schema';
        break;
      case 'oneOf':
        out = 'åªè½å¹éä¸ä¸ª "oneOf" ä¸­ç schema';
        break;
      case 'pattern':
        out = 'åºå½å¹éæ¨¡å¼ "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'åºå½æå±æ§å¹éæ¨¡å¼ ' + (e.params.missingPattern);
        break;
      case 'propertyNames':
        out = 'å±æ§å \'' + (e.params.propertyName) + '\' æ æ';
        break;
      case 'required':
        out = 'åºå½æå¿éå±æ§ ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'ç±äº ' + (e.params.caseIndex) + ' å¤±è´¥ï¼æªéè¿ "switch" æ ¡éª, ';
        break;
      case 'type':
        out = 'åºå½æ¯ ' + (e.params.type) + ' ç±»å';
        break;
      case 'uniqueItems':
        out = 'ä¸åºå½å«æéå¤é¡¹ (ç¬¬ ' + (e.params.j) + ' é¡¹ä¸ç¬¬ ' + (e.params.i) + ' é¡¹æ¯éå¤ç)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var zhTW = function localize_zh_TW(errors) {
  if (!(errors && errors.length)) return;
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    var out;
    switch (e.keyword) {
      case '$ref':
        out = 'ç¡æ³æ¾å°å¼ç¨' + (e.params.ref);
        break;
      case 'additionalItems':
        out = '';
        var n = e.params.limit;
        out += 'ä¸å¯ä»¥è¶é' + (n) + 'ååç´ ';
        break;
      case 'additionalProperties':
        out = 'ä¸å¯ä»¥æé¡å¤çå±¬æ§';
        break;
      case 'anyOf':
        out = 'ä¸ç¬¦å anyOf æå®çæ¨¡å¼';
        break;
      case 'const':
        out = 'æè©²ç­æ¼å¸¸æ¸';
        break;
      case 'contains':
        out = 'æè©²åå«ä¸åææåç´ ';
        break;
      case 'custom':
        out = 'æè©²éé "' + (e.keyword) + ' ééµè©æª¢é©"';
        break;
      case 'dependencies':
        out = '';
        var n = e.params.depsCount;
        out += 'æè©²è¦æå±¬æ§' + (e.params.property) + 'çä¾è³´å±¬æ§' + (e.params.deps);
        break;
      case 'enum':
        out = 'æè©²è¦å¨é è¨­çå¼ä¹ä¸­';
        break;
      case 'exclusiveMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'æè©²è¦ ' + (cond);
        break;
      case 'exclusiveMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'æè©²è¦ ' + (cond);
        break;
      case 'false schema':
        out = 'å¸ææ¨¡å¼ä¸æ­£ç¢º';
        break;
      case 'format':
        out = 'æè©²è¦ç¬¦å' + (e.params.format) + 'æ ¼å¼';
        break;
      case 'formatExclusiveMaximum':
        out = 'formatExclusiveMaximum æè©²æ¯å¸æå¼';
        break;
      case 'formatExclusiveMinimum':
        out = 'formatExclusiveMinimum æè©²æ¯å¸æå¼';
        break;
      case 'formatMaximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'æè©²æ¯ ' + (cond);
        break;
      case 'formatMinimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'æè©²æ¯ ' + (cond);
        break;
      case 'if':
        out = 'æè©²ç¬¦å "' + (e.params.failingKeyword) + '" schema';
        break;
      case 'maximum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'æè©²è¦ ' + (cond);
        break;
      case 'maxItems':
        out = '';
        var n = e.params.limit;
        out += 'ä¸æè©²å¤æ¼ ' + (n) + ' å';
        break;
      case 'maxLength':
        out = '';
        var n = e.params.limit;
        out += 'ä¸æè©²å¤æ¼ ' + (n) + ' åå­å';
        break;
      case 'maxProperties':
        out = '';
        var n = e.params.limit;
        out += 'ä¸æè©²å¤æ¼ ' + (n) + ' åå±¬æ§';
        break;
      case 'minimum':
        out = '';
        var cond = e.params.comparison + " " + e.params.limit;
        out += 'æè©²è¦ ' + (cond);
        break;
      case 'minItems':
        out = '';
        var n = e.params.limit;
        out += 'ä¸æè©²å°æ¼ ' + (n) + ' å';
        break;
      case 'minLength':
        out = '';
        var n = e.params.limit;
        out += 'ä¸æè©²å°æ¼ ' + (n) + ' åå­å';
        break;
      case 'minProperties':
        out = '';
        var n = e.params.limit;
        out += 'ä¸æè©²å°æ¼ ' + (n) + ' åå±¬æ§';
        break;
      case 'multipleOf':
        out = 'æè©²æ¯ ' + (e.params.multipleOf) + ' çæ´æ¸å';
        break;
      case 'not':
        out = 'ä¸æè©²ç¬¦å "not" schema';
        break;
      case 'oneOf':
        out = 'åªè½ç¬¦åä¸å "oneOf" ä¸­ç schema';
        break;
      case 'pattern':
        out = 'æè©²ç¬¦åæ¨¡å¼ "' + (e.params.pattern) + '"';
        break;
      case 'patternRequired':
        out = 'æè©²æå±¬æ§å°ææ¨¡å¼ ' + (e.params.missingPattern);
        break;
      case 'propertyNames':
        out = 'å±æ§å \'' + (e.params.propertyName) + '\' ç¡æ';
        break;
      case 'required':
        out = 'æè©²æå¿é å±¬æ§ ' + (e.params.missingProperty);
        break;
      case 'switch':
        out = 'å çº ' + (e.params.caseIndex) + ' å¤±è´¥ï¼æ²æéé "switch" æª¢é©, ';
        break;
      case 'type':
        out = 'æè©²æ¯ ' + (e.params.type) + ' é¡å';
        break;
      case 'uniqueItems':
        out = 'ä¸æè©²æéè¤é ç® (ç¬¬ ' + (e.params.j) + ' é åç¬¬ ' + (e.params.i) + ' é æ¯éè¤ç)';
        break;
      default:
        continue;
    }
    e.message = out;
  }
};

var localize = {
    en: en,
    ar: ar,
    cz: cz,
    de: de,
    es: es,
    fr: fr,
    hu: hu,
    it: it,
    ja: ja,
    nb: nb,
    nl: nl,
    pl: pl,
    'pt-BR': ptBR,
    ru: ru,
    sk: sk,
    sv: sv,
    th: th,
    zh: zh,
    'zh-TW': zhTW,
};

var trim$2 = stringTrim.trim;


var $parseInt = global_1.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED$4 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
var numberParseInt = FORCED$4 ? function parseInt(string, radix) {
  var S = trim$2(String(string));
  return $parseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
} : $parseInt;

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
_export({ global: true, forced: parseInt != numberParseInt }, {
  parseInt: numberParseInt
});

var defineProperty$7 = objectDefineProperty.f;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;





var setInternalState$4 = internalState.set;



var MATCH$1 = wellKnownSymbol('match');
var NativeRegExp = global_1.RegExp;
var RegExpPrototype$1 = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;

var FORCED$5 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y$2 || fails(function () {
  re2[MATCH$1] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED$5) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegexp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = regexpFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y$2) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(
      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
      thisIsRegExp ? this : RegExpPrototype$1,
      RegExpWrapper
    );

    if (UNSUPPORTED_Y$2 && sticky) setInternalState$4(result, { sticky: sticky });

    return result;
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty$7(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys$3 = getOwnPropertyNames$1(NativeRegExp);
  var index = 0;
  while (keys$3.length > index) proxy(keys$3[index++]);
  RegExpPrototype$1.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype$1;
  redefine(global_1, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');

// do NOT remove this file - it would break pre-compiled schemas
// https://github.com/ajv-validator/ajv/issues/889
var equal = fastDeepEqual;

var formats$1 = formats_1();

var validate$2 = function () {
  var refVal = [];
  var refVal1 = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "_SchemaVer",
    title: "_SchemaVer",
    type: "string",
    "const": "2.0.0"
  };
  refVal[1] = refVal1;

  var refVal2 = function () {
    var refVal = [];

    var refVal1 = function () {
      var refVal = [];

      var refVal1 = function () {
        var refVal = [];
        var refVal1 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "IntegerNonNegative",
          title: "IntegerNonNegative",
          type: "integer",
          multipleOf: 1,
          minimum: 0
        };
        refVal[1] = refVal1;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "populationServed" || key0 == "ageDistributionName" || key0 == "caseCountsName" || key0 == "initialNumberOfCases" || key0 == "importsPerDay" || key0 == "hospitalBeds" || key0 == "icuBeds");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.populationServed;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "populationServed"
                },
                message: "should have required property 'populationServed'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/populationServed",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/populationServed",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/populationServed",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.ageDistributionName;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "ageDistributionName"
                },
                message: "should have required property 'ageDistributionName'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "string") {
                if (ucs2length(data1) < 1) {
                  var err = {
                    keyword: "minLength",
                    dataPath: (dataPath || "") + "/ageDistributionName",
                    schemaPath: "#/properties/ageDistributionName/minLength",
                    params: {
                      limit: 1
                    },
                    message: "should NOT be shorter than 1 characters"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/ageDistributionName",
                  schemaPath: "#/properties/ageDistributionName/type",
                  params: {
                    type: "string"
                  },
                  message: "should be string"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.caseCountsName;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "caseCountsName"
                },
                message: "should have required property 'caseCountsName'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "string") {
                if (ucs2length(data1) < 1) {
                  var err = {
                    keyword: "minLength",
                    dataPath: (dataPath || "") + "/caseCountsName",
                    schemaPath: "#/properties/caseCountsName/minLength",
                    params: {
                      limit: 1
                    },
                    message: "should NOT be shorter than 1 characters"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/caseCountsName",
                  schemaPath: "#/properties/caseCountsName/type",
                  params: {
                    type: "string"
                  },
                  message: "should be string"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.initialNumberOfCases;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "initialNumberOfCases"
                },
                message: "should have required property 'initialNumberOfCases'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/initialNumberOfCases",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/initialNumberOfCases",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/initialNumberOfCases",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.importsPerDay;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "importsPerDay"
                },
                message: "should have required property 'importsPerDay'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/importsPerDay",
                    schemaPath: "#/properties/importsPerDay/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/importsPerDay",
                  schemaPath: "#/properties/importsPerDay/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.hospitalBeds;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "hospitalBeds"
                },
                message: "should have required property 'hospitalBeds'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/hospitalBeds",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/hospitalBeds",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/hospitalBeds",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.icuBeds;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "icuBeds"
                },
                message: "should have required property 'icuBeds'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/icuBeds",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/icuBeds",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/icuBeds",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal1.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumPopulation",
        title: "ScenarioDatumPopulation",
        type: "object",
        additionalProperties: false,
        required: ["populationServed", "ageDistributionName", "caseCountsName", "initialNumberOfCases", "importsPerDay", "hospitalBeds", "icuBeds"],
        properties: {
          populationServed: {
            $ref: "IntegerNonNegative#"
          },
          ageDistributionName: {
            type: "string",
            minLength: 1
          },
          caseCountsName: {
            type: "string",
            minLength: 1
          },
          initialNumberOfCases: {
            $ref: "IntegerNonNegative#"
          },
          importsPerDay: {
            type: "number",
            minimum: 0
          },
          hospitalBeds: {
            $ref: "IntegerNonNegative#"
          },
          icuBeds: {
            $ref: "IntegerNonNegative#"
          }
        }
      };
      refVal1.errors = null;
      refVal[1] = refVal1;

      var refVal2 = function () {
        var refVal = [];
        var refVal1 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "NumericRangeNonNegative",
          title: "NumericRangeNonNegative",
          type: "object",
          additionalProperties: false,
          required: ["begin", "end"],
          properties: {
            begin: {
              type: "number",
              minimum: 0,
              maximum: {
                $data: "1/end"
              }
            },
            end: {
              type: "number"
            }
          }
        };
        refVal[1] = refVal1;
        var refVal2 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "IntegerNonNegative",
          title: "IntegerNonNegative",
          type: "integer",
          multipleOf: 1,
          minimum: 0
        };
        refVal[2] = refVal2;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "r0" || key0 == "latencyDays" || key0 == "infectiousPeriodDays" || key0 == "hospitalStayDays" || key0 == "icuStayDays" || key0 == "seasonalForcing" || key0 == "peakMonth" || key0 == "overflowSeverity");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.r0;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "r0"
                },
                message: "should have required property 'r0'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {

                for (var key2 in data1) {
                  var isAdditional2 = !( key2 == "begin" || key2 == "end");

                  if (isAdditional2) {
                    var err = {
                      keyword: "additionalProperties",
                      dataPath: (dataPath || "") + "/r0",
                      schemaPath: "NumericRangeNonNegative#/additionalProperties",
                      params: {
                        additionalProperty: "" + key2 + ""
                      },
                      message: "should NOT have additional properties"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }

                var data2 = data1.begin;

                if (data2 === undefined) {
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/r0",
                    schemaPath: "NumericRangeNonNegative#/required",
                    params: {
                      missingProperty: "begin"
                    },
                    message: "should have required property 'begin'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {

                  if (typeof data2 === "number") {
                    var schema3 = data1 && data1.end;

                    if (schema3 !== undefined && typeof schema3 != "number" || data2 > schema3 || data2 !== data2) {
                      var err = {
                        keyword: "maximum",
                        dataPath: (dataPath || "") + "/r0/begin",
                        schemaPath: "NumericRangeNonNegative#/properties/begin/maximum",
                        params: {
                          comparison: "<=",
                          limit: schema3,
                          exclusive: false
                        },
                        message: "should be <= " + schema3
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    if (data2 < 0 || data2 !== data2) {
                      var err = {
                        keyword: "minimum",
                        dataPath: (dataPath || "") + "/r0/begin",
                        schemaPath: "NumericRangeNonNegative#/properties/begin/minimum",
                        params: {
                          comparison: ">=",
                          limit: 0,
                          exclusive: false
                        },
                        message: "should be >= 0"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/r0/begin",
                      schemaPath: "NumericRangeNonNegative#/properties/begin/type",
                      params: {
                        type: "number"
                      },
                      message: "should be number"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }

                if (data1.end === undefined) {
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/r0",
                    schemaPath: "NumericRangeNonNegative#/required",
                    params: {
                      missingProperty: "end"
                    },
                    message: "should have required property 'end'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {

                  if (typeof data1.end !== "number") {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/r0/end",
                      schemaPath: "NumericRangeNonNegative#/properties/end/type",
                      params: {
                        type: "number"
                      },
                      message: "should be number"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/r0",
                  schemaPath: "NumericRangeNonNegative#/type",
                  params: {
                    type: "object"
                  },
                  message: "should be object"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.latencyDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "latencyDays"
                },
                message: "should have required property 'latencyDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/latencyDays",
                    schemaPath: "#/properties/latencyDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/latencyDays",
                  schemaPath: "#/properties/latencyDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.infectiousPeriodDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "infectiousPeriodDays"
                },
                message: "should have required property 'infectiousPeriodDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/infectiousPeriodDays",
                    schemaPath: "#/properties/infectiousPeriodDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/infectiousPeriodDays",
                  schemaPath: "#/properties/infectiousPeriodDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.hospitalStayDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "hospitalStayDays"
                },
                message: "should have required property 'hospitalStayDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/hospitalStayDays",
                    schemaPath: "#/properties/hospitalStayDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/hospitalStayDays",
                  schemaPath: "#/properties/hospitalStayDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.icuStayDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "icuStayDays"
                },
                message: "should have required property 'icuStayDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/icuStayDays",
                    schemaPath: "#/properties/icuStayDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/icuStayDays",
                  schemaPath: "#/properties/icuStayDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.seasonalForcing;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "seasonalForcing"
                },
                message: "should have required property 'seasonalForcing'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/seasonalForcing",
                    schemaPath: "#/properties/seasonalForcing/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/seasonalForcing",
                  schemaPath: "#/properties/seasonalForcing/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.peakMonth;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "peakMonth"
                },
                message: "should have required property 'peakMonth'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/peakMonth",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/peakMonth",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division3;

                if (division3 = data1 / 1, division3 !== parseInt(division3)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/peakMonth",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              if (typeof data1 === "number") {
                if (data1 > 11 || data1 !== data1) {
                  var err = {
                    keyword: "maximum",
                    dataPath: (dataPath || "") + "/peakMonth",
                    schemaPath: "#/properties/peakMonth/allOf/1/maximum",
                    params: {
                      comparison: "<=",
                      limit: 11,
                      exclusive: false
                    },
                    message: "should be <= 11"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.overflowSeverity;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "overflowSeverity"
                },
                message: "should have required property 'overflowSeverity'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/overflowSeverity",
                    schemaPath: "#/properties/overflowSeverity/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/overflowSeverity",
                  schemaPath: "#/properties/overflowSeverity/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal2.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumEpidemiological",
        title: "ScenarioDatumEpidemiological",
        type: "object",
        additionalProperties: false,
        required: ["r0", "latencyDays", "infectiousPeriodDays", "hospitalStayDays", "icuStayDays", "seasonalForcing", "peakMonth", "overflowSeverity"],
        properties: {
          r0: {
            $ref: "NumericRangeNonNegative#"
          },
          latencyDays: {
            type: "number",
            minimum: 1
          },
          infectiousPeriodDays: {
            type: "number",
            minimum: 1
          },
          hospitalStayDays: {
            type: "number",
            minimum: 1
          },
          icuStayDays: {
            type: "number",
            minimum: 1
          },
          seasonalForcing: {
            type: "number",
            minimum: 0
          },
          peakMonth: {
            allOf: [{
              $ref: "IntegerNonNegative#"
            }, {
              maximum: 11
            }]
          },
          overflowSeverity: {
            type: "number",
            minimum: 0
          }
        }
      };
      refVal2.errors = null;
      refVal[2] = refVal2;

      var refVal3 = function () {
        var refVal = [];
        var refVal1 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "DateRange",
          title: "DateRange",
          type: "object",
          additionalProperties: false,
          required: ["begin", "end"],
          properties: {
            begin: {
              oneOf: [{
                type: "string",
                format: "date"
              }, {
                type: "string",
                format: "date-time"
              }],
              formatMaximum: {
                $data: "1/end"
              }
            },
            end: {
              oneOf: [{
                type: "string",
                format: "date"
              }, {
                type: "string",
                format: "date-time"
              }]
            }
          }
        };
        refVal[1] = refVal1;
        var refVal2 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "Integer",
          title: "Integer",
          type: "integer",
          multipleOf: 1
        };
        refVal[2] = refVal2;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "simulationTimeRange" || key0 == "numberStochasticRuns");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.simulationTimeRange;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "simulationTimeRange"
                },
                message: "should have required property 'simulationTimeRange'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                var valid3 = true;

                for (var key2 in data1) {
                  var isAdditional2 = !( key2 == "begin" || key2 == "end");

                  if (isAdditional2) {
                    valid3 = false;
                    var err = {
                      keyword: "additionalProperties",
                      dataPath: (dataPath || "") + "/simulationTimeRange",
                      schemaPath: "DateRange#/additionalProperties",
                      params: {
                        additionalProperty: "" + key2 + ""
                      },
                      message: "should NOT have additional properties"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }

                var data2 = data1.begin;

                if (data2 === undefined) {
                  valid3 = false;
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/simulationTimeRange",
                    schemaPath: "DateRange#/required",
                    params: {
                      missingProperty: "begin"
                    },
                    message: "should have required property 'begin'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {
                  var errs_3 = errors;
                  var errs__3 = errors,
                      prevValid3 = false,
                      valid3 = false,
                      passingSchemas3 = null;
                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$1.date.test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/0/format",
                        params: {
                          format: "date"
                        },
                        message: 'should match format "date"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                      schemaPath: "DateRange#/properties/begin/oneOf/0/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4) {
                    valid3 = prevValid3 = true;
                    passingSchemas3 = 0;
                  }

                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$1["date-time"].test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/1/format",
                        params: {
                          format: "date-time"
                        },
                        message: 'should match format "date-time"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                      schemaPath: "DateRange#/properties/begin/oneOf/1/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4 && prevValid3) {
                    valid3 = false;
                    passingSchemas3 = [passingSchemas3, 1];
                  } else {
                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 1;
                    }
                  }

                  if (!valid3) {
                    var err = {
                      keyword: "oneOf",
                      dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                      schemaPath: "DateRange#/properties/begin/oneOf",
                      params: {
                        passingSchemas: passingSchemas3
                      },
                      message: "should match exactly one schema in oneOf"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    errors = errs__3;

                    if (vErrors !== null) {
                      if (errs__3) vErrors.length = errs__3;else vErrors = null;
                    }
                  }

                  var valid3 = errors === errs_3;
                }

                var data2 = data1.end;

                if (data2 === undefined) {
                  valid3 = false;
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/simulationTimeRange",
                    schemaPath: "DateRange#/required",
                    params: {
                      missingProperty: "end"
                    },
                    message: "should have required property 'end'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {
                  var errs_3 = errors;
                  var errs__3 = errors,
                      prevValid3 = false,
                      valid3 = false,
                      passingSchemas3 = null;
                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$1.date.test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/0/format",
                        params: {
                          format: "date"
                        },
                        message: 'should match format "date"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/end",
                      schemaPath: "DateRange#/properties/end/oneOf/0/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4) {
                    valid3 = prevValid3 = true;
                    passingSchemas3 = 0;
                  }

                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$1["date-time"].test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/1/format",
                        params: {
                          format: "date-time"
                        },
                        message: 'should match format "date-time"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/end",
                      schemaPath: "DateRange#/properties/end/oneOf/1/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4 && prevValid3) {
                    valid3 = false;
                    passingSchemas3 = [passingSchemas3, 1];
                  } else {
                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 1;
                    }
                  }

                  if (!valid3) {
                    var err = {
                      keyword: "oneOf",
                      dataPath: (dataPath || "") + "/simulationTimeRange/end",
                      schemaPath: "DateRange#/properties/end/oneOf",
                      params: {
                        passingSchemas: passingSchemas3
                      },
                      message: "should match exactly one schema in oneOf"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    errors = errs__3;

                    if (vErrors !== null) {
                      if (errs__3) vErrors.length = errs__3;else vErrors = null;
                    }
                  }

                  var valid3 = errors === errs_3;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/simulationTimeRange",
                  schemaPath: "DateRange#/type",
                  params: {
                    type: "object"
                  },
                  message: "should be object"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.numberStochasticRuns;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "numberStochasticRuns"
                },
                message: "should have required property 'numberStochasticRuns'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {
              var errs_3 = errors;

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/numberStochasticRuns",
                  schemaPath: "Integer#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                var division3;

                if (division3 = data1 / 1, division3 !== parseInt(division3)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/numberStochasticRuns",
                    schemaPath: "Integer#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var valid3 = errors === errs_3;

              if (typeof data1 === "number") {
                if (data1 > 100 || data1 !== data1) {
                  var err = {
                    keyword: "maximum",
                    dataPath: (dataPath || "") + "/numberStochasticRuns",
                    schemaPath: "#/properties/numberStochasticRuns/allOf/1/maximum",
                    params: {
                      comparison: "<=",
                      limit: 100,
                      exclusive: false
                    },
                    message: "should be <= 100"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                if (data1 < 10 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/numberStochasticRuns",
                    schemaPath: "#/properties/numberStochasticRuns/allOf/1/minimum",
                    params: {
                      comparison: ">=",
                      limit: 10,
                      exclusive: false
                    },
                    message: "should be >= 10"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal3.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumSimulation",
        title: "ScenarioDatumSimulation",
        type: "object",
        additionalProperties: false,
        required: ["simulationTimeRange", "numberStochasticRuns"],
        properties: {
          simulationTimeRange: {
            $ref: "DateRange#"
          },
          numberStochasticRuns: {
            allOf: [{
              $ref: "Integer#"
            }, {
              minimum: 10,
              maximum: 100
            }]
          }
        }
      };
      refVal3.errors = null;
      refVal[3] = refVal3;

      var refVal4 = function () {
        var refVal = [];

        var refVal1 = function () {
          var pattern0 = new RegExp("^#(?:[0-9a-fA-F]{3}){1,2}$");
          var refVal = [];
          var refVal1 = {
            $schema: "http://json-schema.org/draft-07/schema",
            $id: "ColorHex",
            title: "ColorHex",
            type: "string",
            pattern: "^#(?:[0-9a-fA-F]{3}){1,2}$"
          };
          refVal[1] = refVal1;
          var refVal2 = {
            $schema: "http://json-schema.org/draft-07/schema",
            $id: "DateRange",
            title: "DateRange",
            type: "object",
            additionalProperties: false,
            required: ["begin", "end"],
            properties: {
              begin: {
                oneOf: [{
                  type: "string",
                  format: "date"
                }, {
                  type: "string",
                  format: "date-time"
                }],
                formatMaximum: {
                  $data: "1/end"
                }
              },
              end: {
                oneOf: [{
                  type: "string",
                  format: "date"
                }, {
                  type: "string",
                  format: "date-time"
                }]
              }
            }
          };
          refVal[2] = refVal2;
          var refVal3 = {
            $schema: "http://json-schema.org/draft-07/schema",
            $id: "PercentageRange",
            title: "PercentageRange",
            type: "object",
            additionalProperties: false,
            required: ["begin", "end"],
            properties: {
              begin: {
                type: "number",
                minimum: 0,
                maximum: {
                  $data: "1/end"
                }
              },
              end: {
                type: "number",
                maximum: 100
              }
            }
          };
          refVal[3] = refVal3;
          return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

            var vErrors = null;
            var errors = 0;

            if (data && typeof data === "object" && !Array.isArray(data)) {

              for (var key0 in data) {
                var isAdditional0 = !( key0 == "name" || key0 == "color" || key0 == "timeRange" || key0 == "transmissionReduction");

                if (isAdditional0) {
                  var err = {
                    keyword: "additionalProperties",
                    dataPath: (dataPath || "") + "",
                    schemaPath: "#/additionalProperties",
                    params: {
                      additionalProperty: "" + key0 + ""
                    },
                    message: "should NOT have additional properties"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.name;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "name"
                  },
                  message: "should have required property 'name'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (typeof data1 === "string") {
                  if (ucs2length(data1) < 1) {
                    var err = {
                      keyword: "minLength",
                      dataPath: (dataPath || "") + "/name",
                      schemaPath: "#/properties/name/minLength",
                      params: {
                        limit: 1
                      },
                      message: "should NOT be shorter than 1 characters"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/name",
                    schemaPath: "#/properties/name/type",
                    params: {
                      type: "string"
                    },
                    message: "should be string"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.color;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "color"
                  },
                  message: "should have required property 'color'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (typeof data1 === "string") {
                  if (!pattern0.test(data1)) {
                    var err = {
                      keyword: "pattern",
                      dataPath: (dataPath || "") + "/color",
                      schemaPath: "ColorHex#/pattern",
                      params: {
                        pattern: "^#(?:[0-9a-fA-F]{3}){1,2}$"
                      },
                      message: 'should match pattern "^#(?:[0-9a-fA-F]{3}){1,2}$"'
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/color",
                    schemaPath: "ColorHex#/type",
                    params: {
                      type: "string"
                    },
                    message: "should be string"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.timeRange;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "timeRange"
                  },
                  message: "should have required property 'timeRange'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                  var valid3 = true;

                  for (var key2 in data1) {
                    var isAdditional2 = !( key2 == "begin" || key2 == "end");

                    if (isAdditional2) {
                      valid3 = false;
                      var err = {
                        keyword: "additionalProperties",
                        dataPath: (dataPath || "") + "/timeRange",
                        schemaPath: "DateRange#/additionalProperties",
                        params: {
                          additionalProperty: "" + key2 + ""
                        },
                        message: "should NOT have additional properties"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  }

                  var data2 = data1.begin;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/timeRange",
                      schemaPath: "DateRange#/required",
                      params: {
                        missingProperty: "begin"
                      },
                      message: "should have required property 'begin'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;
                    var errs__3 = errors,
                        prevValid3 = false,
                        valid3 = false,
                        passingSchemas3 = null;
                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$1.date.test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/begin",
                          schemaPath: "DateRange#/properties/begin/oneOf/0/format",
                          params: {
                            format: "date"
                          },
                          message: 'should match format "date"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/0/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 0;
                    }

                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$1["date-time"].test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/begin",
                          schemaPath: "DateRange#/properties/begin/oneOf/1/format",
                          params: {
                            format: "date-time"
                          },
                          message: 'should match format "date-time"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/1/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4 && prevValid3) {
                      valid3 = false;
                      passingSchemas3 = [passingSchemas3, 1];
                    } else {
                      if (valid4) {
                        valid3 = prevValid3 = true;
                        passingSchemas3 = 1;
                      }
                    }

                    if (!valid3) {
                      var err = {
                        keyword: "oneOf",
                        dataPath: (dataPath || "") + "/timeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf",
                        params: {
                          passingSchemas: passingSchemas3
                        },
                        message: "should match exactly one schema in oneOf"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    } else {
                      errors = errs__3;

                      if (vErrors !== null) {
                        if (errs__3) vErrors.length = errs__3;else vErrors = null;
                      }
                    }

                    var valid3 = errors === errs_3;
                  }

                  var data2 = data1.end;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/timeRange",
                      schemaPath: "DateRange#/required",
                      params: {
                        missingProperty: "end"
                      },
                      message: "should have required property 'end'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;
                    var errs__3 = errors,
                        prevValid3 = false,
                        valid3 = false,
                        passingSchemas3 = null;
                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$1.date.test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/end",
                          schemaPath: "DateRange#/properties/end/oneOf/0/format",
                          params: {
                            format: "date"
                          },
                          message: 'should match format "date"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/0/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 0;
                    }

                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$1["date-time"].test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/end",
                          schemaPath: "DateRange#/properties/end/oneOf/1/format",
                          params: {
                            format: "date-time"
                          },
                          message: 'should match format "date-time"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/1/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4 && prevValid3) {
                      valid3 = false;
                      passingSchemas3 = [passingSchemas3, 1];
                    } else {
                      if (valid4) {
                        valid3 = prevValid3 = true;
                        passingSchemas3 = 1;
                      }
                    }

                    if (!valid3) {
                      var err = {
                        keyword: "oneOf",
                        dataPath: (dataPath || "") + "/timeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf",
                        params: {
                          passingSchemas: passingSchemas3
                        },
                        message: "should match exactly one schema in oneOf"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    } else {
                      errors = errs__3;

                      if (vErrors !== null) {
                        if (errs__3) vErrors.length = errs__3;else vErrors = null;
                      }
                    }

                    var valid3 = errors === errs_3;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/timeRange",
                    schemaPath: "DateRange#/type",
                    params: {
                      type: "object"
                    },
                    message: "should be object"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.transmissionReduction;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "transmissionReduction"
                  },
                  message: "should have required property 'transmissionReduction'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                  var valid3 = true;

                  for (var key2 in data1) {
                    var isAdditional2 = !( key2 == "begin" || key2 == "end");

                    if (isAdditional2) {
                      valid3 = false;
                      var err = {
                        keyword: "additionalProperties",
                        dataPath: (dataPath || "") + "/transmissionReduction",
                        schemaPath: "PercentageRange#/additionalProperties",
                        params: {
                          additionalProperty: "" + key2 + ""
                        },
                        message: "should NOT have additional properties"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  }

                  var data2 = data1.begin;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/transmissionReduction",
                      schemaPath: "PercentageRange#/required",
                      params: {
                        missingProperty: "begin"
                      },
                      message: "should have required property 'begin'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;

                    if (typeof data2 === "number") {
                      var schema3 = data1 && data1.end;

                      if (schema3 !== undefined && typeof schema3 != "number" || data2 > schema3 || data2 !== data2) {
                        var err = {
                          keyword: "maximum",
                          dataPath: (dataPath || "") + "/transmissionReduction/begin",
                          schemaPath: "PercentageRange#/properties/begin/maximum",
                          params: {
                            comparison: "<=",
                            limit: schema3,
                            exclusive: false
                          },
                          message: "should be <= " + schema3
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }

                      if (data2 < 0 || data2 !== data2) {
                        var err = {
                          keyword: "minimum",
                          dataPath: (dataPath || "") + "/transmissionReduction/begin",
                          schemaPath: "PercentageRange#/properties/begin/minimum",
                          params: {
                            comparison: ">=",
                            limit: 0,
                            exclusive: false
                          },
                          message: "should be >= 0"
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/transmissionReduction/begin",
                        schemaPath: "PercentageRange#/properties/begin/type",
                        params: {
                          type: "number"
                        },
                        message: "should be number"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid3 = errors === errs_3;
                  }

                  var data2 = data1.end;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/transmissionReduction",
                      schemaPath: "PercentageRange#/required",
                      params: {
                        missingProperty: "end"
                      },
                      message: "should have required property 'end'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;

                    if (typeof data2 === "number") {
                      if (data2 > 100 || data2 !== data2) {
                        var err = {
                          keyword: "maximum",
                          dataPath: (dataPath || "") + "/transmissionReduction/end",
                          schemaPath: "PercentageRange#/properties/end/maximum",
                          params: {
                            comparison: "<=",
                            limit: 100,
                            exclusive: false
                          },
                          message: "should be <= 100"
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/transmissionReduction/end",
                        schemaPath: "PercentageRange#/properties/end/type",
                        params: {
                          type: "number"
                        },
                        message: "should be number"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid3 = errors === errs_3;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/transmissionReduction",
                    schemaPath: "PercentageRange#/type",
                    params: {
                      type: "object"
                    },
                    message: "should be object"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/type",
                params: {
                  type: "object"
                },
                message: "should be object"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            validate.errors = vErrors;
            return errors === 0;
          };
        }();

        refVal1.schema = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "MitigationInterval",
          title: "MitigationInterval",
          type: "object",
          additionalProperties: false,
          required: ["name", "color", "timeRange", "transmissionReduction"],
          properties: {
            name: {
              type: "string",
              minLength: 1
            },
            color: {
              $ref: "ColorHex#"
            },
            timeRange: {
              $ref: "DateRange#"
            },
            transmissionReduction: {
              $ref: "PercentageRange#"
            }
          }
        };
        refVal1.errors = null;
        refVal[1] = refVal1;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;
          if (rootData === undefined) rootData = data;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "mitigationIntervals");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.mitigationIntervals;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "mitigationIntervals"
                },
                message: "should have required property 'mitigationIntervals'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (Array.isArray(data1)) {

                for (var i1 = 0; i1 < data1.length; i1++) {

                  if (!refVal1(data1[i1], (dataPath || "") + "/mitigationIntervals/" + i1, data1, i1, rootData)) {
                    if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/mitigationIntervals",
                  schemaPath: "#/properties/mitigationIntervals/type",
                  params: {
                    type: "array"
                  },
                  message: "should be array"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal4.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumMitigation",
        title: "ScenarioDatumMitigation",
        type: "object",
        additionalProperties: false,
        required: ["mitigationIntervals"],
        properties: {
          mitigationIntervals: {
            type: "array",
            items: {
              $ref: "MitigationInterval#"
            }
          }
        }
      };
      refVal4.errors = null;
      refVal[4] = refVal4;
      return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

        var vErrors = null;
        var errors = 0;
        if (rootData === undefined) rootData = data;

        if (data && typeof data === "object" && !Array.isArray(data)) {

          for (var key0 in data) {
            var isAdditional0 = !( key0 == "population" || key0 == "epidemiological" || key0 == "simulation" || key0 == "mitigation");

            if (isAdditional0) {
              var err = {
                keyword: "additionalProperties",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/additionalProperties",
                params: {
                  additionalProperty: "" + key0 + ""
                },
                message: "should NOT have additional properties"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          }

          if (data.population === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "population"
              },
              message: "should have required property 'population'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal1(data.population, (dataPath || "") + "/population", data, "population", rootData)) {
              if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
              errors = vErrors.length;
            }
          }

          if (data.epidemiological === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "epidemiological"
              },
              message: "should have required property 'epidemiological'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal2(data.epidemiological, (dataPath || "") + "/epidemiological", data, "epidemiological", rootData)) {
              if (vErrors === null) vErrors = refVal2.errors;else vErrors = vErrors.concat(refVal2.errors);
              errors = vErrors.length;
            }
          }

          if (data.simulation === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "simulation"
              },
              message: "should have required property 'simulation'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal3(data.simulation, (dataPath || "") + "/simulation", data, "simulation", rootData)) {
              if (vErrors === null) vErrors = refVal3.errors;else vErrors = vErrors.concat(refVal3.errors);
              errors = vErrors.length;
            }
          }

          if (data.mitigation === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "mitigation"
              },
              message: "should have required property 'mitigation'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal4(data.mitigation, (dataPath || "") + "/mitigation", data, "mitigation", rootData)) {
              if (vErrors === null) vErrors = refVal4.errors;else vErrors = vErrors.concat(refVal4.errors);
              errors = vErrors.length;
            }
          }
        } else {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/type",
            params: {
              type: "object"
            },
            message: "should be object"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        validate.errors = vErrors;
        return errors === 0;
      };
    }();

    refVal1.schema = {
      $schema: "http://json-schema.org/draft-07/schema",
      $id: "ScenarioDatum",
      title: "ScenarioDatum",
      type: "object",
      additionalProperties: false,
      required: ["population", "epidemiological", "simulation", "mitigation"],
      properties: {
        population: {
          $ref: "ScenarioDatumPopulation#"
        },
        epidemiological: {
          $ref: "ScenarioDatumEpidemiological#"
        },
        simulation: {
          $ref: "ScenarioDatumSimulation#"
        },
        mitigation: {
          $ref: "ScenarioDatumMitigation#"
        }
      }
    };
    refVal1.errors = null;
    refVal[1] = refVal1;
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

      var vErrors = null;
      var errors = 0;
      if (rootData === undefined) rootData = data;

      if (data && typeof data === "object" && !Array.isArray(data)) {

        for (var key0 in data) {
          var isAdditional0 = !( key0 == "name" || key0 == "data");

          if (isAdditional0) {
            var err = {
              keyword: "additionalProperties",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/additionalProperties",
              params: {
                additionalProperty: "" + key0 + ""
              },
              message: "should NOT have additional properties"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.name;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "name"
            },
            message: "should have required property 'name'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (typeof data1 === "string") {
            if (ucs2length(data1) < 1) {
              var err = {
                keyword: "minLength",
                dataPath: (dataPath || "") + "/name",
                schemaPath: "#/properties/name/minLength",
                params: {
                  limit: 1
                },
                message: "should NOT be shorter than 1 characters"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/name",
              schemaPath: "#/properties/name/type",
              params: {
                type: "string"
              },
              message: "should be string"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        if (data.data === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "data"
            },
            message: "should have required property 'data'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (!refVal1(data.data, (dataPath || "") + "/data", data, "data", rootData)) {
            if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
            errors = vErrors.length;
          }
        }
      } else {
        var err = {
          keyword: "type",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/type",
          params: {
            type: "object"
          },
          message: "should be object"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      }

      validate.errors = vErrors;
      return errors === 0;
    };
  }();

  refVal2.schema = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "ScenarioData",
    title: "ScenarioData",
    type: "object",
    additionalProperties: false,
    required: ["name", "data"],
    properties: {
      name: {
        type: "string",
        minLength: 1
      },
      data: {
        $ref: "ScenarioDatum#"
      }
    }
  };
  refVal2.errors = null;
  refVal[2] = refVal2;

  var refVal3 = function () {
    var refVal = [];

    var refVal1 = function () {
      var refVal = [];
      var refVal1 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "AgeGroup",
        title: "AgeGroup",
        type: "string",
        "enum": ["0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80+"]
      };
      refVal[1] = refVal1;
      var refVal2 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "IntegerNonNegative",
        title: "IntegerNonNegative",
        type: "integer",
        multipleOf: 1,
        minimum: 0
      };
      refVal[2] = refVal2;
      return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

        var vErrors = null;
        var errors = 0;

        if (data && typeof data === "object" && !Array.isArray(data)) {

          for (var key0 in data) {
            var isAdditional0 = !( key0 == "ageGroup" || key0 == "population");

            if (isAdditional0) {
              var err = {
                keyword: "additionalProperties",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/additionalProperties",
                params: {
                  additionalProperty: "" + key0 + ""
                },
                message: "should NOT have additional properties"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          }

          var data1 = data.ageGroup;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "ageGroup"
              },
              message: "should have required property 'ageGroup'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 !== "string") {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/type",
                params: {
                  type: "string"
                },
                message: "should be string"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var schema2 = refVal1["enum"];
            var valid2;
            valid2 = false;

            for (var i2 = 0; i2 < schema2.length; i2++) {
              if (equal(data1, schema2[i2])) {
                valid2 = true;
                break;
              }
            }

            if (!valid2) {
              var err = {
                keyword: "enum",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/enum",
                params: {
                  allowedValues: schema2
                },
                message: "should be equal to one of the allowed values"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.population;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "population"
              },
              message: "should have required property 'population'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/population",
                schemaPath: "IntegerNonNegative#/type",
                params: {
                  type: "integer"
                },
                message: "should be integer"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            if (typeof data1 === "number") {
              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/population",
                  schemaPath: "IntegerNonNegative#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              var division2;

              if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                var err = {
                  keyword: "multipleOf",
                  dataPath: (dataPath || "") + "/population",
                  schemaPath: "IntegerNonNegative#/multipleOf",
                  params: {
                    multipleOf: 1
                  },
                  message: "should be multiple of 1"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var valid2 = errors === errs_2;
          }
        } else {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/type",
            params: {
              type: "object"
            },
            message: "should be object"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        validate.errors = vErrors;
        return errors === 0;
      };
    }();

    refVal1.schema = {
      $schema: "http://json-schema.org/draft-07/schema",
      $id: "AgeDistributionDatum",
      title: "AgeDistributionDatum",
      type: "object",
      additionalProperties: false,
      required: ["ageGroup", "population"],
      properties: {
        ageGroup: {
          $ref: "AgeGroup#"
        },
        population: {
          $ref: "IntegerNonNegative#"
        }
      }
    };
    refVal1.errors = null;
    refVal[1] = refVal1;
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

      var vErrors = null;
      var errors = 0;
      if (rootData === undefined) rootData = data;

      if (data && typeof data === "object" && !Array.isArray(data)) {

        for (var key0 in data) {
          var isAdditional0 = !( key0 == "name" || key0 == "data");

          if (isAdditional0) {
            var err = {
              keyword: "additionalProperties",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/additionalProperties",
              params: {
                additionalProperty: "" + key0 + ""
              },
              message: "should NOT have additional properties"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.name;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "name"
            },
            message: "should have required property 'name'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (typeof data1 === "string") {
            if (ucs2length(data1) < 1) {
              var err = {
                keyword: "minLength",
                dataPath: (dataPath || "") + "/name",
                schemaPath: "#/properties/name/minLength",
                params: {
                  limit: 1
                },
                message: "should NOT be shorter than 1 characters"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/name",
              schemaPath: "#/properties/name/type",
              params: {
                type: "string"
              },
              message: "should be string"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.data;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "data"
            },
            message: "should have required property 'data'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (Array.isArray(data1)) {

            for (var i1 = 0; i1 < data1.length; i1++) {

              if (!refVal1(data1[i1], (dataPath || "") + "/data/" + i1, data1, i1, rootData)) {
                if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
                errors = vErrors.length;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/data",
              schemaPath: "#/properties/data/type",
              params: {
                type: "array"
              },
              message: "should be array"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }
      } else {
        var err = {
          keyword: "type",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/type",
          params: {
            type: "object"
          },
          message: "should be object"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      }

      validate.errors = vErrors;
      return errors === 0;
    };
  }();

  refVal3.schema = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "AgeDistributionData",
    title: "AgeDistributionData",
    type: "object",
    additionalProperties: false,
    required: ["name", "data"],
    properties: {
      name: {
        type: "string",
        minLength: 1
      },
      data: {
        type: "array",
        items: {
          $ref: "AgeDistributionDatum#"
        }
      }
    }
  };
  refVal3.errors = null;
  refVal[3] = refVal3;

  var refVal4 = function () {
    var refVal = [];

    var refVal1 = function () {
      var refVal = [];
      var refVal1 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "AgeGroup",
        title: "AgeGroup",
        type: "string",
        "enum": ["0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80+"]
      };
      refVal[1] = refVal1;
      var refVal2 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "Percentage",
        title: "Percentage",
        type: "number",
        minimum: 0,
        maximum: 100
      };
      refVal[2] = refVal2;
      return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

        var vErrors = null;
        var errors = 0;

        if (data && typeof data === "object" && !Array.isArray(data)) {

          for (var key0 in data) {
            var isAdditional0 = !( key0 == "ageGroup" || key0 == "isolated" || key0 == "confirmed" || key0 == "severe" || key0 == "critical" || key0 == "fatal");

            if (isAdditional0) {
              var err = {
                keyword: "additionalProperties",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/additionalProperties",
                params: {
                  additionalProperty: "" + key0 + ""
                },
                message: "should NOT have additional properties"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          }

          var data1 = data.ageGroup;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "ageGroup"
              },
              message: "should have required property 'ageGroup'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 !== "string") {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/type",
                params: {
                  type: "string"
                },
                message: "should be string"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var schema2 = refVal1["enum"];
            var valid2;
            valid2 = false;

            for (var i2 = 0; i2 < schema2.length; i2++) {
              if (equal(data1, schema2[i2])) {
                valid2 = true;
                break;
              }
            }

            if (!valid2) {
              var err = {
                keyword: "enum",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/enum",
                params: {
                  allowedValues: schema2
                },
                message: "should be equal to one of the allowed values"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.isolated;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "isolated"
              },
              message: "should have required property 'isolated'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/isolated",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/isolated",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/isolated",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.confirmed;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "confirmed"
              },
              message: "should have required property 'confirmed'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/confirmed",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/confirmed",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/confirmed",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.severe;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "severe"
              },
              message: "should have required property 'severe'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/severe",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/severe",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/severe",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.critical;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "critical"
              },
              message: "should have required property 'critical'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/critical",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/critical",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/critical",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.fatal;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "fatal"
              },
              message: "should have required property 'fatal'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/fatal",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/fatal",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/fatal",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }
        } else {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/type",
            params: {
              type: "object"
            },
            message: "should be object"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        validate.errors = vErrors;
        return errors === 0;
      };
    }();

    refVal1.schema = {
      $schema: "http://json-schema.org/draft-07/schema",
      $id: "SeverityDistributionDatum",
      title: "SeverityDistributionDatum",
      additionalProperties: false,
      type: "object",
      required: ["ageGroup", "isolated", "confirmed", "severe", "critical", "fatal"],
      properties: {
        ageGroup: {
          $ref: "AgeGroup#"
        },
        isolated: {
          $ref: "Percentage#"
        },
        confirmed: {
          $ref: "Percentage#"
        },
        severe: {
          $ref: "Percentage#"
        },
        critical: {
          $ref: "Percentage#"
        },
        fatal: {
          $ref: "Percentage#"
        }
      }
    };
    refVal1.errors = null;
    refVal[1] = refVal1;
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

      var vErrors = null;
      var errors = 0;
      if (rootData === undefined) rootData = data;

      if (data && typeof data === "object" && !Array.isArray(data)) {

        for (var key0 in data) {
          var isAdditional0 = !( key0 == "name" || key0 == "data");

          if (isAdditional0) {
            var err = {
              keyword: "additionalProperties",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/additionalProperties",
              params: {
                additionalProperty: "" + key0 + ""
              },
              message: "should NOT have additional properties"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.name;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "name"
            },
            message: "should have required property 'name'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (typeof data1 === "string") {
            if (ucs2length(data1) < 1) {
              var err = {
                keyword: "minLength",
                dataPath: (dataPath || "") + "/name",
                schemaPath: "#/properties/name/minLength",
                params: {
                  limit: 1
                },
                message: "should NOT be shorter than 1 characters"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/name",
              schemaPath: "#/properties/name/type",
              params: {
                type: "string"
              },
              message: "should be string"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.data;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "data"
            },
            message: "should have required property 'data'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (Array.isArray(data1)) {

            for (var i1 = 0; i1 < data1.length; i1++) {

              if (!refVal1(data1[i1], (dataPath || "") + "/data/" + i1, data1, i1, rootData)) {
                if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
                errors = vErrors.length;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/data",
              schemaPath: "#/properties/data/type",
              params: {
                type: "array"
              },
              message: "should be array"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }
      } else {
        var err = {
          keyword: "type",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/type",
          params: {
            type: "object"
          },
          message: "should be object"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      }

      validate.errors = vErrors;
      return errors === 0;
    };
  }();

  refVal4.schema = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "SeverityDistributionData",
    title: "SeverityDistributionData",
    type: "object",
    additionalProperties: false,
    required: ["name", "data"],
    properties: {
      name: {
        type: "string",
        minLength: 1
      },
      data: {
        type: "array",
        items: {
          $ref: "SeverityDistributionDatum#"
        }
      }
    }
  };
  refVal4.errors = null;
  refVal[4] = refVal4;
  return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

    var vErrors = null;
    var errors = 0;
    if (rootData === undefined) rootData = data;

    if (data && typeof data === "object" && !Array.isArray(data)) {

      for (var key0 in data) {
        var isAdditional0 = !( key0 == "schemaVer" || key0 == "scenarioData" || key0 == "ageDistributionData" || key0 == "severityDistributionData");

        if (isAdditional0) {
          var err = {
            keyword: "additionalProperties",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/additionalProperties",
            params: {
              additionalProperty: "" + key0 + ""
            },
            message: "should NOT have additional properties"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }
      }

      var data1 = data.schemaVer;

      if (data1 === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "schemaVer"
          },
          message: "should have required property 'schemaVer'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {
        var errs_2 = errors;

        if (typeof data1 !== "string") {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "/schemaVer",
            schemaPath: "_SchemaVer#/type",
            params: {
              type: "string"
            },
            message: "should be string"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        var schema2 = refVal1["const"];
        var valid2 = equal(data1, schema2);

        if (!valid2) {
          var err = {
            keyword: "const",
            dataPath: (dataPath || "") + "/schemaVer",
            schemaPath: "_SchemaVer#/const",
            params: {
              allowedValue: schema2
            },
            message: "should be equal to constant"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        var valid2 = errors === errs_2;
      }

      if (data.scenarioData === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "scenarioData"
          },
          message: "should have required property 'scenarioData'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {

        if (!refVal2(data.scenarioData, (dataPath || "") + "/scenarioData", data, "scenarioData", rootData)) {
          if (vErrors === null) vErrors = refVal2.errors;else vErrors = vErrors.concat(refVal2.errors);
          errors = vErrors.length;
        }
      }

      if (data.ageDistributionData === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "ageDistributionData"
          },
          message: "should have required property 'ageDistributionData'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {

        if (!refVal3(data.ageDistributionData, (dataPath || "") + "/ageDistributionData", data, "ageDistributionData", rootData)) {
          if (vErrors === null) vErrors = refVal3.errors;else vErrors = vErrors.concat(refVal3.errors);
          errors = vErrors.length;
        }
      }

      if (data.severityDistributionData === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "severityDistributionData"
          },
          message: "should have required property 'severityDistributionData'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {

        if (!refVal4(data.severityDistributionData, (dataPath || "") + "/severityDistributionData", data, "severityDistributionData", rootData)) {
          if (vErrors === null) vErrors = refVal4.errors;else vErrors = vErrors.concat(refVal4.errors);
          errors = vErrors.length;
        }
      }
    } else {
      var err = {
        keyword: "type",
        dataPath: (dataPath || "") + "",
        schemaPath: "#/type",
        params: {
          type: "object"
        },
        message: "should be object"
      };
      if (vErrors === null) vErrors = [err];else vErrors.push(err);
      errors++;
    }

    validate.errors = vErrors;
    return errors === 0;
  };
}();

validate$2.schema = {
  $schema: "http://json-schema.org/draft-07/schema",
  $id: "Shareable",
  title: "Shareable",
  type: "object",
  additionalProperties: false,
  required: ["schemaVer", "scenarioData", "ageDistributionData", "severityDistributionData"],
  properties: {
    schemaVer: {
      $ref: "_SchemaVer#"
    },
    scenarioData: {
      $ref: "ScenarioData#"
    },
    ageDistributionData: {
      $ref: "AgeDistributionData#"
    },
    severityDistributionData: {
      $ref: "SeverityDistributionData#"
    }
  }
};
validate$2.errors = null;
var validateShareable = validate$2;

//
//   import { Convert, AgeDistributionArray, AgeDistributionData, AgeDistributionDatum, AgeGroup, CaseCountsArray, CaseCountsData, CaseCountsDatum, DateRange, MitigationInterval, NumericRangeNonNegative, PercentageRange, ScenarioArray, ScenarioData, ScenarioDatum, ScenarioDatumEpidemiological, ScenarioDatumMitigation, ScenarioDatumPopulation, ScenarioDatumSimulation, SeverityDistributionArray, SeverityDistributionData, SeverityDistributionDatum, Shareable } from "./file";
//
//   const ageDistributionArray = Convert.toAgeDistributionArray(json);
//   const ageDistributionData = Convert.toAgeDistributionData(json);
//   const ageDistributionDatum = Convert.toAgeDistributionDatum(json);
//   const ageGroup = Convert.toAgeGroup(json);
//   const caseCountsArray = Convert.toCaseCountsArray(json);
//   const caseCountsData = Convert.toCaseCountsData(json);
//   const caseCountsDatum = Convert.toCaseCountsDatum(json);
//   const colorHex = Convert.toColorHex(json);
//   const dateRange = Convert.toDateRange(json);
//   const integer = Convert.toInteger(json);
//   const integerNonNegative = Convert.toIntegerNonNegative(json);
//   const integerPositive = Convert.toIntegerPositive(json);
//   const mitigationInterval = Convert.toMitigationInterval(json);
//   const numericRangeNonNegative = Convert.toNumericRangeNonNegative(json);
//   const percentage = Convert.toPercentage(json);
//   const percentageRange = Convert.toPercentageRange(json);
//   const scenarioArray = Convert.toScenarioArray(json);
//   const scenarioData = Convert.toScenarioData(json);
//   const scenarioDatum = Convert.toScenarioDatum(json);
//   const scenarioDatumEpidemiological = Convert.toScenarioDatumEpidemiological(json);
//   const scenarioDatumMitigation = Convert.toScenarioDatumMitigation(json);
//   const scenarioDatumPopulation = Convert.toScenarioDatumPopulation(json);
//   const scenarioDatumSimulation = Convert.toScenarioDatumSimulation(json);
//   const severityDistributionArray = Convert.toSeverityDistributionArray(json);
//   const severityDistributionData = Convert.toSeverityDistributionData(json);
//   const severityDistributionDatum = Convert.toSeverityDistributionDatum(json);
//   const shareable = Convert.toShareable(json);
//   const schemaVer = Convert.toSchemaVer(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

var AgeGroup$1;

(function (AgeGroup) {
  AgeGroup["The09"] = "0-9";
  AgeGroup["The1019"] = "10-19";
  AgeGroup["The2029"] = "20-29";
  AgeGroup["The3039"] = "30-39";
  AgeGroup["The4049"] = "40-49";
  AgeGroup["The5059"] = "50-59";
  AgeGroup["The6069"] = "60-69";
  AgeGroup["The7079"] = "70-79";
  AgeGroup["The80"] = "80+";
})(AgeGroup$1 || (AgeGroup$1 = {}));

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
var Convert$1 = /*#__PURE__*/function () {
  function Convert() {
    _classCallCheck(this, Convert);
  }

  _createClass(Convert, null, [{
    key: "toAgeDistributionArray",
    value: function toAgeDistributionArray(json) {
      return cast$1(JSON.parse(json), r$1("AgeDistributionArray"));
    }
  }, {
    key: "ageDistributionArrayToJson",
    value: function ageDistributionArrayToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("AgeDistributionArray")), null, 2);
    }
  }, {
    key: "toAgeDistributionData",
    value: function toAgeDistributionData(json) {
      return cast$1(JSON.parse(json), r$1("AgeDistributionData"));
    }
  }, {
    key: "ageDistributionDataToJson",
    value: function ageDistributionDataToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("AgeDistributionData")), null, 2);
    }
  }, {
    key: "toAgeDistributionDatum",
    value: function toAgeDistributionDatum(json) {
      return cast$1(JSON.parse(json), r$1("AgeDistributionDatum"));
    }
  }, {
    key: "ageDistributionDatumToJson",
    value: function ageDistributionDatumToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("AgeDistributionDatum")), null, 2);
    }
  }, {
    key: "toCaseCountsArray",
    value: function toCaseCountsArray(json) {
      return cast$1(JSON.parse(json), r$1("CaseCountsArray"));
    }
  }, {
    key: "caseCountsArrayToJson",
    value: function caseCountsArrayToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("CaseCountsArray")), null, 2);
    }
  }, {
    key: "toCaseCountsData",
    value: function toCaseCountsData(json) {
      return cast$1(JSON.parse(json), r$1("CaseCountsData"));
    }
  }, {
    key: "caseCountsDataToJson",
    value: function caseCountsDataToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("CaseCountsData")), null, 2);
    }
  }, {
    key: "toCaseCountsDatum",
    value: function toCaseCountsDatum(json) {
      return cast$1(JSON.parse(json), r$1("CaseCountsDatum"));
    }
  }, {
    key: "caseCountsDatumToJson",
    value: function caseCountsDatumToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("CaseCountsDatum")), null, 2);
    }
  }, {
    key: "toScenarioArray",
    value: function toScenarioArray(json) {
      return cast$1(JSON.parse(json), r$1("ScenarioArray"));
    }
  }, {
    key: "scenarioArrayToJson",
    value: function scenarioArrayToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("ScenarioArray")), null, 2);
    }
  }, {
    key: "toScenarioData",
    value: function toScenarioData(json) {
      return cast$1(JSON.parse(json), r$1("ScenarioData"));
    }
  }, {
    key: "scenarioDataToJson",
    value: function scenarioDataToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("ScenarioData")), null, 2);
    }
  }, {
    key: "toScenarioDatum",
    value: function toScenarioDatum(json) {
      return cast$1(JSON.parse(json), r$1("ScenarioDatum"));
    }
  }, {
    key: "scenarioDatumToJson",
    value: function scenarioDatumToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("ScenarioDatum")), null, 2);
    }
  }, {
    key: "toScenarioDatumEpidemiological",
    value: function toScenarioDatumEpidemiological(json) {
      return cast$1(JSON.parse(json), r$1("ScenarioDatumEpidemiological"));
    }
  }, {
    key: "scenarioDatumEpidemiologicalToJson",
    value: function scenarioDatumEpidemiologicalToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("ScenarioDatumEpidemiological")), null, 2);
    }
  }, {
    key: "toNumericRangeNonNegative",
    value: function toNumericRangeNonNegative(json) {
      return cast$1(JSON.parse(json), r$1("NumericRangeNonNegative"));
    }
  }, {
    key: "numericRangeNonNegativeToJson",
    value: function numericRangeNonNegativeToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("NumericRangeNonNegative")), null, 2);
    }
  }, {
    key: "toScenarioDatumMitigation",
    value: function toScenarioDatumMitigation(json) {
      return cast$1(JSON.parse(json), r$1("ScenarioDatumMitigation"));
    }
  }, {
    key: "scenarioDatumMitigationToJson",
    value: function scenarioDatumMitigationToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("ScenarioDatumMitigation")), null, 2);
    }
  }, {
    key: "toMitigationInterval",
    value: function toMitigationInterval(json) {
      return cast$1(JSON.parse(json), r$1("MitigationInterval"));
    }
  }, {
    key: "mitigationIntervalToJson",
    value: function mitigationIntervalToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("MitigationInterval")), null, 2);
    }
  }, {
    key: "toDateRange",
    value: function toDateRange(json) {
      return cast$1(JSON.parse(json), r$1("DateRange"));
    }
  }, {
    key: "dateRangeToJson",
    value: function dateRangeToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("DateRange")), null, 2);
    }
  }, {
    key: "toPercentageRange",
    value: function toPercentageRange(json) {
      return cast$1(JSON.parse(json), r$1("PercentageRange"));
    }
  }, {
    key: "percentageRangeToJson",
    value: function percentageRangeToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("PercentageRange")), null, 2);
    }
  }, {
    key: "toScenarioDatumPopulation",
    value: function toScenarioDatumPopulation(json) {
      return cast$1(JSON.parse(json), r$1("ScenarioDatumPopulation"));
    }
  }, {
    key: "scenarioDatumPopulationToJson",
    value: function scenarioDatumPopulationToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("ScenarioDatumPopulation")), null, 2);
    }
  }, {
    key: "toScenarioDatumSimulation",
    value: function toScenarioDatumSimulation(json) {
      return cast$1(JSON.parse(json), r$1("ScenarioDatumSimulation"));
    }
  }, {
    key: "scenarioDatumSimulationToJson",
    value: function scenarioDatumSimulationToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("ScenarioDatumSimulation")), null, 2);
    }
  }, {
    key: "toSeverityDistributionArray",
    value: function toSeverityDistributionArray(json) {
      return cast$1(JSON.parse(json), r$1("SeverityDistributionArray"));
    }
  }, {
    key: "severityDistributionArrayToJson",
    value: function severityDistributionArrayToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("SeverityDistributionArray")), null, 2);
    }
  }, {
    key: "toSeverityDistributionData",
    value: function toSeverityDistributionData(json) {
      return cast$1(JSON.parse(json), r$1("SeverityDistributionData"));
    }
  }, {
    key: "severityDistributionDataToJson",
    value: function severityDistributionDataToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("SeverityDistributionData")), null, 2);
    }
  }, {
    key: "toSeverityDistributionDatum",
    value: function toSeverityDistributionDatum(json) {
      return cast$1(JSON.parse(json), r$1("SeverityDistributionDatum"));
    }
  }, {
    key: "severityDistributionDatumToJson",
    value: function severityDistributionDatumToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("SeverityDistributionDatum")), null, 2);
    }
  }, {
    key: "toShareable",
    value: function toShareable(json) {
      return cast$1(JSON.parse(json), r$1("Shareable"));
    }
  }, {
    key: "shareableToJson",
    value: function shareableToJson(value) {
      return JSON.stringify(uncast$1(value, r$1("Shareable")), null, 2);
    }
  }]);

  return Convert;
}();

function invalidValue$1(typ, val) {
  throw Error("Invalid value ".concat(JSON.stringify(val), " for type ").concat(JSON.stringify(typ)));
}

function jsonToJSProps$1(typ) {
  if (typ.jsonToJS === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.json] = {
        key: p.js,
        typ: p.typ
      };
    });
    typ.jsonToJS = map;
  }

  return typ.jsonToJS;
}

function jsToJSONProps$1(typ) {
  if (typ.jsToJSON === undefined) {
    var map = {};
    typ.props.forEach(function (p) {
      return map[p.js] = {
        key: p.json,
        typ: p.typ
      };
    });
    typ.jsToJSON = map;
  }

  return typ.jsToJSON;
}

function transform$1(val, typ, getProps) {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue$1(typ, val);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    var l = typs.length;

    for (var i = 0; i < l; i++) {
      var _typ = typs[i];

      try {
        return transform$1(val, _typ, getProps);
      } catch (_) {}
    }

    return invalidValue$1(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue$1(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue$1("array", val);
    return val.map(function (el) {
      return transform$1(el, typ, getProps);
    });
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }

    var d = new Date(val);

    if (isNaN(d.valueOf())) {
      return invalidValue$1("Date", val);
    }

    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== "object" || Array.isArray(val)) {
      return invalidValue$1("object", val);
    }

    var result = {};
    Object.getOwnPropertyNames(props).forEach(function (key) {
      var prop = props[key];
      var v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform$1(v, prop.typ, getProps);
    });
    Object.getOwnPropertyNames(val).forEach(function (key) {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform$1(val[key], additional, getProps);
      }
    });
    return result;
  }

  if (typ === "any") return val;

  if (typ === null) {
    if (val === null) return val;
    return invalidValue$1(typ, val);
  }

  if (typ === false) return invalidValue$1(typ, val);

  while (typeof typ === "object" && typ.ref !== undefined) {
    typ = typeMap$1[typ.ref];
  }

  if (Array.isArray(typ)) return transformEnum(typ, val);

  if (typeof typ === "object") {
    return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val) : typ.hasOwnProperty("arrayItems") ? transformArray(typ.arrayItems, val) : typ.hasOwnProperty("props") ? transformObject(getProps(typ), typ.additional, val) : invalidValue$1(typ, val);
  } // Numbers can be parsed by Date but shouldn't be.


  if (typ === Date && typeof val !== "number") return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast$1(val, typ) {
  return transform$1(val, typ, jsonToJSProps$1);
}

function uncast$1(val, typ) {
  return transform$1(val, typ, jsToJSONProps$1);
}

function a$1(typ) {
  return {
    arrayItems: typ
  };
}

function u$c() {
  for (var _len = arguments.length, typs = new Array(_len), _key = 0; _key < _len; _key++) {
    typs[_key] = arguments[_key];
  }

  return {
    unionMembers: typs
  };
}

function o$1(props, additional) {
  return {
    props: props,
    additional: additional
  };
}

function r$1(name) {
  return {
    ref: name
  };
}

var typeMap$1 = {
  AgeDistributionArray: o$1([{
    json: "all",
    js: "all",
    typ: a$1(r$1("AgeDistributionData"))
  }], false),
  AgeDistributionData: o$1([{
    json: "data",
    js: "data",
    typ: a$1(r$1("AgeDistributionDatum"))
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  AgeDistributionDatum: o$1([{
    json: "ageGroup",
    js: "ageGroup",
    typ: r$1("AgeGroup")
  }, {
    json: "population",
    js: "population",
    typ: 0
  }], false),
  CaseCountsArray: o$1([{
    json: "all",
    js: "all",
    typ: a$1(r$1("CaseCountsData"))
  }], false),
  CaseCountsData: o$1([{
    json: "data",
    js: "data",
    typ: a$1(r$1("CaseCountsDatum"))
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  CaseCountsDatum: o$1([{
    json: "cases",
    js: "cases",
    typ: u$c(0, null)
  }, {
    json: "deaths",
    js: "deaths",
    typ: u$c(undefined, u$c(0, null))
  }, {
    json: "hospitalized",
    js: "hospitalized",
    typ: u$c(undefined, u$c(0, null))
  }, {
    json: "icu",
    js: "icu",
    typ: u$c(undefined, u$c(0, null))
  }, {
    json: "recovered",
    js: "recovered",
    typ: u$c(undefined, u$c(0, null))
  }, {
    json: "time",
    js: "time",
    typ: Date
  }], false),
  ScenarioArray: o$1([{
    json: "all",
    js: "all",
    typ: a$1(r$1("ScenarioData"))
  }], false),
  ScenarioData: o$1([{
    json: "data",
    js: "data",
    typ: r$1("ScenarioDatum")
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  ScenarioDatum: o$1([{
    json: "epidemiological",
    js: "epidemiological",
    typ: r$1("ScenarioDatumEpidemiological")
  }, {
    json: "mitigation",
    js: "mitigation",
    typ: r$1("ScenarioDatumMitigation")
  }, {
    json: "population",
    js: "population",
    typ: r$1("ScenarioDatumPopulation")
  }, {
    json: "simulation",
    js: "simulation",
    typ: r$1("ScenarioDatumSimulation")
  }], false),
  ScenarioDatumEpidemiological: o$1([{
    json: "hospitalStayDays",
    js: "hospitalStayDays",
    typ: 3.14
  }, {
    json: "icuStayDays",
    js: "icuStayDays",
    typ: 3.14
  }, {
    json: "infectiousPeriodDays",
    js: "infectiousPeriodDays",
    typ: 3.14
  }, {
    json: "latencyDays",
    js: "latencyDays",
    typ: 3.14
  }, {
    json: "overflowSeverity",
    js: "overflowSeverity",
    typ: 3.14
  }, {
    json: "peakMonth",
    js: "peakMonth",
    typ: 0
  }, {
    json: "r0",
    js: "r0",
    typ: r$1("NumericRangeNonNegative")
  }, {
    json: "seasonalForcing",
    js: "seasonalForcing",
    typ: 3.14
  }], false),
  NumericRangeNonNegative: o$1([{
    json: "begin",
    js: "begin",
    typ: 3.14
  }, {
    json: "end",
    js: "end",
    typ: 3.14
  }], false),
  ScenarioDatumMitigation: o$1([{
    json: "mitigationIntervals",
    js: "mitigationIntervals",
    typ: a$1(r$1("MitigationInterval"))
  }], false),
  MitigationInterval: o$1([{
    json: "color",
    js: "color",
    typ: ""
  }, {
    json: "name",
    js: "name",
    typ: ""
  }, {
    json: "timeRange",
    js: "timeRange",
    typ: r$1("DateRange")
  }, {
    json: "transmissionReduction",
    js: "transmissionReduction",
    typ: r$1("PercentageRange")
  }], false),
  DateRange: o$1([{
    json: "begin",
    js: "begin",
    typ: Date
  }, {
    json: "end",
    js: "end",
    typ: Date
  }], false),
  PercentageRange: o$1([{
    json: "begin",
    js: "begin",
    typ: 3.14
  }, {
    json: "end",
    js: "end",
    typ: 3.14
  }], false),
  ScenarioDatumPopulation: o$1([{
    json: "ageDistributionName",
    js: "ageDistributionName",
    typ: ""
  }, {
    json: "caseCountsName",
    js: "caseCountsName",
    typ: ""
  }, {
    json: "hospitalBeds",
    js: "hospitalBeds",
    typ: 0
  }, {
    json: "icuBeds",
    js: "icuBeds",
    typ: 0
  }, {
    json: "importsPerDay",
    js: "importsPerDay",
    typ: 3.14
  }, {
    json: "initialNumberOfCases",
    js: "initialNumberOfCases",
    typ: 0
  }, {
    json: "populationServed",
    js: "populationServed",
    typ: 0
  }], false),
  ScenarioDatumSimulation: o$1([{
    json: "numberStochasticRuns",
    js: "numberStochasticRuns",
    typ: 0
  }, {
    json: "simulationTimeRange",
    js: "simulationTimeRange",
    typ: r$1("DateRange")
  }], false),
  SeverityDistributionArray: o$1([{
    json: "all",
    js: "all",
    typ: a$1(r$1("SeverityDistributionData"))
  }], false),
  SeverityDistributionData: o$1([{
    json: "data",
    js: "data",
    typ: a$1(r$1("SeverityDistributionDatum"))
  }, {
    json: "name",
    js: "name",
    typ: ""
  }], false),
  SeverityDistributionDatum: o$1([{
    json: "ageGroup",
    js: "ageGroup",
    typ: r$1("AgeGroup")
  }, {
    json: "confirmed",
    js: "confirmed",
    typ: 3.14
  }, {
    json: "critical",
    js: "critical",
    typ: 3.14
  }, {
    json: "fatal",
    js: "fatal",
    typ: 3.14
  }, {
    json: "isolated",
    js: "isolated",
    typ: 3.14
  }, {
    json: "severe",
    js: "severe",
    typ: 3.14
  }], false),
  Shareable: o$1([{
    json: "ageDistributionData",
    js: "ageDistributionData",
    typ: r$1("AgeDistributionData")
  }, {
    json: "scenarioData",
    js: "scenarioData",
    typ: r$1("ScenarioData")
  }, {
    json: "schemaVer",
    js: "schemaVer",
    typ: ""
  }, {
    json: "severityDistributionData",
    js: "severityDistributionData",
    typ: r$1("SeverityDistributionData")
  }], false),
  AgeGroup: ["0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80+"]
};

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return _baseIsEqual(value, other);
}

var isEqual_1 = isEqual;

var formats$2 = formats_1();

var validate$3 = function () {
  var refVal = [];
  var refVal1 = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "_SchemaVer",
    title: "_SchemaVer",
    type: "string",
    "const": "2.1.0"
  };
  refVal[1] = refVal1;

  var refVal2 = function () {
    var refVal = [];

    var refVal1 = function () {
      var refVal = [];

      var refVal1 = function () {
        var refVal = [];
        var refVal1 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "IntegerNonNegative",
          title: "IntegerNonNegative",
          type: "integer",
          multipleOf: 1,
          minimum: 0
        };
        refVal[1] = refVal1;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "populationServed" || key0 == "ageDistributionName" || key0 == "caseCountsName" || key0 == "initialNumberOfCases" || key0 == "importsPerDay" || key0 == "hospitalBeds" || key0 == "icuBeds");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.populationServed;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "populationServed"
                },
                message: "should have required property 'populationServed'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/populationServed",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/populationServed",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/populationServed",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.ageDistributionName;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "ageDistributionName"
                },
                message: "should have required property 'ageDistributionName'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "string") {
                if (ucs2length(data1) < 1) {
                  var err = {
                    keyword: "minLength",
                    dataPath: (dataPath || "") + "/ageDistributionName",
                    schemaPath: "#/properties/ageDistributionName/minLength",
                    params: {
                      limit: 1
                    },
                    message: "should NOT be shorter than 1 characters"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/ageDistributionName",
                  schemaPath: "#/properties/ageDistributionName/type",
                  params: {
                    type: "string"
                  },
                  message: "should be string"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.caseCountsName;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "caseCountsName"
                },
                message: "should have required property 'caseCountsName'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "string") {
                if (ucs2length(data1) < 1) {
                  var err = {
                    keyword: "minLength",
                    dataPath: (dataPath || "") + "/caseCountsName",
                    schemaPath: "#/properties/caseCountsName/minLength",
                    params: {
                      limit: 1
                    },
                    message: "should NOT be shorter than 1 characters"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/caseCountsName",
                  schemaPath: "#/properties/caseCountsName/type",
                  params: {
                    type: "string"
                  },
                  message: "should be string"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.initialNumberOfCases;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "initialNumberOfCases"
                },
                message: "should have required property 'initialNumberOfCases'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/initialNumberOfCases",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/initialNumberOfCases",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/initialNumberOfCases",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.importsPerDay;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "importsPerDay"
                },
                message: "should have required property 'importsPerDay'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/importsPerDay",
                    schemaPath: "#/properties/importsPerDay/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/importsPerDay",
                  schemaPath: "#/properties/importsPerDay/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.hospitalBeds;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "hospitalBeds"
                },
                message: "should have required property 'hospitalBeds'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/hospitalBeds",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/hospitalBeds",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/hospitalBeds",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.icuBeds;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "icuBeds"
                },
                message: "should have required property 'icuBeds'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/icuBeds",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/icuBeds",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division2;

                if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/icuBeds",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal1.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumPopulation",
        title: "ScenarioDatumPopulation",
        type: "object",
        additionalProperties: false,
        required: ["populationServed", "ageDistributionName", "caseCountsName", "initialNumberOfCases", "importsPerDay", "hospitalBeds", "icuBeds"],
        properties: {
          populationServed: {
            $ref: "IntegerNonNegative#"
          },
          ageDistributionName: {
            type: "string",
            minLength: 1
          },
          caseCountsName: {
            type: "string",
            minLength: 1
          },
          initialNumberOfCases: {
            $ref: "IntegerNonNegative#"
          },
          importsPerDay: {
            type: "number",
            minimum: 0
          },
          hospitalBeds: {
            $ref: "IntegerNonNegative#"
          },
          icuBeds: {
            $ref: "IntegerNonNegative#"
          }
        }
      };
      refVal1.errors = null;
      refVal[1] = refVal1;

      var refVal2 = function () {
        var refVal = [];
        var refVal1 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "NumericRangeNonNegative",
          title: "NumericRangeNonNegative",
          type: "object",
          additionalProperties: false,
          required: ["begin", "end"],
          properties: {
            begin: {
              type: "number",
              minimum: 0,
              maximum: {
                $data: "1/end"
              }
            },
            end: {
              type: "number"
            }
          }
        };
        refVal[1] = refVal1;
        var refVal2 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "IntegerNonNegative",
          title: "IntegerNonNegative",
          type: "integer",
          multipleOf: 1,
          minimum: 0
        };
        refVal[2] = refVal2;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "r0" || key0 == "latencyDays" || key0 == "infectiousPeriodDays" || key0 == "hospitalStayDays" || key0 == "icuStayDays" || key0 == "seasonalForcing" || key0 == "peakMonth" || key0 == "overflowSeverity");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.r0;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "r0"
                },
                message: "should have required property 'r0'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {

                for (var key2 in data1) {
                  var isAdditional2 = !( key2 == "begin" || key2 == "end");

                  if (isAdditional2) {
                    var err = {
                      keyword: "additionalProperties",
                      dataPath: (dataPath || "") + "/r0",
                      schemaPath: "NumericRangeNonNegative#/additionalProperties",
                      params: {
                        additionalProperty: "" + key2 + ""
                      },
                      message: "should NOT have additional properties"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }

                var data2 = data1.begin;

                if (data2 === undefined) {
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/r0",
                    schemaPath: "NumericRangeNonNegative#/required",
                    params: {
                      missingProperty: "begin"
                    },
                    message: "should have required property 'begin'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {

                  if (typeof data2 === "number") {
                    var schema3 = data1 && data1.end;

                    if (schema3 !== undefined && typeof schema3 != "number" || data2 > schema3 || data2 !== data2) {
                      var err = {
                        keyword: "maximum",
                        dataPath: (dataPath || "") + "/r0/begin",
                        schemaPath: "NumericRangeNonNegative#/properties/begin/maximum",
                        params: {
                          comparison: "<=",
                          limit: schema3,
                          exclusive: false
                        },
                        message: "should be <= " + schema3
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    if (data2 < 0 || data2 !== data2) {
                      var err = {
                        keyword: "minimum",
                        dataPath: (dataPath || "") + "/r0/begin",
                        schemaPath: "NumericRangeNonNegative#/properties/begin/minimum",
                        params: {
                          comparison: ">=",
                          limit: 0,
                          exclusive: false
                        },
                        message: "should be >= 0"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/r0/begin",
                      schemaPath: "NumericRangeNonNegative#/properties/begin/type",
                      params: {
                        type: "number"
                      },
                      message: "should be number"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }

                if (data1.end === undefined) {
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/r0",
                    schemaPath: "NumericRangeNonNegative#/required",
                    params: {
                      missingProperty: "end"
                    },
                    message: "should have required property 'end'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {

                  if (typeof data1.end !== "number") {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/r0/end",
                      schemaPath: "NumericRangeNonNegative#/properties/end/type",
                      params: {
                        type: "number"
                      },
                      message: "should be number"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/r0",
                  schemaPath: "NumericRangeNonNegative#/type",
                  params: {
                    type: "object"
                  },
                  message: "should be object"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.latencyDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "latencyDays"
                },
                message: "should have required property 'latencyDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/latencyDays",
                    schemaPath: "#/properties/latencyDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/latencyDays",
                  schemaPath: "#/properties/latencyDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.infectiousPeriodDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "infectiousPeriodDays"
                },
                message: "should have required property 'infectiousPeriodDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/infectiousPeriodDays",
                    schemaPath: "#/properties/infectiousPeriodDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/infectiousPeriodDays",
                  schemaPath: "#/properties/infectiousPeriodDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.hospitalStayDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "hospitalStayDays"
                },
                message: "should have required property 'hospitalStayDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/hospitalStayDays",
                    schemaPath: "#/properties/hospitalStayDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/hospitalStayDays",
                  schemaPath: "#/properties/hospitalStayDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.icuStayDays;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "icuStayDays"
                },
                message: "should have required property 'icuStayDays'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 1 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/icuStayDays",
                    schemaPath: "#/properties/icuStayDays/minimum",
                    params: {
                      comparison: ">=",
                      limit: 1,
                      exclusive: false
                    },
                    message: "should be >= 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/icuStayDays",
                  schemaPath: "#/properties/icuStayDays/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.seasonalForcing;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "seasonalForcing"
                },
                message: "should have required property 'seasonalForcing'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/seasonalForcing",
                    schemaPath: "#/properties/seasonalForcing/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/seasonalForcing",
                  schemaPath: "#/properties/seasonalForcing/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.peakMonth;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "peakMonth"
                },
                message: "should have required property 'peakMonth'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/peakMonth",
                  schemaPath: "IntegerNonNegative#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/peakMonth",
                    schemaPath: "IntegerNonNegative#/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                var division3;

                if (division3 = data1 / 1, division3 !== parseInt(division3)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/peakMonth",
                    schemaPath: "IntegerNonNegative#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              if (typeof data1 === "number") {
                if (data1 > 11 || data1 !== data1) {
                  var err = {
                    keyword: "maximum",
                    dataPath: (dataPath || "") + "/peakMonth",
                    schemaPath: "#/properties/peakMonth/allOf/1/maximum",
                    params: {
                      comparison: "<=",
                      limit: 11,
                      exclusive: false
                    },
                    message: "should be <= 11"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }

            var data1 = data.overflowSeverity;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "overflowSeverity"
                },
                message: "should have required property 'overflowSeverity'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (typeof data1 === "number") {
                if (data1 < 0 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/overflowSeverity",
                    schemaPath: "#/properties/overflowSeverity/minimum",
                    params: {
                      comparison: ">=",
                      limit: 0,
                      exclusive: false
                    },
                    message: "should be >= 0"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/overflowSeverity",
                  schemaPath: "#/properties/overflowSeverity/type",
                  params: {
                    type: "number"
                  },
                  message: "should be number"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal2.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumEpidemiological",
        title: "ScenarioDatumEpidemiological",
        type: "object",
        additionalProperties: false,
        required: ["r0", "latencyDays", "infectiousPeriodDays", "hospitalStayDays", "icuStayDays", "seasonalForcing", "peakMonth", "overflowSeverity"],
        properties: {
          r0: {
            $ref: "NumericRangeNonNegative#"
          },
          latencyDays: {
            type: "number",
            minimum: 1
          },
          infectiousPeriodDays: {
            type: "number",
            minimum: 1
          },
          hospitalStayDays: {
            type: "number",
            minimum: 1
          },
          icuStayDays: {
            type: "number",
            minimum: 1
          },
          seasonalForcing: {
            type: "number",
            minimum: 0
          },
          peakMonth: {
            allOf: [{
              $ref: "IntegerNonNegative#"
            }, {
              maximum: 11
            }]
          },
          overflowSeverity: {
            type: "number",
            minimum: 0
          }
        }
      };
      refVal2.errors = null;
      refVal[2] = refVal2;

      var refVal3 = function () {
        var refVal = [];
        var refVal1 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "DateRange",
          title: "DateRange",
          type: "object",
          additionalProperties: false,
          required: ["begin", "end"],
          properties: {
            begin: {
              oneOf: [{
                type: "string",
                format: "date"
              }, {
                type: "string",
                format: "date-time"
              }],
              formatMaximum: {
                $data: "1/end"
              }
            },
            end: {
              oneOf: [{
                type: "string",
                format: "date"
              }, {
                type: "string",
                format: "date-time"
              }]
            }
          }
        };
        refVal[1] = refVal1;
        var refVal2 = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "Integer",
          title: "Integer",
          type: "integer",
          multipleOf: 1
        };
        refVal[2] = refVal2;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "simulationTimeRange" || key0 == "numberStochasticRuns");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.simulationTimeRange;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "simulationTimeRange"
                },
                message: "should have required property 'simulationTimeRange'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                var valid3 = true;

                for (var key2 in data1) {
                  var isAdditional2 = !( key2 == "begin" || key2 == "end");

                  if (isAdditional2) {
                    valid3 = false;
                    var err = {
                      keyword: "additionalProperties",
                      dataPath: (dataPath || "") + "/simulationTimeRange",
                      schemaPath: "DateRange#/additionalProperties",
                      params: {
                        additionalProperty: "" + key2 + ""
                      },
                      message: "should NOT have additional properties"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                }

                var data2 = data1.begin;

                if (data2 === undefined) {
                  valid3 = false;
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/simulationTimeRange",
                    schemaPath: "DateRange#/required",
                    params: {
                      missingProperty: "begin"
                    },
                    message: "should have required property 'begin'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {
                  var errs_3 = errors;
                  var errs__3 = errors,
                      prevValid3 = false,
                      valid3 = false,
                      passingSchemas3 = null;
                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$2.date.test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/0/format",
                        params: {
                          format: "date"
                        },
                        message: 'should match format "date"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                      schemaPath: "DateRange#/properties/begin/oneOf/0/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4) {
                    valid3 = prevValid3 = true;
                    passingSchemas3 = 0;
                  }

                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$2["date-time"].test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/1/format",
                        params: {
                          format: "date-time"
                        },
                        message: 'should match format "date-time"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                      schemaPath: "DateRange#/properties/begin/oneOf/1/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4 && prevValid3) {
                    valid3 = false;
                    passingSchemas3 = [passingSchemas3, 1];
                  } else {
                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 1;
                    }
                  }

                  if (!valid3) {
                    var err = {
                      keyword: "oneOf",
                      dataPath: (dataPath || "") + "/simulationTimeRange/begin",
                      schemaPath: "DateRange#/properties/begin/oneOf",
                      params: {
                        passingSchemas: passingSchemas3
                      },
                      message: "should match exactly one schema in oneOf"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    errors = errs__3;

                    if (vErrors !== null) {
                      if (errs__3) vErrors.length = errs__3;else vErrors = null;
                    }
                  }

                  var valid3 = errors === errs_3;
                }

                var data2 = data1.end;

                if (data2 === undefined) {
                  valid3 = false;
                  var err = {
                    keyword: "required",
                    dataPath: (dataPath || "") + "/simulationTimeRange",
                    schemaPath: "DateRange#/required",
                    params: {
                      missingProperty: "end"
                    },
                    message: "should have required property 'end'"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                } else {
                  var errs_3 = errors;
                  var errs__3 = errors,
                      prevValid3 = false,
                      valid3 = false,
                      passingSchemas3 = null;
                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$2.date.test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/0/format",
                        params: {
                          format: "date"
                        },
                        message: 'should match format "date"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/end",
                      schemaPath: "DateRange#/properties/end/oneOf/0/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4) {
                    valid3 = prevValid3 = true;
                    passingSchemas3 = 0;
                  }

                  var errs_4 = errors;

                  if (typeof data2 === "string") {
                    if (!formats$2["date-time"].test(data2)) {
                      var err = {
                        keyword: "format",
                        dataPath: (dataPath || "") + "/simulationTimeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/1/format",
                        params: {
                          format: "date-time"
                        },
                        message: 'should match format "date-time"'
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  } else {
                    var err = {
                      keyword: "type",
                      dataPath: (dataPath || "") + "/simulationTimeRange/end",
                      schemaPath: "DateRange#/properties/end/oneOf/1/type",
                      params: {
                        type: "string"
                      },
                      message: "should be string"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }

                  var valid4 = errors === errs_4;

                  if (valid4 && prevValid3) {
                    valid3 = false;
                    passingSchemas3 = [passingSchemas3, 1];
                  } else {
                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 1;
                    }
                  }

                  if (!valid3) {
                    var err = {
                      keyword: "oneOf",
                      dataPath: (dataPath || "") + "/simulationTimeRange/end",
                      schemaPath: "DateRange#/properties/end/oneOf",
                      params: {
                        passingSchemas: passingSchemas3
                      },
                      message: "should match exactly one schema in oneOf"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    errors = errs__3;

                    if (vErrors !== null) {
                      if (errs__3) vErrors.length = errs__3;else vErrors = null;
                    }
                  }

                  var valid3 = errors === errs_3;
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/simulationTimeRange",
                  schemaPath: "DateRange#/type",
                  params: {
                    type: "object"
                  },
                  message: "should be object"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.numberStochasticRuns;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "numberStochasticRuns"
                },
                message: "should have required property 'numberStochasticRuns'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {
              var errs_3 = errors;

              if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/numberStochasticRuns",
                  schemaPath: "Integer#/type",
                  params: {
                    type: "integer"
                  },
                  message: "should be integer"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (typeof data1 === "number") {
                var division3;

                if (division3 = data1 / 1, division3 !== parseInt(division3)) {
                  var err = {
                    keyword: "multipleOf",
                    dataPath: (dataPath || "") + "/numberStochasticRuns",
                    schemaPath: "Integer#/multipleOf",
                    params: {
                      multipleOf: 1
                    },
                    message: "should be multiple of 1"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var valid3 = errors === errs_3;

              if (typeof data1 === "number") {
                if (data1 > 100 || data1 !== data1) {
                  var err = {
                    keyword: "maximum",
                    dataPath: (dataPath || "") + "/numberStochasticRuns",
                    schemaPath: "#/properties/numberStochasticRuns/allOf/1/maximum",
                    params: {
                      comparison: "<=",
                      limit: 100,
                      exclusive: false
                    },
                    message: "should be <= 100"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }

                if (data1 < 10 || data1 !== data1) {
                  var err = {
                    keyword: "minimum",
                    dataPath: (dataPath || "") + "/numberStochasticRuns",
                    schemaPath: "#/properties/numberStochasticRuns/allOf/1/minimum",
                    params: {
                      comparison: ">=",
                      limit: 10,
                      exclusive: false
                    },
                    message: "should be >= 10"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal3.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumSimulation",
        title: "ScenarioDatumSimulation",
        type: "object",
        additionalProperties: false,
        required: ["simulationTimeRange", "numberStochasticRuns"],
        properties: {
          simulationTimeRange: {
            $ref: "DateRange#"
          },
          numberStochasticRuns: {
            allOf: [{
              $ref: "Integer#"
            }, {
              minimum: 10,
              maximum: 100
            }]
          }
        }
      };
      refVal3.errors = null;
      refVal[3] = refVal3;

      var refVal4 = function () {
        var refVal = [];

        var refVal1 = function () {
          var pattern0 = new RegExp("^#(?:[0-9a-fA-F]{3}){1,2}$");
          var refVal = [];
          var refVal1 = {
            $schema: "http://json-schema.org/draft-07/schema",
            $id: "ColorHex",
            title: "ColorHex",
            type: "string",
            pattern: "^#(?:[0-9a-fA-F]{3}){1,2}$"
          };
          refVal[1] = refVal1;
          var refVal2 = {
            $schema: "http://json-schema.org/draft-07/schema",
            $id: "DateRange",
            title: "DateRange",
            type: "object",
            additionalProperties: false,
            required: ["begin", "end"],
            properties: {
              begin: {
                oneOf: [{
                  type: "string",
                  format: "date"
                }, {
                  type: "string",
                  format: "date-time"
                }],
                formatMaximum: {
                  $data: "1/end"
                }
              },
              end: {
                oneOf: [{
                  type: "string",
                  format: "date"
                }, {
                  type: "string",
                  format: "date-time"
                }]
              }
            }
          };
          refVal[2] = refVal2;
          var refVal3 = {
            $schema: "http://json-schema.org/draft-07/schema",
            $id: "PercentageRange",
            title: "PercentageRange",
            type: "object",
            additionalProperties: false,
            required: ["begin", "end"],
            properties: {
              begin: {
                type: "number",
                minimum: 0,
                maximum: {
                  $data: "1/end"
                }
              },
              end: {
                type: "number",
                maximum: 100
              }
            }
          };
          refVal[3] = refVal3;
          return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

            var vErrors = null;
            var errors = 0;

            if (data && typeof data === "object" && !Array.isArray(data)) {

              for (var key0 in data) {
                var isAdditional0 = !( key0 == "name" || key0 == "color" || key0 == "timeRange" || key0 == "transmissionReduction");

                if (isAdditional0) {
                  var err = {
                    keyword: "additionalProperties",
                    dataPath: (dataPath || "") + "",
                    schemaPath: "#/additionalProperties",
                    params: {
                      additionalProperty: "" + key0 + ""
                    },
                    message: "should NOT have additional properties"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.name;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "name"
                  },
                  message: "should have required property 'name'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (typeof data1 === "string") {
                  if (ucs2length(data1) < 1) {
                    var err = {
                      keyword: "minLength",
                      dataPath: (dataPath || "") + "/name",
                      schemaPath: "#/properties/name/minLength",
                      params: {
                        limit: 1
                      },
                      message: "should NOT be shorter than 1 characters"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/name",
                    schemaPath: "#/properties/name/type",
                    params: {
                      type: "string"
                    },
                    message: "should be string"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.color;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "color"
                  },
                  message: "should have required property 'color'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (typeof data1 === "string") {
                  if (!pattern0.test(data1)) {
                    var err = {
                      keyword: "pattern",
                      dataPath: (dataPath || "") + "/color",
                      schemaPath: "ColorHex#/pattern",
                      params: {
                        pattern: "^#(?:[0-9a-fA-F]{3}){1,2}$"
                      },
                      message: 'should match pattern "^#(?:[0-9a-fA-F]{3}){1,2}$"'
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/color",
                    schemaPath: "ColorHex#/type",
                    params: {
                      type: "string"
                    },
                    message: "should be string"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.timeRange;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "timeRange"
                  },
                  message: "should have required property 'timeRange'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                  var valid3 = true;

                  for (var key2 in data1) {
                    var isAdditional2 = !( key2 == "begin" || key2 == "end");

                    if (isAdditional2) {
                      valid3 = false;
                      var err = {
                        keyword: "additionalProperties",
                        dataPath: (dataPath || "") + "/timeRange",
                        schemaPath: "DateRange#/additionalProperties",
                        params: {
                          additionalProperty: "" + key2 + ""
                        },
                        message: "should NOT have additional properties"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  }

                  var data2 = data1.begin;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/timeRange",
                      schemaPath: "DateRange#/required",
                      params: {
                        missingProperty: "begin"
                      },
                      message: "should have required property 'begin'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;
                    var errs__3 = errors,
                        prevValid3 = false,
                        valid3 = false,
                        passingSchemas3 = null;
                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$2.date.test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/begin",
                          schemaPath: "DateRange#/properties/begin/oneOf/0/format",
                          params: {
                            format: "date"
                          },
                          message: 'should match format "date"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/0/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 0;
                    }

                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$2["date-time"].test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/begin",
                          schemaPath: "DateRange#/properties/begin/oneOf/1/format",
                          params: {
                            format: "date-time"
                          },
                          message: 'should match format "date-time"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf/1/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4 && prevValid3) {
                      valid3 = false;
                      passingSchemas3 = [passingSchemas3, 1];
                    } else {
                      if (valid4) {
                        valid3 = prevValid3 = true;
                        passingSchemas3 = 1;
                      }
                    }

                    if (!valid3) {
                      var err = {
                        keyword: "oneOf",
                        dataPath: (dataPath || "") + "/timeRange/begin",
                        schemaPath: "DateRange#/properties/begin/oneOf",
                        params: {
                          passingSchemas: passingSchemas3
                        },
                        message: "should match exactly one schema in oneOf"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    } else {
                      errors = errs__3;

                      if (vErrors !== null) {
                        if (errs__3) vErrors.length = errs__3;else vErrors = null;
                      }
                    }

                    var valid3 = errors === errs_3;
                  }

                  var data2 = data1.end;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/timeRange",
                      schemaPath: "DateRange#/required",
                      params: {
                        missingProperty: "end"
                      },
                      message: "should have required property 'end'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;
                    var errs__3 = errors,
                        prevValid3 = false,
                        valid3 = false,
                        passingSchemas3 = null;
                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$2.date.test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/end",
                          schemaPath: "DateRange#/properties/end/oneOf/0/format",
                          params: {
                            format: "date"
                          },
                          message: 'should match format "date"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/0/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4) {
                      valid3 = prevValid3 = true;
                      passingSchemas3 = 0;
                    }

                    var errs_4 = errors;

                    if (typeof data2 === "string") {
                      if (!formats$2["date-time"].test(data2)) {
                        var err = {
                          keyword: "format",
                          dataPath: (dataPath || "") + "/timeRange/end",
                          schemaPath: "DateRange#/properties/end/oneOf/1/format",
                          params: {
                            format: "date-time"
                          },
                          message: 'should match format "date-time"'
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/timeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf/1/type",
                        params: {
                          type: "string"
                        },
                        message: "should be string"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid4 = errors === errs_4;

                    if (valid4 && prevValid3) {
                      valid3 = false;
                      passingSchemas3 = [passingSchemas3, 1];
                    } else {
                      if (valid4) {
                        valid3 = prevValid3 = true;
                        passingSchemas3 = 1;
                      }
                    }

                    if (!valid3) {
                      var err = {
                        keyword: "oneOf",
                        dataPath: (dataPath || "") + "/timeRange/end",
                        schemaPath: "DateRange#/properties/end/oneOf",
                        params: {
                          passingSchemas: passingSchemas3
                        },
                        message: "should match exactly one schema in oneOf"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    } else {
                      errors = errs__3;

                      if (vErrors !== null) {
                        if (errs__3) vErrors.length = errs__3;else vErrors = null;
                      }
                    }

                    var valid3 = errors === errs_3;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/timeRange",
                    schemaPath: "DateRange#/type",
                    params: {
                      type: "object"
                    },
                    message: "should be object"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }

              var data1 = data.transmissionReduction;

              if (data1 === undefined) {
                var err = {
                  keyword: "required",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/required",
                  params: {
                    missingProperty: "transmissionReduction"
                  },
                  message: "should have required property 'transmissionReduction'"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              } else {

                if (data1 && typeof data1 === "object" && !Array.isArray(data1)) {
                  var valid3 = true;

                  for (var key2 in data1) {
                    var isAdditional2 = !( key2 == "begin" || key2 == "end");

                    if (isAdditional2) {
                      valid3 = false;
                      var err = {
                        keyword: "additionalProperties",
                        dataPath: (dataPath || "") + "/transmissionReduction",
                        schemaPath: "PercentageRange#/additionalProperties",
                        params: {
                          additionalProperty: "" + key2 + ""
                        },
                        message: "should NOT have additional properties"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }
                  }

                  var data2 = data1.begin;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/transmissionReduction",
                      schemaPath: "PercentageRange#/required",
                      params: {
                        missingProperty: "begin"
                      },
                      message: "should have required property 'begin'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;

                    if (typeof data2 === "number") {
                      var schema3 = data1 && data1.end;

                      if (schema3 !== undefined && typeof schema3 != "number" || data2 > schema3 || data2 !== data2) {
                        var err = {
                          keyword: "maximum",
                          dataPath: (dataPath || "") + "/transmissionReduction/begin",
                          schemaPath: "PercentageRange#/properties/begin/maximum",
                          params: {
                            comparison: "<=",
                            limit: schema3,
                            exclusive: false
                          },
                          message: "should be <= " + schema3
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }

                      if (data2 < 0 || data2 !== data2) {
                        var err = {
                          keyword: "minimum",
                          dataPath: (dataPath || "") + "/transmissionReduction/begin",
                          schemaPath: "PercentageRange#/properties/begin/minimum",
                          params: {
                            comparison: ">=",
                            limit: 0,
                            exclusive: false
                          },
                          message: "should be >= 0"
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/transmissionReduction/begin",
                        schemaPath: "PercentageRange#/properties/begin/type",
                        params: {
                          type: "number"
                        },
                        message: "should be number"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid3 = errors === errs_3;
                  }

                  var data2 = data1.end;

                  if (data2 === undefined) {
                    valid3 = false;
                    var err = {
                      keyword: "required",
                      dataPath: (dataPath || "") + "/transmissionReduction",
                      schemaPath: "PercentageRange#/required",
                      params: {
                        missingProperty: "end"
                      },
                      message: "should have required property 'end'"
                    };
                    if (vErrors === null) vErrors = [err];else vErrors.push(err);
                    errors++;
                  } else {
                    var errs_3 = errors;

                    if (typeof data2 === "number") {
                      if (data2 > 100 || data2 !== data2) {
                        var err = {
                          keyword: "maximum",
                          dataPath: (dataPath || "") + "/transmissionReduction/end",
                          schemaPath: "PercentageRange#/properties/end/maximum",
                          params: {
                            comparison: "<=",
                            limit: 100,
                            exclusive: false
                          },
                          message: "should be <= 100"
                        };
                        if (vErrors === null) vErrors = [err];else vErrors.push(err);
                        errors++;
                      }
                    } else {
                      var err = {
                        keyword: "type",
                        dataPath: (dataPath || "") + "/transmissionReduction/end",
                        schemaPath: "PercentageRange#/properties/end/type",
                        params: {
                          type: "number"
                        },
                        message: "should be number"
                      };
                      if (vErrors === null) vErrors = [err];else vErrors.push(err);
                      errors++;
                    }

                    var valid3 = errors === errs_3;
                  }
                } else {
                  var err = {
                    keyword: "type",
                    dataPath: (dataPath || "") + "/transmissionReduction",
                    schemaPath: "PercentageRange#/type",
                    params: {
                      type: "object"
                    },
                    message: "should be object"
                  };
                  if (vErrors === null) vErrors = [err];else vErrors.push(err);
                  errors++;
                }
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/type",
                params: {
                  type: "object"
                },
                message: "should be object"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            validate.errors = vErrors;
            return errors === 0;
          };
        }();

        refVal1.schema = {
          $schema: "http://json-schema.org/draft-07/schema",
          $id: "MitigationInterval",
          title: "MitigationInterval",
          type: "object",
          additionalProperties: false,
          required: ["name", "color", "timeRange", "transmissionReduction"],
          properties: {
            name: {
              type: "string",
              minLength: 1
            },
            color: {
              $ref: "ColorHex#"
            },
            timeRange: {
              $ref: "DateRange#"
            },
            transmissionReduction: {
              $ref: "PercentageRange#"
            }
          }
        };
        refVal1.errors = null;
        refVal[1] = refVal1;
        return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

          var vErrors = null;
          var errors = 0;
          if (rootData === undefined) rootData = data;

          if (data && typeof data === "object" && !Array.isArray(data)) {

            for (var key0 in data) {
              var isAdditional0 = !( key0 == "mitigationIntervals");

              if (isAdditional0) {
                var err = {
                  keyword: "additionalProperties",
                  dataPath: (dataPath || "") + "",
                  schemaPath: "#/additionalProperties",
                  params: {
                    additionalProperty: "" + key0 + ""
                  },
                  message: "should NOT have additional properties"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var data1 = data.mitigationIntervals;

            if (data1 === undefined) {
              var err = {
                keyword: "required",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/required",
                params: {
                  missingProperty: "mitigationIntervals"
                },
                message: "should have required property 'mitigationIntervals'"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            } else {

              if (Array.isArray(data1)) {

                for (var i1 = 0; i1 < data1.length; i1++) {

                  if (!refVal1(data1[i1], (dataPath || "") + "/mitigationIntervals/" + i1, data1, i1, rootData)) {
                    if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
                    errors = vErrors.length;
                  }
                }
              } else {
                var err = {
                  keyword: "type",
                  dataPath: (dataPath || "") + "/mitigationIntervals",
                  schemaPath: "#/properties/mitigationIntervals/type",
                  params: {
                    type: "array"
                  },
                  message: "should be array"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/type",
              params: {
                type: "object"
              },
              message: "should be object"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }

          validate.errors = vErrors;
          return errors === 0;
        };
      }();

      refVal4.schema = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "ScenarioDatumMitigation",
        title: "ScenarioDatumMitigation",
        type: "object",
        additionalProperties: false,
        required: ["mitigationIntervals"],
        properties: {
          mitigationIntervals: {
            type: "array",
            items: {
              $ref: "MitigationInterval#"
            }
          }
        }
      };
      refVal4.errors = null;
      refVal[4] = refVal4;
      return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

        var vErrors = null;
        var errors = 0;
        if (rootData === undefined) rootData = data;

        if (data && typeof data === "object" && !Array.isArray(data)) {

          for (var key0 in data) {
            var isAdditional0 = !( key0 == "population" || key0 == "epidemiological" || key0 == "simulation" || key0 == "mitigation");

            if (isAdditional0) {
              var err = {
                keyword: "additionalProperties",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/additionalProperties",
                params: {
                  additionalProperty: "" + key0 + ""
                },
                message: "should NOT have additional properties"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          }

          if (data.population === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "population"
              },
              message: "should have required property 'population'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal1(data.population, (dataPath || "") + "/population", data, "population", rootData)) {
              if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
              errors = vErrors.length;
            }
          }

          if (data.epidemiological === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "epidemiological"
              },
              message: "should have required property 'epidemiological'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal2(data.epidemiological, (dataPath || "") + "/epidemiological", data, "epidemiological", rootData)) {
              if (vErrors === null) vErrors = refVal2.errors;else vErrors = vErrors.concat(refVal2.errors);
              errors = vErrors.length;
            }
          }

          if (data.simulation === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "simulation"
              },
              message: "should have required property 'simulation'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal3(data.simulation, (dataPath || "") + "/simulation", data, "simulation", rootData)) {
              if (vErrors === null) vErrors = refVal3.errors;else vErrors = vErrors.concat(refVal3.errors);
              errors = vErrors.length;
            }
          }

          if (data.mitigation === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "mitigation"
              },
              message: "should have required property 'mitigation'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {

            if (!refVal4(data.mitigation, (dataPath || "") + "/mitigation", data, "mitigation", rootData)) {
              if (vErrors === null) vErrors = refVal4.errors;else vErrors = vErrors.concat(refVal4.errors);
              errors = vErrors.length;
            }
          }
        } else {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/type",
            params: {
              type: "object"
            },
            message: "should be object"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        validate.errors = vErrors;
        return errors === 0;
      };
    }();

    refVal1.schema = {
      $schema: "http://json-schema.org/draft-07/schema",
      $id: "ScenarioDatum",
      title: "ScenarioDatum",
      type: "object",
      additionalProperties: false,
      required: ["population", "epidemiological", "simulation", "mitigation"],
      properties: {
        population: {
          $ref: "ScenarioDatumPopulation#"
        },
        epidemiological: {
          $ref: "ScenarioDatumEpidemiological#"
        },
        simulation: {
          $ref: "ScenarioDatumSimulation#"
        },
        mitigation: {
          $ref: "ScenarioDatumMitigation#"
        }
      }
    };
    refVal1.errors = null;
    refVal[1] = refVal1;
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

      var vErrors = null;
      var errors = 0;
      if (rootData === undefined) rootData = data;

      if (data && typeof data === "object" && !Array.isArray(data)) {

        for (var key0 in data) {
          var isAdditional0 = !( key0 == "name" || key0 == "data");

          if (isAdditional0) {
            var err = {
              keyword: "additionalProperties",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/additionalProperties",
              params: {
                additionalProperty: "" + key0 + ""
              },
              message: "should NOT have additional properties"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.name;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "name"
            },
            message: "should have required property 'name'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (typeof data1 === "string") {
            if (ucs2length(data1) < 1) {
              var err = {
                keyword: "minLength",
                dataPath: (dataPath || "") + "/name",
                schemaPath: "#/properties/name/minLength",
                params: {
                  limit: 1
                },
                message: "should NOT be shorter than 1 characters"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/name",
              schemaPath: "#/properties/name/type",
              params: {
                type: "string"
              },
              message: "should be string"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        if (data.data === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "data"
            },
            message: "should have required property 'data'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (!refVal1(data.data, (dataPath || "") + "/data", data, "data", rootData)) {
            if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
            errors = vErrors.length;
          }
        }
      } else {
        var err = {
          keyword: "type",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/type",
          params: {
            type: "object"
          },
          message: "should be object"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      }

      validate.errors = vErrors;
      return errors === 0;
    };
  }();

  refVal2.schema = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "ScenarioData",
    title: "ScenarioData",
    type: "object",
    additionalProperties: false,
    required: ["name", "data"],
    properties: {
      name: {
        type: "string",
        minLength: 1
      },
      data: {
        $ref: "ScenarioDatum#"
      }
    }
  };
  refVal2.errors = null;
  refVal[2] = refVal2;

  var refVal3 = function () {
    var refVal = [];

    var refVal1 = function () {
      var refVal = [];
      var refVal1 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "AgeGroup",
        title: "AgeGroup",
        type: "string",
        "enum": ["0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80+"]
      };
      refVal[1] = refVal1;
      var refVal2 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "IntegerNonNegative",
        title: "IntegerNonNegative",
        type: "integer",
        multipleOf: 1,
        minimum: 0
      };
      refVal[2] = refVal2;
      return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

        var vErrors = null;
        var errors = 0;

        if (data && typeof data === "object" && !Array.isArray(data)) {

          for (var key0 in data) {
            var isAdditional0 = !( key0 == "ageGroup" || key0 == "population");

            if (isAdditional0) {
              var err = {
                keyword: "additionalProperties",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/additionalProperties",
                params: {
                  additionalProperty: "" + key0 + ""
                },
                message: "should NOT have additional properties"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          }

          var data1 = data.ageGroup;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "ageGroup"
              },
              message: "should have required property 'ageGroup'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 !== "string") {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/type",
                params: {
                  type: "string"
                },
                message: "should be string"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var schema2 = refVal1["enum"];
            var valid2;
            valid2 = false;

            for (var i2 = 0; i2 < schema2.length; i2++) {
              if (equal(data1, schema2[i2])) {
                valid2 = true;
                break;
              }
            }

            if (!valid2) {
              var err = {
                keyword: "enum",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/enum",
                params: {
                  allowedValues: schema2
                },
                message: "should be equal to one of the allowed values"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.population;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "population"
              },
              message: "should have required property 'population'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 !== "number" || data1 % 1 || data1 !== data1) {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/population",
                schemaPath: "IntegerNonNegative#/type",
                params: {
                  type: "integer"
                },
                message: "should be integer"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            if (typeof data1 === "number") {
              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/population",
                  schemaPath: "IntegerNonNegative#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              var division2;

              if (division2 = data1 / 1, division2 !== parseInt(division2)) {
                var err = {
                  keyword: "multipleOf",
                  dataPath: (dataPath || "") + "/population",
                  schemaPath: "IntegerNonNegative#/multipleOf",
                  params: {
                    multipleOf: 1
                  },
                  message: "should be multiple of 1"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            }

            var valid2 = errors === errs_2;
          }
        } else {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/type",
            params: {
              type: "object"
            },
            message: "should be object"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        validate.errors = vErrors;
        return errors === 0;
      };
    }();

    refVal1.schema = {
      $schema: "http://json-schema.org/draft-07/schema",
      $id: "AgeDistributionDatum",
      title: "AgeDistributionDatum",
      type: "object",
      additionalProperties: false,
      required: ["ageGroup", "population"],
      properties: {
        ageGroup: {
          $ref: "AgeGroup#"
        },
        population: {
          $ref: "IntegerNonNegative#"
        }
      }
    };
    refVal1.errors = null;
    refVal[1] = refVal1;
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

      var vErrors = null;
      var errors = 0;
      if (rootData === undefined) rootData = data;

      if (data && typeof data === "object" && !Array.isArray(data)) {

        for (var key0 in data) {
          var isAdditional0 = !( key0 == "name" || key0 == "data");

          if (isAdditional0) {
            var err = {
              keyword: "additionalProperties",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/additionalProperties",
              params: {
                additionalProperty: "" + key0 + ""
              },
              message: "should NOT have additional properties"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.name;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "name"
            },
            message: "should have required property 'name'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (typeof data1 === "string") {
            if (ucs2length(data1) < 1) {
              var err = {
                keyword: "minLength",
                dataPath: (dataPath || "") + "/name",
                schemaPath: "#/properties/name/minLength",
                params: {
                  limit: 1
                },
                message: "should NOT be shorter than 1 characters"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/name",
              schemaPath: "#/properties/name/type",
              params: {
                type: "string"
              },
              message: "should be string"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.data;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "data"
            },
            message: "should have required property 'data'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (Array.isArray(data1)) {

            for (var i1 = 0; i1 < data1.length; i1++) {

              if (!refVal1(data1[i1], (dataPath || "") + "/data/" + i1, data1, i1, rootData)) {
                if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
                errors = vErrors.length;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/data",
              schemaPath: "#/properties/data/type",
              params: {
                type: "array"
              },
              message: "should be array"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }
      } else {
        var err = {
          keyword: "type",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/type",
          params: {
            type: "object"
          },
          message: "should be object"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      }

      validate.errors = vErrors;
      return errors === 0;
    };
  }();

  refVal3.schema = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "AgeDistributionData",
    title: "AgeDistributionData",
    type: "object",
    additionalProperties: false,
    required: ["name", "data"],
    properties: {
      name: {
        type: "string",
        minLength: 1
      },
      data: {
        type: "array",
        items: {
          $ref: "AgeDistributionDatum#"
        }
      }
    }
  };
  refVal3.errors = null;
  refVal[3] = refVal3;

  var refVal4 = function () {
    var refVal = [];

    var refVal1 = function () {
      var refVal = [];
      var refVal1 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "AgeGroup",
        title: "AgeGroup",
        type: "string",
        "enum": ["0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80+"]
      };
      refVal[1] = refVal1;
      var refVal2 = {
        $schema: "http://json-schema.org/draft-07/schema",
        $id: "Percentage",
        title: "Percentage",
        type: "number",
        minimum: 0,
        maximum: 100
      };
      refVal[2] = refVal2;
      return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

        var vErrors = null;
        var errors = 0;

        if (data && typeof data === "object" && !Array.isArray(data)) {

          for (var key0 in data) {
            var isAdditional0 = !( key0 == "ageGroup" || key0 == "isolated" || key0 == "palliative" || key0 == "confirmed" || key0 == "severe" || key0 == "critical" || key0 == "fatal");

            if (isAdditional0) {
              var err = {
                keyword: "additionalProperties",
                dataPath: (dataPath || "") + "",
                schemaPath: "#/additionalProperties",
                params: {
                  additionalProperty: "" + key0 + ""
                },
                message: "should NOT have additional properties"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          }

          var data1 = data.ageGroup;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "ageGroup"
              },
              message: "should have required property 'ageGroup'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 !== "string") {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/type",
                params: {
                  type: "string"
                },
                message: "should be string"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var schema2 = refVal1["enum"];
            var valid2;
            valid2 = false;

            for (var i2 = 0; i2 < schema2.length; i2++) {
              if (equal(data1, schema2[i2])) {
                valid2 = true;
                break;
              }
            }

            if (!valid2) {
              var err = {
                keyword: "enum",
                dataPath: (dataPath || "") + "/ageGroup",
                schemaPath: "AgeGroup#/enum",
                params: {
                  allowedValues: schema2
                },
                message: "should be equal to one of the allowed values"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.isolated;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "isolated"
              },
              message: "should have required property 'isolated'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/isolated",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/isolated",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/isolated",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.palliative;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "palliative"
              },
              message: "should have required property 'palliative'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/palliative",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/palliative",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/palliative",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.confirmed;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "confirmed"
              },
              message: "should have required property 'confirmed'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/confirmed",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/confirmed",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/confirmed",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.severe;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "severe"
              },
              message: "should have required property 'severe'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/severe",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/severe",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/severe",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.critical;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "critical"
              },
              message: "should have required property 'critical'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/critical",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/critical",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/critical",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }

          var data1 = data.fatal;

          if (data1 === undefined) {
            var err = {
              keyword: "required",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/required",
              params: {
                missingProperty: "fatal"
              },
              message: "should have required property 'fatal'"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          } else {
            var errs_2 = errors;

            if (typeof data1 === "number") {
              if (data1 > 100 || data1 !== data1) {
                var err = {
                  keyword: "maximum",
                  dataPath: (dataPath || "") + "/fatal",
                  schemaPath: "Percentage#/maximum",
                  params: {
                    comparison: "<=",
                    limit: 100,
                    exclusive: false
                  },
                  message: "should be <= 100"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }

              if (data1 < 0 || data1 !== data1) {
                var err = {
                  keyword: "minimum",
                  dataPath: (dataPath || "") + "/fatal",
                  schemaPath: "Percentage#/minimum",
                  params: {
                    comparison: ">=",
                    limit: 0,
                    exclusive: false
                  },
                  message: "should be >= 0"
                };
                if (vErrors === null) vErrors = [err];else vErrors.push(err);
                errors++;
              }
            } else {
              var err = {
                keyword: "type",
                dataPath: (dataPath || "") + "/fatal",
                schemaPath: "Percentage#/type",
                params: {
                  type: "number"
                },
                message: "should be number"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }

            var valid2 = errors === errs_2;
          }
        } else {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/type",
            params: {
              type: "object"
            },
            message: "should be object"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        validate.errors = vErrors;
        return errors === 0;
      };
    }();

    refVal1.schema = {
      $schema: "http://json-schema.org/draft-07/schema",
      $id: "SeverityDistributionDatum",
      title: "SeverityDistributionDatum",
      additionalProperties: false,
      type: "object",
      required: ["ageGroup", "isolated", "palliative", "confirmed", "severe", "critical", "fatal"],
      properties: {
        ageGroup: {
          $ref: "AgeGroup#"
        },
        isolated: {
          $ref: "Percentage#"
        },
        palliative: {
          $ref: "Percentage#"
        },
        confirmed: {
          $ref: "Percentage#"
        },
        severe: {
          $ref: "Percentage#"
        },
        critical: {
          $ref: "Percentage#"
        },
        fatal: {
          $ref: "Percentage#"
        }
      }
    };
    refVal1.errors = null;
    refVal[1] = refVal1;
    return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

      var vErrors = null;
      var errors = 0;
      if (rootData === undefined) rootData = data;

      if (data && typeof data === "object" && !Array.isArray(data)) {

        for (var key0 in data) {
          var isAdditional0 = !( key0 == "name" || key0 == "data");

          if (isAdditional0) {
            var err = {
              keyword: "additionalProperties",
              dataPath: (dataPath || "") + "",
              schemaPath: "#/additionalProperties",
              params: {
                additionalProperty: "" + key0 + ""
              },
              message: "should NOT have additional properties"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.name;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "name"
            },
            message: "should have required property 'name'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (typeof data1 === "string") {
            if (ucs2length(data1) < 1) {
              var err = {
                keyword: "minLength",
                dataPath: (dataPath || "") + "/name",
                schemaPath: "#/properties/name/minLength",
                params: {
                  limit: 1
                },
                message: "should NOT be shorter than 1 characters"
              };
              if (vErrors === null) vErrors = [err];else vErrors.push(err);
              errors++;
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/name",
              schemaPath: "#/properties/name/type",
              params: {
                type: "string"
              },
              message: "should be string"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }

        var data1 = data.data;

        if (data1 === undefined) {
          var err = {
            keyword: "required",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/required",
            params: {
              missingProperty: "data"
            },
            message: "should have required property 'data'"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        } else {

          if (Array.isArray(data1)) {

            for (var i1 = 0; i1 < data1.length; i1++) {

              if (!refVal1(data1[i1], (dataPath || "") + "/data/" + i1, data1, i1, rootData)) {
                if (vErrors === null) vErrors = refVal1.errors;else vErrors = vErrors.concat(refVal1.errors);
                errors = vErrors.length;
              }
            }
          } else {
            var err = {
              keyword: "type",
              dataPath: (dataPath || "") + "/data",
              schemaPath: "#/properties/data/type",
              params: {
                type: "array"
              },
              message: "should be array"
            };
            if (vErrors === null) vErrors = [err];else vErrors.push(err);
            errors++;
          }
        }
      } else {
        var err = {
          keyword: "type",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/type",
          params: {
            type: "object"
          },
          message: "should be object"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      }

      validate.errors = vErrors;
      return errors === 0;
    };
  }();

  refVal4.schema = {
    $schema: "http://json-schema.org/draft-07/schema",
    $id: "SeverityDistributionData",
    title: "SeverityDistributionData",
    type: "object",
    additionalProperties: false,
    required: ["name", "data"],
    properties: {
      name: {
        type: "string",
        minLength: 1
      },
      data: {
        type: "array",
        items: {
          $ref: "SeverityDistributionDatum#"
        }
      }
    }
  };
  refVal4.errors = null;
  refVal[4] = refVal4;
  return function validate(data, dataPath, parentData, parentDataProperty, rootData) {

    var vErrors = null;
    var errors = 0;
    if (rootData === undefined) rootData = data;

    if (data && typeof data === "object" && !Array.isArray(data)) {

      for (var key0 in data) {
        var isAdditional0 = !( key0 == "schemaVer" || key0 == "scenarioData" || key0 == "ageDistributionData" || key0 == "severityDistributionData");

        if (isAdditional0) {
          var err = {
            keyword: "additionalProperties",
            dataPath: (dataPath || "") + "",
            schemaPath: "#/additionalProperties",
            params: {
              additionalProperty: "" + key0 + ""
            },
            message: "should NOT have additional properties"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }
      }

      var data1 = data.schemaVer;

      if (data1 === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "schemaVer"
          },
          message: "should have required property 'schemaVer'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {
        var errs_2 = errors;

        if (typeof data1 !== "string") {
          var err = {
            keyword: "type",
            dataPath: (dataPath || "") + "/schemaVer",
            schemaPath: "_SchemaVer#/type",
            params: {
              type: "string"
            },
            message: "should be string"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        var schema2 = refVal1["const"];
        var valid2 = equal(data1, schema2);

        if (!valid2) {
          var err = {
            keyword: "const",
            dataPath: (dataPath || "") + "/schemaVer",
            schemaPath: "_SchemaVer#/const",
            params: {
              allowedValue: schema2
            },
            message: "should be equal to constant"
          };
          if (vErrors === null) vErrors = [err];else vErrors.push(err);
          errors++;
        }

        var valid2 = errors === errs_2;
      }

      if (data.scenarioData === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "scenarioData"
          },
          message: "should have required property 'scenarioData'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {

        if (!refVal2(data.scenarioData, (dataPath || "") + "/scenarioData", data, "scenarioData", rootData)) {
          if (vErrors === null) vErrors = refVal2.errors;else vErrors = vErrors.concat(refVal2.errors);
          errors = vErrors.length;
        }
      }

      if (data.ageDistributionData === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "ageDistributionData"
          },
          message: "should have required property 'ageDistributionData'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {

        if (!refVal3(data.ageDistributionData, (dataPath || "") + "/ageDistributionData", data, "ageDistributionData", rootData)) {
          if (vErrors === null) vErrors = refVal3.errors;else vErrors = vErrors.concat(refVal3.errors);
          errors = vErrors.length;
        }
      }

      if (data.severityDistributionData === undefined) {
        var err = {
          keyword: "required",
          dataPath: (dataPath || "") + "",
          schemaPath: "#/required",
          params: {
            missingProperty: "severityDistributionData"
          },
          message: "should have required property 'severityDistributionData'"
        };
        if (vErrors === null) vErrors = [err];else vErrors.push(err);
        errors++;
      } else {

        if (!refVal4(data.severityDistributionData, (dataPath || "") + "/severityDistributionData", data, "severityDistributionData", rootData)) {
          if (vErrors === null) vErrors = refVal4.errors;else vErrors = vErrors.concat(refVal4.errors);
          errors = vErrors.length;
        }
      }
    } else {
      var err = {
        keyword: "type",
        dataPath: (dataPath || "") + "",
        schemaPath: "#/type",
        params: {
          type: "object"
        },
        message: "should be object"
      };
      if (vErrors === null) vErrors = [err];else vErrors.push(err);
      errors++;
    }

    validate.errors = vErrors;
    return errors === 0;
  };
}();

validate$3.schema = {
  $schema: "http://json-schema.org/draft-07/schema",
  $id: "Shareable",
  title: "Shareable",
  type: "object",
  additionalProperties: false,
  required: ["schemaVer", "scenarioData", "ageDistributionData", "severityDistributionData"],
  properties: {
    schemaVer: {
      $ref: "_SchemaVer#"
    },
    scenarioData: {
      $ref: "ScenarioData#"
    },
    ageDistributionData: {
      $ref: "AgeDistributionData#"
    },
    severityDistributionData: {
      $ref: "SeverityDistributionData#"
    }
  }
};
validate$3.errors = null;
var validateShareable$1 = validate$3;

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));
}

var _parent = parent;

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = _castPath(path, object);
  object = _parent(object, path);
  return object == null || delete object[_toKey(last_1(path))];
}

var _baseUnset = baseUnset;

/** `Object#toString` result references. */
var objectTag$4 = '[object Object]';

/** Used for built-in method references. */
var funcProto$2 = Function.prototype,
    objectProto$f = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$e = objectProto$f.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString$2.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$4) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$e.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString$2.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject;

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject_1(value) ? undefined : value;
}

var _customOmitClone = customOmitClone;

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray_1(value) || isArguments_1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

var _isFlattenable = isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

var _baseFlatten = baseFlatten;

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? _baseFlatten(array, 1) : [];
}

var flatten_1 = flatten;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var _apply = apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

var _overRest = overRest;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var constant_1 = constant;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty$1 ? identity_1 : function(func, string) {
  return _defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant_1(string),
    'writable': true
  });
};

var _baseSetToString = baseSetToString;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

var _setToString = setToString;

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return _setToString(_overRest(func, undefined, flatten_1), func + '');
}

var _flatRest = flatRest;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$2 = 1,
    CLONE_FLAT_FLAG$1 = 2,
    CLONE_SYMBOLS_FLAG$2 = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = _flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = _arrayMap(paths, function(path) {
    path = _castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  _copyObject(object, _getAllKeysIn(object), result);
  if (isDeep) {
    result = _baseClone(result, CLONE_DEEP_FLAG$2 | CLONE_FLAT_FLAG$1 | CLONE_SYMBOLS_FLAG$2, _customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    _baseUnset(result, paths[length]);
  }
  return result;
});

var omit_1 = omit;

const rnds8 = new Uint8Array(16);
function rng() {
  return crypto.randomFillSync(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate$4(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify$4(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate$4(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify$4(rnds);
}

function uuidv4() {
  return v4();
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
function addId(interval) {
  return _objectSpread(_objectSpread({}, interval), {}, {
    id: uuidv4()
  });
}
function removeId(interval) {
  return omit_1(interval, 'id');
}
function toInternal(scenario) {
  var mitigationIntervals = scenario.mitigation.mitigationIntervals;
  return _objectSpread(_objectSpread({}, scenario), {}, {
    mitigation: _objectSpread(_objectSpread({}, scenario.mitigation), {}, {
      mitigationIntervals: mitigationIntervals.map(addId)
    })
  });
}
function toExternal(scenario) {
  var mitigationIntervals = scenario.mitigation.mitigationIntervals;
  return _objectSpread(_objectSpread({}, scenario), {}, {
    mitigation: _objectSpread(_objectSpread({}, scenario.mitigation), {}, {
      mitigationIntervals: mitigationIntervals.map(removeId)
    })
  });
}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var schemaVer = '2.1.0';

function serialize(scenarioParameters) {
  var shareable = _objectSpread$1(_objectSpread$1({}, scenarioParameters), {}, {
    schemaVer: schemaVer,
    scenarioData: _objectSpread$1(_objectSpread$1({}, scenarioParameters.scenarioData), {}, {
      data: toExternal(scenarioParameters.scenarioData.data)
    })
  });

  var serialized = Convert.shareableToJson(shareable);

  if (process.env.NODE_ENV !== 'production' && !validateShareable$1(JSON.parse(serialized))) {
    throw validateShareable$1.errors;
  }

  return serialized;
}

function validateSchema$1(shareableDangerous) {
  if (!validateShareable$1(shareableDangerous)) {
    var _ajvLocalizers$locale;

    var locale = 'en'; // TODO: use current locale

    var localize$1 = (_ajvLocalizers$locale = localize[locale]) !== null && _ajvLocalizers$locale !== void 0 ? _ajvLocalizers$locale : localize.en;
    localize$1(validateShareable$1.errors);
    var ajv$1 = ajv({
      allErrors: true
    });
    var separator = '<<<NEWLINE>>>';
    var errorString = ajv$1.errorsText(validateShareable$1.errors, {
      dataVar: '',
      separator: separator
    });

    if (typeof errorString === 'string') {
      var errorStrings = errorString.split(separator).map(trim_1);

      if (errorStrings.length > 0) {
        throw new DeserializationErrorValidationFailed(errorStrings);
      }
    }

    throw new DeserializationErrorValidationFailed(['Unknown validation error']);
  }
}

function convert(shareableDangerous) {
  try {
    return Convert.toShareable(JSON.stringify(shareableDangerous));
  } catch (error) {
    if (error instanceof Error) {
      throw new DeserializationErrorConversionFailed(error.message);
    }

    throw new DeserializationErrorConversionFailed('Unknown conversion error');
  }
}

function validateMore(shareable) {
  var scenarioData = shareable.scenarioData,
      ageDistributionData = shareable.ageDistributionData,
      severityDistributionData = shareable.severityDistributionData;

  if (scenarioData.data.population.ageDistributionName !== ageDistributionData.name) {
    throw new DeserializationErrorValidationFailed(['/scenarioData/data/population/ageDistributionName should be equal to /ageDistributionData/name']);
  }

  var ageDistributionCategories = ageDistributionData.data.map(function (_ref) {
    var ageGroup = _ref.ageGroup;
    return ageGroup;
  });
  var severityCategories = severityDistributionData.data.map(function (_ref2) {
    var ageGroup = _ref2.ageGroup;
    return ageGroup;
  });

  if (!isEqual_1(ageDistributionCategories, severityCategories)) {
    throw new DeserializationErrorValidationFailed(['arrays /ageDistributionData/data[] and /severityDistributionData/data[] should contain the same number of the same values for ageGroup']);
  }
}

function deserialize(input) {
  var shareableDangerous = JSON.parse(input);
  validateSchema$1(shareableDangerous);
  var shareable = convert(shareableDangerous);
  validateMore(shareable);
  var scenarioData = shareable.scenarioData,
      ageDistributionData = shareable.ageDistributionData,
      severityDistributionData = shareable.severityDistributionData;
  return {
    scenarioData: _objectSpread$1(_objectSpread$1({}, scenarioData), {}, {
      data: toInternal(scenarioData.data)
    }),
    ageDistributionData: ageDistributionData,
    severityDistributionData: severityDistributionData
  };
}

var v2_1_0 = _defineProperty({}, schemaVer, {
  serialize: serialize,
  deserialize: deserialize
});

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var schemaVer$1 = '2.0.0';
var schemaVerNext = '2.1.0';
function serialize$1(_0) {
  throw new Error(": Developer error: This function should never be called.\n  Serialization must always use the latest version of the serializer, but serializer of version \"".concat(schemaVer$1, "\" is called instead.\n  Change the callee to use the latest version."));
}

function validateSchema$2(shareableDangerous) {
  if (!validateShareable(shareableDangerous)) {
    var _ajvLocalizers$locale;

    var locale = 'en'; // TODO: use current locale

    var localize$1 = (_ajvLocalizers$locale = localize[locale]) !== null && _ajvLocalizers$locale !== void 0 ? _ajvLocalizers$locale : localize.en;
    localize$1(validateShareable.errors);
    var ajv$1 = ajv({
      allErrors: true
    });
    var separator = '<<<NEWLINE>>>';
    var errorString = ajv$1.errorsText(validateShareable.errors, {
      dataVar: '',
      separator: separator
    });

    if (typeof errorString === 'string') {
      var errorStrings = errorString.split(separator).map(trim_1);

      if (errorStrings.length > 0) {
        throw new DeserializationErrorValidationFailed(errorStrings);
      }
    }

    throw new DeserializationErrorValidationFailed(['Unknown validation error']);
  }
}

function convert$1(shareableDangerous) {
  try {
    return Convert$1.toShareable(JSON.stringify(shareableDangerous));
  } catch (error) {
    if (error instanceof Error) {
      throw new DeserializationErrorConversionFailed(error.message);
    }

    throw new DeserializationErrorConversionFailed('Unknown conversion error');
  }
}

function deserialize$1(input) {
  var shareableDangerous = JSON.parse(input);
  validateSchema$2(shareableDangerous);
  var shareable = convert$1(shareableDangerous); // Migrate object to schema v2.1.0:
  //  - Add palliative severities and set them to 0

  var shareableNew = _objectSpread$2(_objectSpread$2({}, shareable), {}, {
    schemaVer: schemaVerNext,
    severityDistributionData: _objectSpread$2(_objectSpread$2({}, shareable.severityDistributionData), {}, {
      data: shareable.severityDistributionData.data.map(function (severity) {
        return _objectSpread$2(_objectSpread$2({}, severity), {}, {
          palliative: 0
        });
      })
    })
  }); // Delegate to the next version of deserializer


  return v2_1_0[schemaVerNext].deserialize(JSON.stringify(shareableNew));
}

var v2_0_0 = _defineProperty({}, schemaVer$1, {
  serialize: serialize$1,
  deserialize: deserialize$1
});

var _last2;

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SERIALIZERS = new Map(Object.entries(_objectSpread$3(_objectSpread$3({}, v2_0_0), v2_1_0)));
var SERIALIZER_VERSIONS = semver$1.sort(Array.from(SERIALIZERS.keys()));
var SERIALIZER_VERSION_LATEST = (_last2 = last_1(SERIALIZER_VERSIONS)) !== null && _last2 !== void 0 ? _last2 : 'NO_SERIALIZERS';
var SERIALIZER_LATEST = getOrThrow(SERIALIZERS, SERIALIZER_VERSION_LATEST);

function deserialize$2(dataString) {
  try {
    var shareableDangerous = JSON.parse(dataString);
    var schemaVer = semver$1.valid(shareableDangerous === null || shareableDangerous === void 0 ? void 0 : shareableDangerous.schemaVer);

    if (schemaVer) {
      var _SERIALIZERS$get;

      var _deserialize = (_SERIALIZERS$get = SERIALIZERS.get(schemaVer)) === null || _SERIALIZERS$get === void 0 ? void 0 : _SERIALIZERS$get.deserialize;

      if (_deserialize) {
        return _deserialize(dataString);
      }

      throw new DeserializationErrorSchemaVersionInvalid(schemaVer, SERIALIZER_VERSIONS);
    }

    throw new DeserializationErrorSchemaVersionMissing();
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new DeserializationErrorJsonSyntaxInvalid(error.message);
    } else {
      throw error;
    }
  }
}

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var handleRejection = function handleRejection(err) {
  console.error(err);
  process.exit(1);
};

process.on('unhandledRejection', handleRejection);
/**
 * Run the model //TODO: these docs
 *
 * @param params: ScenarioFlat  it's got some properties to it
 * @param severity              Severity array
 * @param ageDistribution       Age distribution array
 */

function runModel(_x, _x2, _x3) {
  return _runModel.apply(this, arguments);
}
/**
 * Read a file in JSON format.
 *
 * @param inputFilename The path to the file.
 */

function _runModel() {
  _runModel = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(params, severity, ageDistribution) {
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", run({
              params: params,
              severity: severity,
              ageDistribution: ageDistribution
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _runModel.apply(this, arguments);
}

function readJsonFromFile(inputFilename) {
  console.info("Reading data from file ".concat(inputFilename));
  return lib.readJsonSync(inputFilename, {
    encoding: 'utf8'
  });
}
/**
 * Get severity distribution data. If a file is specified on the command
 * line, give priority to its contents, else load a default distribution.
 *
 * @param inputFilename The path to the file.
 */


function getSeverity(inputFilename) {
  if (inputFilename) {
    var data = readJsonFromFile(inputFilename);
    return data.data;
  }

  var dataRaw = readJsonFromFile('./src/assets/data/severityDistributions.json');
  var severityDistributionFound = dataRaw.all.find(function (s) {
    return s.name === DEFAULT_SEVERITY_DISTRIBUTION;
  });

  if (!severityDistributionFound) {
    throw new Error("Error: scenario not found");
  }

  var severityDistribution = Convert.toSeverityDistributionData(JSON.stringify(severityDistributionFound));
  severityDistribution.data.sort(function (a, b) {
    if (a.ageGroup > b.ageGroup) {
      return +1;
    }

    if (a.ageGroup < b.ageGroup) {
      return -1;
    }

    return 0;
  });
  return severityDistribution.data;
}
/**
 * Get age distribution data. If a file is specified on the command
 * line, give priority to its contents, else load the distribution
 * name as specified in the scenario parameters.
 *
 * @param inputFilename The path to the file.
 * @param name The age distribution name to use if no file is
 *             specified.
 */


function getAge(inputFilename, name) {
  if (inputFilename) {
    var data = readJsonFromFile(inputFilename);
    return data.data;
  }

  var dataRaw = readJsonFromFile('./src/assets/data/ageDistribution.json');
  var ageDistributionFound = dataRaw.all.find(function (cad) {
    return cad.name === name;
  });

  if (!ageDistributionFound) {
    throw new Error("Error: country age distribution \"".concat(name, "\" not found in JSON"));
  }

  var ageDistribution = Convert.toAgeDistributionData(JSON.stringify(ageDistributionFound)); // eslint-disable-next-line sonarjs/no-identical-functions

  ageDistribution.data.sort(function (a, b) {
    if (a.ageGroup > b.ageGroup) {
      return +1;
    }

    if (a.ageGroup < b.ageGroup) {
      return -1;
    }

    return 0;
  });
  return ageDistribution.data;
}

function main() {
  return _main.apply(this, arguments);
}

function _main() {
  _main = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
    var argv, scenarioData, scenario, mitigationIntervals, i, severity, ageDistribution, scenarioDataToSerialize, ageDistributionDataToSerialize, severityDataToSerialize, scenarioParamsToSerialize, params, errors, outputFile, result;
    return regenerator.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // Command line argument processing.
            argv = neodoc$1.run("\n    usage:  covid19_scenarios <scenario> <output> [options]\n            covid19_scenarios <scenario> <output> mitigation\n              (<mitTimeBegin> <mitTimeEnd>\n              <transmissionReductionLow> <transmissionReductionHigh>)...\n              [options]\n\n    options:\n      <scenario>            Path to scenario parameters JSON file\n      <output>              Path to output file\n\n      --age=<pathToAgeDistribution>\n                            Path to age distribution JSON file\n      --ageDistribution=<ageDistribution>\n                            Name of country for age distribution\n      --severity=<pathToSeverityDistribution>\n                            Path to severity JSON file\n      --hospitalStayDays=<hospitalStayDays>\n                            Average number of days a severe case stays in regular hospital beds\n      --icuStayDays=<icuStayDays>\n                            Average number of days a critical case stays in the Intensive Care Unit (ICU)\n      --infectiousPeriodDays=<infectiousPeriodDays>\n                            Average number of days a person is infectious\n      --latencyDays=<latencyDays>\n                            Time from infection to onset of symptoms (here onset of infectiousness)\n      --overflowSeverity=<overflowSeverity>\n                            A multiplicative factor to death rate to patients that require but do not have access to an Intensive Care Unit (ICU) bed relative to those who do\n      --peakMonth=<peakMonth>\n                            Time of the year with peak transmission (month as a number)\n      --r0Low=<r0Low>\n                            Average number of secondary infections per case (lower bound)\n      --r0High=<r0High>\n                            Average number of secondary infections per case (upper bound)\n      --ageDistributionName=<ageDistributionName>\n                            Name of age distribution data to use\n      --caseCountsName=<caseCountsName>\n                            Name of case count data to use\n      --hospitalBeds=<hospitalBeds>\n                            Number of hospital beds available\n      --icuBeds=<icuBeds>\n                            Number of available beds in Intensive Care Units (ICUs)\n      --importsPerDay=<importsPerDay>\n                            Number of cases imported from the outside per day on average\n      --initialNumberOfCases=<initialNumberOfCases>\n                            Number of cases present at the start of simulation\n      --populationServed=<populationServed>\n                            Number of people served by the healthcare system\n      --numberStochasticRuns=<numberStochasticRuns>\n                            Number of runs, to account for the uncertainty of parameters.\n      <mitTimeBegin>\n                            Start of mitigation time period (date in form yyyy-mm-dd)\n      <mitTimeEnd>\n                            End of mitigation time period (date in form yyyy-mm-dd)\n      <transmissionReductionLow>\n                            Intervention efficacy as a range of plausible multiplicative reductions of the base growth rate (low bound)\n      <transmissionReductionHigh>\n                            Intervention efficacy as a range of plausible multiplicative reductions of the base growth rate (high bound)\n      --simulationRangeBegin=<simulationRangeBegin>\n                            Beginning of simulation time range (date in form yyyy-mm-dd)\n      --simulationRangeEnd=<simulationRangeEnd>\n                            End of simulation time range (date in form yyyy-mm-dd)\n      --name=<name>\n                            Scenario name\n      --color=<color>\n                            Colorhex\n    ", {
              smartOptions: true
            }); // Read the scenario data.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

            scenarioData = readJsonFromFile(argv['<scenario>']);
            scenario = scenarioData.data;
            Object.keys(scenario.epidemiological).forEach(function (key) {
              if (argv["--".concat(key)]) {
                scenario.epidemiological[key] = argv["--".concat(key)];
              }
            });

            if (argv['--r0Low']) {
              scenario.epidemiological.r0.begin = +argv['--r0Low'];
            }

            if (argv['--r0High']) {
              scenario.epidemiological.r0.end = +argv['--r0High'];
            }

            Object.keys(scenario.population).forEach(function (key) {
              if (argv["--".concat(key)]) {
                scenario.population[key] = argv["--".concat(key)];
              }
            });

            if (argv['--numberStochasticRuns']) {
              scenario.simulation.numberStochasticRuns = +argv['--numberStochasticRuns'];
            }

            if (argv.mitigation) {
              mitigationIntervals = []; // eslint-disable-next-line no-loops/no-loops

              for (i = 0; i < argv['<mitTimeBegin>'].length; i += 1) {
                mitigationIntervals[i] = {
                  color: scenario.mitigation.mitigationIntervals[0].color,
                  name: "Intervention ".concat(i + 1),
                  timeRange: {
                    begin: argv['<mitTimeBegin>'][i] ? argv['<mitTimeBegin>'][i] : scenario.mitigation.mitigationIntervals[0].timeRange.begin,
                    end: argv['<mitTimeEnd>'][i] ? argv['<mitTimeEnd>'][i] : scenario.mitigation.mitigationIntervals[0].timeRange.end
                  },
                  transmissionReduction: {
                    begin: argv['<transmissionReductionLow>'][i] ? argv['<transmissionReductionLow>'][i] : scenario.mitigation.mitigationIntervals[0].transmissionReduction.begin,
                    end: argv['<transmissionReductionHigh>'][i] ? argv['<transmissionReductionHigh>'][i] : scenario.mitigation.mitigationIntervals[0].transmissionReduction.end
                  }
                };
              }

              scenario.mitigation.mitigationIntervals = mitigationIntervals;
            }

            scenario.population.ageDistributionName = argv['--ageDistribution'] ? argv['--ageDistribution'] : scenario.population.ageDistributionName; // Load severity and age data.

            severity = getSeverity(argv['--severity']);
            ageDistribution = getAge(argv['--age'], scenario.population.ageDistributionName);
            scenarioDataToSerialize = {
              name: scenarioData.name,
              data: scenario
            };
            ageDistributionDataToSerialize = {
              name: scenario.population.ageDistributionName,
              data: ageDistribution
            };
            severityDataToSerialize = {
              name: 'China CDC',
              data: severity
            };
            scenarioParamsToSerialize = {
              schemaVer: '2.1.0',
              scenarioData: scenarioDataToSerialize,
              ageDistributionData: ageDistributionDataToSerialize,
              severityDistributionData: severityDataToSerialize
            };
            params = _objectSpread$4(_objectSpread$4(_objectSpread$4(_objectSpread$4({}, scenario.population), scenario.epidemiological), scenario.simulation), scenario.mitigation);

            try {
              deserialize$2(JSON.stringify(scenarioParamsToSerialize));
            } catch (error) {
              if (error instanceof DeserializationError) {
                errors = error.errors;
                console.error("when deserializing: validation failed:\n".concat(errors.map(appendDash).join('\n')));
                process.exit(1);
              } else {
                console.error("when deserializing: unknown error occured\n".concat(error));
                process.exit(1);
              }
            } // Run the model.


            _context2.prev = 18;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            outputFile = argv['<output>'];
            console.info('Running the model');
            _context2.next = 23;
            return runModel(params, severity, ageDistribution);

          case 23:
            result = _context2.sent;
            console.info('Run complete');
            console.info("Writing output to ".concat(outputFile));
            lib.writeFileSync(outputFile, JSON.stringify(result));
            _context2.next = 33;
            break;

          case 29:
            _context2.prev = 29;
            _context2.t0 = _context2["catch"](18);
            console.error("Run failed: ".concat(_context2.t0));
            process.exit(1);

          case 33:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[18, 29]]);
  }));
  return _main.apply(this, arguments);
}

main();

export { runModel };
